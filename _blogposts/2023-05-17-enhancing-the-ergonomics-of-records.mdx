---
author: rescript-team
date: "2023-05-17"
title: Enhancing the ergonomics of records
badge: roadmap
description: |
  A tour of new capabilities coming in ReScript v11
---

> This is the second post covering new capabilities that'll ship in ReScript v11. You can check out the first post on [better interop with customizable variants here](https://rescript-lang.org/blog/improving-interop).

[Records](https://rescript-lang.org/docs/manual/latest/record) are a fundamental part of ReScript, offering a clear and concise definition of complex data structures, immutability by default, great error messages, and support for exhaustive pattern matching.

However, working with records is not without friction. They need to be defined before they're used, can't be extended, and you can't pass parts of them around, because they're "all or nothing". Some of these constraints are what enables the benefits of records. But, they can be slightly unergonomic at times. Especially compared to their close relative [structural objects](https://rescript-lang.org/docs/manual/latest/object#sidebar), that while lacking important features like pattern matching, does allow you to spread type definitions at creation, and leverage subtyping between types that share the same fields.

Because records are so much more powerful in general, we've been focusing on how using them can be more ergonomic and how we can bring some of the ergonomics of structural objects to them as well.

In ReScript v10 we added support for [optional record fields](https://rescript-lang.org/docs/manual/latest/record#optional-record-fields) to make constructing records with many optional fields easier. In ReScript v11, we're delighted to introduce two new features that will significantly boost your record manipulation capabilities: Record Type Spreads and Record Type Coercion. Let's delve into what these new features offer and how they can make working with records more ergonomic.

## Type Spreads

Before type spreads, creating a new record that was similar or extended from another record required spelling out every single field in the new definition. This was often tedious, error-prone and made code harder to maintain, especially when working with records with many fields.

In ReScript v11, you can now spread one or more record types into a new record type. It looks like this:

```rescript
type a = {
  id: string,
  name: string,
}

type b = {
  age: int
}

type c = {
  ...a,
  ...b,
  active: bool
}
```

`type c` will now be:

```rescript
type c = {
  id: string,
  name: string,
  age: int,
  active: bool,
}
```

Keeping it as straightforward as possible, spreads are essentially a 'copy-paste' operation for fields from one or more records to another, inlining the fields from the spread records into the new record.

This is going to be a much more ergonomic experience when working with types with many fields, where variations of the same underlying type are needed.

### Use case: extending the built in DOM nodes

This feature can be particularly useful when extending DOM nodes. For instance, in the case of the animation library Framer Motion, one could easily extend the native DOM types with additional properties specific to the library, leading to a more seamless and type-safe integration.

This is how you could bind to a `div` in Framer Motion with the new record type spreads:

```rescript
type animate = {} // definition omitted for brevity

// JsxDOM.domProps is a built-in record with all valid DOM node attributes
type divProps = {
  ...JsxDOM.domProps,
  initial?: animate,
  animate?: animate,
  whileHover?: animate,
  whileTap?: animate,
}

module Div = {
  @module("framer-motion") external make: divProps => Jsx.element = "div"
}
```

You can now use `<Div />` as a `<motion.div />` component from Framer Motion. And your type definition is now simple and easy to maintain.

## Type Coercion

Type coercion introduces an extra layer of flexibility when working with records. Now, records of the same shape can be coerced between each other. This means that we can cast record `a` to be record `b` at the type level, if they contain the same exact fields. An example:

```rescript
type a = {
  name: string,
  age: int,
}

type b = {
  name: string,
  age: int,
}

let nameFromB = (b: b) => b.name

let a: a = {
  name: "Name",
  age: 35,
}

let name = nameFromB(a :> b)
```

Notice how we _coerce_ the value `a` into the type `b` using the coercion operator `:>`. This works because they have the same fields.

Additionally, we can also coerce records from `a` to `b` whenever `a` is a super-set of `b` (i.e. `a` containing all the fields of `b`, and more). The same example as above, slightly altered:

```rescript
type a = {
  id: string,
  name: string,
  age: int,
  active: bool,
}

type b = {
  name: string,
  age: int,
}

let nameFromB = (b: b) => b.name

let a: a = {
  id: "1",
  name: "Name",
  age: 35,
  active: true,
}

let name = nameFromB(a :> b)
```

Notice how `a` now has more fields than `b`, but we can still coerce `a` to `b` because `b` has a subset of the fields of `a`.

### Coercing is explicit

To maintain the robustness of our type system, coercing is an explicit action. Records are still nominal, preserving the same guarantees as before. You can't accidentally pass record `a` as a `b` without explicitly coercing between them. This is crucial as it prevents accidental dependencies on shapes rather than records, ensuring type safety by forcing explicit coercion between types.

## Conclusion

The introduction of Record Type Spreads and Coercion in ReScript v11 will provide developers with even more powerful tools for manipulating and interacting with record types. We're eager to see how you'll leverage these new features in your ReScript projects. Happy coding!
