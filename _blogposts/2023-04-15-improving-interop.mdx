---
author: rescript-team
date: "2023-04-15"
title: Better interop with customizable variants
badge: roadmap
description: |
  A tour of new capabilities coming in ReScript v11
---

ReScript v11 is around the corner, and it comes packed with new features that will improve interop with JavaScript/TypeScript. We will shine some light on each significant feature in a series of blog posts.

Interop with JavaScript/TypeScript is a top priority for ReScript. Recently we've made some changes to the runtime representation of variants that'll allow you to use variants for a large number of new interop scenarios, zero cost. This is important, because variants is _the_ feature of ReScript, enabling great data modeling, pattern matching and more.

_Pattern matching_ is really the key here. The changes we've made will enable you to write idiomatic ReScript leveraging pattern matching in many more scenarios.

These changes will ship in `v11` of ReScript, and in this post we'll tell you all you need to know about them.

## TLDR;

This is a long post, so here's a summary for those of you who just want the broad strokes.

### Customizable runtime representation

We're making the runtime representation of variants customizable. This will allow you to cleanly map variants to external data and APIs in many more cases than before.

### Zero cost bindings to discriminated unions

Variants with inline records will map cleanly to JavaScript/TypeScript [discriminated unions](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#discriminating-unions).

Discriminated unions are getting more and more popular in TypeScript (for good reason!) and this will open up a whole new venue for simple interop for ReScript. It will let you effortlessly utilize the power of ReScript's pattern matching and similar features, without needing any runtime conversion.

In addition it'll also greatly improve debuggability, because the runtime representation will map cleanly to the variant type you've defined.

### Unboxed (untagged) variants

We also introduce untagged variants - variants where the underlying runtime representation can be a primitive, without a specific discriminator. This will let you cleanly map to things like heterogenous array items, nullable values, and more.

Now let's dive into the details.

## The current state

We have several tools available today in ReScript for binding to external values without having to convert them to a runtime representation ReScript understand. Most notably, we have polymorphic variants, allowing us to bind zero cost to string and number literals. An example:

```rescript
// These will both be represented as the strings
// "store-or-network" and "network-only" at runtime.
type myType = [#"store-or-network" | #"network-only"]
```

However, polymorphic variants have many [downsides when compared to regular variants](https://rescript-lang.org/docs/manual/latest/polymorphic-variant#variant-vs-polymorphic-variant).

They still have many good and valid use cases, but more often than not the reason for picking them has been their runtime representation mapping cleanly to external data. They are typically chosen even though choosing regular variants would almost always have been a better choice, all things equal.

In addition to this, there's currently no way to map to discriminated unions in TypeScript (which are getting more and more popular) without being forced to do manual runtime conversion of the discriminated union into a ReScript variant. This is cumbersome in the default case, and even more cumbersome when dealing with things like recursive structures, where each level of recursion needs to do explicit conversion.

With ReScript v11, these issues will finally be solved. Let us take you on a tour of what has changed, and how it improves on the current situation.

## Tagged variants

Variants with payloads have always been represented as a tagged union at runtime. Here's an example:

```rescript
type entity = User({name: string}) | Group({workingName: string})

let user = User({name: "Hello"})
```

This is represented as:

```javascript
var user = {
  TAG: /* User */ 0,
  name: "Hello",
};
```

However, this has been problematic when binding to external data because there has been no way to customize the discriminator (the `TAG` property) or how its value is represented for each variant case (`0` representing `User` here). This means that unless your external data is modeled the exact same way as above, which is unlikely, you'd be forced to convert to the structure ReScript expects at runtime.

To illustrate this, let's imagine we're binding to an external union that looks like this in TypeScript:

```typescript
type LoadingState =
  | { state: "loading"; ready: boolean }
  | { state: "error"; message: string }
  | { state: "done"; data: Data };
```

Currently, there's no good way to use a ReScript variant to represent this type without resorting to manual and error-prone runtime conversion. However, with the new functionality, binding to the above with no additional runtime cost is easy:

```rescript
@tag("state")
type loadingState = | @as("loading") Loading({ready: bool}) | @as("error") Error({message: string}) | @as("done") Done({data: data})

let state = Error({message: "Something went wrong!"})
```

This will compile to:

```javascript
var state = {
  state: "error",
  message: "Something went wrong!",
};
```

Let's break down what we've done to make this work:

- The `@tag` attribute lets you customize the discriminator (default: `TAG`). We're setting that to `"state"` so we map to what the external data looks like.
- Each variant case has an `@as` attribute. That controls what each variant case is discriminated on (default: the variant case name as string). We're setting all of the cases to their lowercase equivalent, because that's what the external data looks like.

The end result is clean and zero cost bindings to the external data, in a way that previously would require manual runtime conversion.

Now, let's look at a few more real-world examples.

### Binding to TypeScript enums

```typescript
// direction.ts
/** Direction of the action. */
enum Direction {
  /** The direction is up. */
  Up = "UP",

  /** The direction is down. */
  Down = "DOWN",

  /** The direction is left. */
  Left = "LEFT",

  /** The direction is right. */
  Right = "RIGHT",
}

export const myDirection = Direction.Up;
```

Previously, you'd be forced to use a polymorphic variant for this if you wanted clean, zero-cost interop:

```rescript
type direction = [#UP | #DOWN | #LEFT | #RIGHT]
@module("./direction.js") external myDirection: direction = "myDirection"
```

Notice a few things:

- We're forced to use the names of the enum payload, meaning it won't fully map to what you'd use in TypeScript
- There's no way to bring over the documentation strings, because polymorphic variants are structural, so there's no one source definition for them to look for docstrings on. This is true _even_ if you annotate with your explicitly written out polymorphic variant definition.

With the new runtime representation, this is how you'd bind to the above enum instead:

```rescript
/** Direction of the action. */
type direction =
  | /** The direction is up. */
  @as("UP")
  Up

  | /** The direction is down. */
  @as("DOWN")
  Down

  | /** The direction is left. */
  @as("LEFT")
  Left

  | /** The direction is right. */
  @as("RIGHT")
  Right

@module("./direction.js") external myDirection: direction = "myDirection"
```

Now, this maps 100% to the TypeScript code, including letting us bring over the documentation strings so we get a nice editor experience.

### String literals

The same logic is easily applied to string literals from TypeScript, only here the benefits is even larger, because string literals have the same limitations in TypeScript that polymorphic variants have in ReScript.

```typescript
// direction.ts
type direction = "UP" | "DOWN" | "LEFT" | "RIGHT";
```

There's no way to attach documentation strings to string literals in TypeScript, and you only get the actual value to interact with.

With the new customizable variants, you could bind to the above string literal type easily, but add documentation, and change the name you interact with in ReScript. And there's no runtime cost.

### Untagged variants

We've also implemented support for _untagged variants_. This will let you use variants to represent values that are primitives and literals in a way that hasn't been possible before.

We'll explain what this is and why it's useful by showing a number of real world examples. Let's start with a simple one on how we can now represent a heterogenous array.

```rescript
@unboxed type listItemValue = String(string) | Boolean(bool) | Number(float)

let myArray = [String("Hello"), Boolean(true), Boolean(false), Number(13.37)]
```

Here, each value will be _unboxed_ at runtime. That means that the variant payload will be all that's left, the variant case name wrapping the payload itself will be stripped out and the payload will be all that remains.

It, therefore, compiles to this JS:

```javascript
var myArray = ["hello", true, false, 13.37];
```

This was previously possible to do, leveraging a few tricks, when you didn't need to potentially read the values from the array again in ReScript. But, if you wanted to read back the values, you'd have to do a number of manual steps.

In the above example, reaching back into the values is as simple as pattern matching on them.

Let's look at a few more examples of what untagged variants enable.

### Pattern matching on nullable values

Previously, any value that might be `null` would need to be explicitly converted to an option by using for example `Nullable.toOption` before you could use pattern matching on it. Here's a typical example of how that could look:

```rescript
type userAge = {ageNum: Nullable.t<int>}

type rec user = {
  name: string,
  age: Nullable.t<userAge>,
  bestFriend: Nullable.t<user>,
}

let getBestFriendsAge = user =>
  switch user.bestFriend->Nullable.toOption {
  | Some({age}) =>
    switch age->Nullable.toOption {
    | None => None
    | Some({ageNum}) => ageNum->Nullable.toOption
    }
  | None => None
  }
```

As you can see, you need to convert each level of nullables explicitly, which makes it hard to fully utilize pattern matching. With the new unboxed variant representation, we'll instead be able to do this:

```rescript
// The type definition below is inlined here to examplify, but this definition will live in Core and be easily accessible
module Nullable = {
  @unboxed type t<'a> = Present('a) | @as(null) Null
}

type userAge = {ageNum: Nullable.t<int>}

type rec user = {
  name: string,
  age: Nullable.t<userAge>,
  bestFriend: Nullable.t<user>,
}

let getBestFriendsAge = user =>
  switch user.bestFriend {
  | Present({age: Present({ageNum: Present(ageNum)})}) => Some(ageNum)
  | _ => None
  }
```

> Notice how `@as` now allows us to say that an unboxed variant case should map to a specific underlying _primitive_. `Present` has a type variable, so it can hold any type. And since it's an unboxed type, only the payloads `'a` or `null` will be kept at runtime. That's where the magic comes from.

We can now utilize pattern matching fully without needing to do any conversion.

This has a few implications:

- Dealing with external data, that is often nullable and seldom guaranteed to map cleanly to `option` without needing conversion, becomes much easier and zero cost.
- Special handling like [@return(nullable)](https://rescript-lang.org/syntax-lookup#return-decorator) becomes redundant. This is good also because the current functionality does not work in all cases. The new functionality will work anywhere.

### Decoding and encoding JSON idiomatically

With unboxed variants, we have everything we need to define a JSON type:

```rescript
@unboxed
type rec json =
  | @as(false) False
  | @as(true) True
  | @as(null) Null
  | String(string)
  | Number(float)
  | Object(Js.Dict.t<json>)
  | Array(array<json>)

let myValidJsonValue = Array([String("Hi"), Number(123.)])
```

Here's an example of how you could write your own JSON decoders easily using the above, leveraging pattern matching:

```rescript
@unboxed
type rec json =
  | @as(false) False
  | @as(true) True
  | @as(null) Null
  | String(string)
  | Number(float)
  | Object(Js.Dict.t<json>)
  | Array(array<json>)

type rec user = {
  name: string,
  age: int,
  bestFriend: option<user>,
}

let rec decodeUser = json =>
  switch json {
  | Object(userDict) =>
    switch (
      userDict->Dict.get("name"),
      userDict->Dict.get("age"),
      userDict->Dict.get("bestFriend"),
    ) {
    | (Some(String(name)), Some(Number(age)), Some(maybeBestFriend)) =>
      Some({
        name,
        age: age->Float.toInt,
        bestFriend: maybeBestFriend->decodeUser,
      })
    | _ => None
    }
  | _ => None
  }

let decodeUsers = json =>
  switch json {
  | Array(array) => array->Array.map(decodeUser)->Array.keepSome
  | _ => []
  }
```

The point of this example isn't to showcase a perfect JSON decoder strategy, but rather show that the language itself will now have the building blocks to interact with JSON style data natively.

This can be extrapolated to many more cases, including easy and simple JSON encoders.

### Bonus: Exhaustive checked, future proofed mapping to external data

Included in the untagged variants functionality is also a built in way to handle when you receive data you didn't expect. Imagine this case:

```rescript
type userStatus = | @as("online") Online | @as("offline") Offline

let greetByStatus = status =>
  switch status {
  | Online => "Hello, you're here!"
  | Offline => "Oh, you're not online.."
  }
```

`userStatus` describes an enum coming from some API. You deploy your code, and everything is working well. But, imagine that the server now adds a `Idle` case without you having a chance to deploy code handling the new case? You'd get a match failure since there would be no code path to handle that new enum value.

However, there's a simple and solid solution for that now. Let's change our variant defintion to handle any value that might be added in the future.

```rescript
@unboxed
type userStatus = | @as("online") Online | @as("offline") Offline | FutureAddedValue(unknown)

let greetByStatus = status =>
  switch status {
  | Online => "Hello, you're here!"
  | Offline => "Oh, you're not online.."
  | FutureAddedValue(v) =>
    Logger.log(`Unknown value:`, v)
    "Oops, you have a status I didn't expect.."
  }
```

Now, any value that does not match `"online"` or `"offline"` will match `FutureAddedValue`. And, if we add new cases to `userStatus`, the compiler will still show us all places where we need to handle the new case, because this preserves exhaustiveness checking.

Let's distill what we've done and what that means:

- We've added a `FutureAddedValue(unknown)` case. This is what will capture any value that hasn't been matched by the other cases in the variant.
- `unknown` is a type representing something not known, and you can't really do much with it without classifying it to something known.
- In order for this to work, we also need to `@unbox` our type so the only thing remaining at runtime will be `unknown`.

> Note that the `FutureAddedValue` case can be called anything for this to work, the important thing is that the type is `@unboxed` and that the catch-all case has a payload of type `unknown`.

This is useful when interfacing with external data that might change. It's also useful when you know a piece of data might be one of a large amount of different things, but you only want to handle a few of those explictly. Like an enum from an API that might have 50 cases, but you only care about explicitly handling 3 of them.

## Wrapping up

We hope you'll enjoy using these new capabilities. Some of them are a big leap forward for ReScript's interop with JavaScript and TypeScript, and we hope they will simplify many scenarios and open up a few new doors.
