{
  "belt": {
    "id": "Belt",
    "name": "Belt",
    "docstrings": [
      "The ReScript standard library.\n\nBelt is currently mostly covering collection types. It has no string or date functions yet, although Belt.String is in the works. In the meantime, use [Js.String](js/string) for string functions and [Js.Date](js/date) for date functions.\n\n## Motivation\n\nBelt provides:\n\n- The **highest quality** immutable data structures in JavaScript.\n- Safety by default: A Belt function will never throw exceptions, unless it is\n  indicated explicitly in the function name (suffix \"Exn\").\n- Better performance and smaller code size running on the JS platform.\n- Ready for [Tree Shaking](https://webpack.js.org/guides/tree-shaking/).\n\n## Usage\n\nTo use modules from Belt, either refer to them by their fully qualified name (`Belt.List`, `Belt.Array` etc.) or open the `Belt` module by putting\n\n## Examples\n\n```rescript\nopen Belt\n```\n\nat the top of your source files. After opening Belt this way, `Array` will refer to `Belt.Array`, `List` will refer to `Belt.List` etc. in the subsequent code.\n\nIf you want to open Belt globally for all files in your project instead, you can put\n\n```json\n{\n  \"bsc-flags\": [\"-open Belt\"]\n}\n```\n\ninto your `bsconfig.json`.\n\n**Note**: this is the **only** `open` we encourage.\n\nExample usage:\n\n## Examples\n\n```rescript\nlet someNumbers = [1, 1, 4, 2, 3, 6, 3, 4, 2]\n\nlet greaterThan2UniqueAndSorted =\n  someNumbers\n  ->Belt.Array.keep(x => x > 2)\n  // convert to and from set to make values unique\n  ->Belt.Set.Int.fromArray\n  ->Belt.Set.Int.toArray // output is already sorted\n\nJs.log2(\"result\", greaterThan2UniqueAndSorted)\n```\n\n## Curried vs. Uncurried Callbacks\n\nFor functions taking a callback parameter, there are usually two versions\navailable:\n\n- curried (no suffix)\n- uncurried (suffixed with `U`)\n\nE.g.:\n\n## Examples\n\n```rescript\nlet forEach: (t<'a>, 'a => unit) => unit\n\nlet forEachU: (t<'a>, (. 'a) => unit) => unit\n```\n\nThe uncurried version will be faster in some cases, but for simplicity we recommend to stick with the curried version unless you need the extra performance.\n\nThe two versions can be invoked as follows:\n\n## Examples\n\n```rescript\n[\"a\", \"b\", \"c\"]->Belt.Array.forEach(x => Js.log(x))\n\n[\"a\", \"b\", \"c\"]->Belt.Array.forEachU((. x) => Js.log(x))\n```\n\n## Specialized Collections\n\nFor collections types like set or map, Belt provides both a generic module as well as specialized, more efficient implementations for string and int keys.\n\nFor example, Belt has the following set modules:\n\n- [Belt.Set](belt/set)\n- [Belt.Set.Int](belt/set/int)\n- [Belt.Set.String](belt/set/string)\n\n## Implementation Details\n\n### Array access runtime safety\n\nOne common confusion comes from the way Belt handles array access. It differs from than the default standard library's.\n\n## Examples\n\n```rescript\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == \"a\"\nlet capitalA = Js.String.toUpperCase(a)\nlet k = letters[10] // Raises an exception! The 10th index doesn't exist.\n```\n\nBecause Belt avoids exceptions and returns `options` instead, this code behaves differently:\n\n## Examples\n\n```rescript\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == Some(\"a\")\nlet captialA = Js.String.toUpperCase(a) // Type error! This code will not compile.\nlet k = letters[10] // k == None\n```\n\nAlthough we've fixed the problem where `k` raises an exception, we now have a type error when trying to capitalize `a`. There are a few things going on here:\n\n- Reason transforms array index access to the function `Array.get`. So `letters[0]` is the same as `Array.get(letters, 0)`.\n- The compiler uses whichever `Array` module is in scope. If you `open Belt`, then it uses `Belt.Array`.\n- `Belt.Array.get` returns values wrapped in options, so `letters[0] == Some(\"a\")`.\n\nFortunately, this is easy to fix:\n\n## Examples\n\n```rescript\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0]\n\n// Use a switch statement:\nlet capitalA =\n  switch a {\n  | Some(a) => Some(Js.String.toUpperCase(a))\n  | None => None\n  }\n\nlet k = letters[10] // k == None\n```\n\nWith that little bit of tweaking, our code now compiles successfully and is 100% free of runtime errors!\n\n### A Special Encoding for Collection Safety\n\nWhen we create a collection library for a custom data type we need a way to provide a comparator function. Take Set for example, suppose its element type is a pair of ints, it needs a custom compare function that takes two tuples and returns their order. The Set could not just be typed as Set.t (int \\* int) , its customized compare function needs to manifest itself in the signature, otherwise, if the user creates another customized compare function, the two collection could mix which would result in runtime error.\n\nWe use a phantom type to solve the problem:\n\n## Examples\n\n```rescript\nmodule Comparable1 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet1 = Belt.Set.make(~id=module(Comparable1))\n\nmodule Comparable2 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet2 = Belt.Set.make(~id=module(Comparable2))\n```\n\nHere, the compiler would infer `mySet1` and `mySet2` having different type, so e.g. a `merge` operation that tries to merge these two sets will correctly fail.\n\n## Examples\n\n```rescript\nlet mySet1: t<(int, int), Comparable1.identity>\nlet mySet2: t<(int, int), Comparable2.identity>\n```\n\n`Comparable1.identity` and `Comparable2.identity` are not the same using our encoding scheme."
    ],
    "items": []
  },
  "belt/hashmap/string": {
    "id": "Belt.HashMap.String",
    "name": "String",
    "docstrings": [
      "Specalized when key type is `string`, more efficient than the generic type"
    ],
    "items": [
      {
        "id": "Belt.HashMap.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.HashMap.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'b>"
      },
      {
        "id": "Belt.HashMap.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t<'b>"
      },
      {
        "id": "Belt.HashMap.String.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'b> => unit"
      },
      {
        "id": "Belt.HashMap.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.HashMap.String.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`setDone(tbl, k, v)` if `k` does not exist, add the binding `k,v`, otherwise,\nupdate the old value with the new `v`"
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.HashMap.String.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.HashMap.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.HashMap.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'b>, key) => bool"
      },
      {
        "id": "Belt.HashMap.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.HashMap.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'b>, (key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t<'b>, (key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.String.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "docstrings": [],
        "signature": "let keepMapInPlaceU: (t<'a>, (key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.String.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "docstrings": [],
        "signature": "let keepMapInPlace: (t<'a>, (key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.HashMap.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.HashMap.String.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.HashMap.String.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.HashMap.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.HashMap.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'a>, array<(key, 'a)>) => unit"
      },
      {
        "id": "Belt.HashMap.String.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t<'a> => array<int>"
      },
      {
        "id": "Belt.HashMap.String.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t<'a> => unit"
      }
    ]
  },
  "belt/hashmap/int": {
    "id": "Belt.HashMap.Int",
    "name": "Int",
    "docstrings": [
      "Specalized when key type is `int`, more efficient than the generic type"
    ],
    "items": [
      {
        "id": "Belt.HashMap.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.HashMap.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'b>"
      },
      {
        "id": "Belt.HashMap.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t<'b>"
      },
      {
        "id": "Belt.HashMap.Int.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'b> => unit"
      },
      {
        "id": "Belt.HashMap.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.HashMap.Int.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`setDone(tbl, k, v)` if `k` does not exist, add the binding `k,v`, otherwise,\nupdate the old value with the new `v`"
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.HashMap.Int.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.HashMap.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.HashMap.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'b>, key) => bool"
      },
      {
        "id": "Belt.HashMap.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.HashMap.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'b>, (key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t<'b>, (key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.Int.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "docstrings": [],
        "signature": "let keepMapInPlaceU: (t<'a>, (key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.Int.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "docstrings": [],
        "signature": "let keepMapInPlace: (t<'a>, (key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.HashMap.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.HashMap.Int.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.HashMap.Int.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.HashMap.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.HashMap.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'a>, array<(key, 'a)>) => unit"
      },
      {
        "id": "Belt.HashMap.Int.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t<'a> => array<int>"
      },
      {
        "id": "Belt.HashMap.Int.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t<'a> => unit"
      }
    ]
  },
  "belt/hashset/string": {
    "id": "Belt.HashSet.String",
    "name": "String",
    "docstrings": [
      "Specalized when key type is `string`, more efficient than the generic type",
      "This module is [`Belt.HashSet`]() specialized with key type to be a primitive type.\n\nIt is more efficient in general, the  API is the same with [`Belt.HashSet`]() except its key type is fixed,\nand identity is not needed(using the built-in one)\n\n**See** [`Belt.HashSet`]()"
    ],
    "items": [
      {
        "id": "Belt.HashSet.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.HashSet.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Belt.HashSet.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t"
      },
      {
        "id": "Belt.HashSet.String.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t => unit"
      },
      {
        "id": "Belt.HashSet.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.HashSet.String.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.String.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.HashSet.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, key) => bool"
      },
      {
        "id": "Belt.HashSet.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, key => unit) => unit"
      },
      {
        "id": "Belt.HashSet.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t, key => unit) => unit"
      },
      {
        "id": "Belt.HashSet.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'c, ('c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t, 'c, ('c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.HashSet.String.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t => unit"
      },
      {
        "id": "Belt.HashSet.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<key>"
      },
      {
        "id": "Belt.HashSet.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<key> => t"
      },
      {
        "id": "Belt.HashSet.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<key>) => unit"
      },
      {
        "id": "Belt.HashSet.String.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t => array<int>"
      }
    ]
  },
  "belt/hashset/int": {
    "id": "Belt.HashSet.Int",
    "name": "Int",
    "docstrings": [
      "Specalized when key type is `int`, more efficient than the generic type",
      "This module is [`Belt.HashSet`]() specialized with key type to be a primitive type.\n\nIt is more efficient in general, the  API is the same with [`Belt.HashSet`]() except its key type is fixed,\nand identity is not needed(using the built-in one)\n\n**See** [`Belt.HashSet`]()"
    ],
    "items": [
      {
        "id": "Belt.HashSet.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.HashSet.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Belt.HashSet.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t"
      },
      {
        "id": "Belt.HashSet.Int.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t => unit"
      },
      {
        "id": "Belt.HashSet.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.HashSet.Int.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.Int.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.HashSet.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, key) => bool"
      },
      {
        "id": "Belt.HashSet.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, key => unit) => unit"
      },
      {
        "id": "Belt.HashSet.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t, key => unit) => unit"
      },
      {
        "id": "Belt.HashSet.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'c, ('c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t, 'c, ('c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.HashSet.Int.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t => unit"
      },
      {
        "id": "Belt.HashSet.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<key>"
      },
      {
        "id": "Belt.HashSet.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<key> => t"
      },
      {
        "id": "Belt.HashSet.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<key>) => unit"
      },
      {
        "id": "Belt.HashSet.Int.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t => array<int>"
      }
    ]
  },
  "belt/mutablemap/string": {
    "id": "Belt.MutableMap.String",
    "name": "String",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.MutableMap.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.MutableMap.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableMap.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableMap.String.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableMap.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'a>, key) => bool"
      },
      {
        "id": "Belt.MutableMap.String.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(m1, m2, cmp)`. First compare by size, if size is the same, compare by key,\nvalue pair"
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.String.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2, cmp)`"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, (key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the key as\nfirst argument, and the associated value as second argument. The application \norder of `f` is in increasing order."
        ],
        "signature": "let forEach: (t<'a>, (key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `(f kN dN ... (f k1 d1 a)...)`, where `k1 ... kN` are\nthe keys of all bindings in `m` (in increasing order), and `d1 ... dN` are the\nassociated data."
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate `p`.\nThe application order of `p` is unspecified."
        ],
        "signature": "let every: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the predicate `p`.\nThe application order of `p` is unspecified."
        ],
        "signature": "let some: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableMap.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t<'a> => list<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.MutableMap.String.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.MutableMap.String.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.MutableMap.String.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.String.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.String.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.String.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.MutableMap.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'a>, key) => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableMap.String.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'a>, key, 'a) => 'a"
      },
      {
        "id": "Belt.MutableMap.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'a>, key) => 'a"
      },
      {
        "id": "Belt.MutableMap.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` do the in-place modification"
        ],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.MutableMap.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'a>, array<key>) => unit"
      },
      {
        "id": "Belt.MutableMap.String.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` do the in-place modification, return `m` for chaining. If `x` was\nalready bound in `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.MutableMap.String.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'a>, key, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.String.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'a>, key, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.String.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.String.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated value `a`\nof all bindings of `m` has been replaced by the result of the application of `f`\nto `a`. The bindings are passed to `f` in increasing order with respect to the\nordering over the type of the keys."
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.String.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'a>, (key, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.String.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'a>, (key, 'a) => 'b) => t<'b>"
      }
    ]
  },
  "belt/mutablemap/int": {
    "id": "Belt.MutableMap.Int",
    "name": "Int",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.MutableMap.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.MutableMap.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableMap.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'a>, key) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(m1, m2, cmp)`. First compare by size, if size is the same, compare by key,\nvalue pair"
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.Int.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2, cmp)`"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, (key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the key as\nfirst argument, and the associated value as second argument. The application \norder of `f` is in increasing order."
        ],
        "signature": "let forEach: (t<'a>, (key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `(f kN dN ... (f k1 d1 a)...)`, where `k1 ... kN` are\nthe keys of all bindings in `m` (in increasing order), and `d1 ... dN` are the\nassociated data."
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate `p`.\nThe application order of `p` is unspecified."
        ],
        "signature": "let every: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the predicate `p`.\nThe application order of `p` is unspecified."
        ],
        "signature": "let some: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableMap.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t<'a> => list<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.MutableMap.Int.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.Int.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.Int.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.Int.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'a>, key) => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'a>, key, 'a) => 'a"
      },
      {
        "id": "Belt.MutableMap.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'a>, key) => 'a"
      },
      {
        "id": "Belt.MutableMap.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` do the in-place modification"
        ],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'a>, array<key>) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` do the in-place modification, return `m` for chaining. If `x` was\nalready bound in `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'a>, key, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'a>, key, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.Int.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated value `a`\nof all bindings of `m` has been replaced by the result of the application of `f`\nto `a`. The bindings are passed to `f` in increasing order with respect to the\nordering over the type of the keys."
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.Int.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'a>, (key, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.Int.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'a>, (key, 'a) => 'b) => t<'b>"
      }
    ]
  },
  "belt/mutableset/string": {
    "id": "Belt.MutableSet.String",
    "name": "String",
    "docstrings": [
      "Specialized when key type is `string`, more efficient than the generic type",
      "This module is [`Belt.MutableSet`]() specialized with key type to be a primitive type.\n\nIt is more efficient in general, the  API is the same with [`Belt.MutableSet`]() except its key type is fixed,\nand identity is not needed(using the built-in one)\n\n**See** [`Belt.MutableSet`]()"
    ],
    "items": [
      {
        "id": "Belt.MutableSet.String.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = string"
      },
      {
        "id": "Belt.MutableSet.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.MutableSet.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t"
      },
      {
        "id": "Belt.MutableSet.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.String.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.String.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.MutableSet.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.MutableSet.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.String.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.String.addCheck",
        "kind": "value",
        "name": "addCheck",
        "docstrings": [],
        "signature": "let addCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.String.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "docstrings": [],
        "signature": "let removeCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.String.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.String.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.String.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.String.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.MutableSet.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(p, s)` checks if all elements of the set satisfy the predicate `p`.\nOrder unspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(p, s)` checks if at least one element of the set satisfies the predicate\n`p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, value => bool) => t"
      },
      {
        "id": "Belt.MutableSet.String.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(s, p)` returns a fresh copy of the set of all elements in `s` that satisfy\npredicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.MutableSet.String.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.String.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(s, p)` returns a fresh copy pair of sets `(s1, s2)`, where `s1` is\nthe set of all the elements of `s` that satisfy the predicate `p`, and `s2` is\nthe set of all the elements of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.MutableSet.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.MutableSet.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.MutableSet.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.MutableSet.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.MutableSet.String.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(s, key)` return a fresh copy of each"
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.MutableSet.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/mutableset/int": {
    "id": "Belt.MutableSet.Int",
    "name": "Int",
    "docstrings": [
      "Specialized when key type is `int`, more efficient than the generic type",
      "This module is [`Belt.MutableSet`]() specialized with key type to be a primitive type.\n\nIt is more efficient in general, the  API is the same with [`Belt.MutableSet`]() except its key type is fixed,\nand identity is not needed(using the built-in one)\n\n**See** [`Belt.MutableSet`]()"
    ],
    "items": [
      {
        "id": "Belt.MutableSet.Int.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = int"
      },
      {
        "id": "Belt.MutableSet.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.MutableSet.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t"
      },
      {
        "id": "Belt.MutableSet.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.Int.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.Int.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.MutableSet.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.MutableSet.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.addCheck",
        "kind": "value",
        "name": "addCheck",
        "docstrings": [],
        "signature": "let addCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "docstrings": [],
        "signature": "let removeCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.Int.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.Int.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.Int.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.MutableSet.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(p, s)` checks if all elements of the set satisfy the predicate `p`.\nOrder unspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(p, s)` checks if at least one element of the set satisfies the predicate\n`p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, value => bool) => t"
      },
      {
        "id": "Belt.MutableSet.Int.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(s, p)` returns a fresh copy of the set of all elements in `s` that satisfy\npredicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.MutableSet.Int.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.Int.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(s, p)` returns a fresh copy pair of sets `(s1, s2)`, where `s1` is\nthe set of all the elements of `s` that satisfy the predicate `p`, and `s2` is\nthe set of all the elements of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.MutableSet.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.MutableSet.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.MutableSet.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.MutableSet.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.MutableSet.Int.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(s, key)` return a fresh copy of each"
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.MutableSet.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/map/dict": {
    "id": "Belt.Map.Dict",
    "name": "Dict",
    "docstrings": [
      "This module separates identity from data, it is a bit more verbose but\nslightly more efficient due to the fact that there is no need to pack\nidentity and data back after each operation.\n\n**_Advanced usage only_**"
    ],
    "items": [
      {
        "id": "Belt.Map.Dict.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.Map.Dict.cmp",
        "kind": "type",
        "name": "cmp",
        "docstrings": [],
        "signature": "type cmp<'key, 'id> = Belt_Id.cmp<'key, 'id>"
      },
      {
        "id": "Belt.Map.Dict.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.Dict.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'k, 'v, 'id> => bool"
      },
      {
        "id": "Belt.Map.Dict.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => bool"
      },
      {
        "id": "Belt.Map.Dict.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (\n  t<'k, 'v, 'id>,\n  t<'k, 'v, 'id>,\n  ~kcmp: cmp<'k, 'id>,\n  ~vcmp: ('v, 'v) => int,\n) => int"
      },
      {
        "id": "Belt.Map.Dict.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (\n  t<'k, 'v, 'id>,\n  t<'k, 'v, 'id>,\n  ~kcmp: cmp<'k, 'id>,\n  ~vcmp: ('v, 'v) => int,\n) => int"
      },
      {
        "id": "Belt.Map.Dict.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (\n  t<'k, 'a, 'id>,\n  t<'k, 'a, 'id>,\n  ~kcmp: cmp<'k, 'id>,\n  ~veq: ('a, 'a) => bool,\n) => bool"
      },
      {
        "id": "Belt.Map.Dict.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2, cmp)` tests whether the maps `m1` and `m2` are equal, that is,\ncontain equal keys and associate them with equal data. `cmp` is the\nequality predicate used to compare the data associated with the keys."
        ],
        "signature": "let eq: (\n  t<'k, 'a, 'id>,\n  t<'k, 'a, 'id>,\n  ~kcmp: cmp<'k, 'id>,\n  ~veq: ('a, 'a) => bool,\n) => bool"
      },
      {
        "id": "Belt.Map.Dict.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.Dict.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`findFirstBy(m, p)` uses function `f` to find the first key value pair to\nmatch predicate `p`.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Map.Dict.fromArray([(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"3\")], ~cmp=IntCmp.cmp)\n\nBelt.Map.Dict.findFirstBy(s0, (k, _) => k == 4) == Some((4, \"4\"))\n```"
        ],
        "signature": "let findFirstBy: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.Dict.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Map.Dict.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the\nkey as first argument, and the associated value as second argument. The\nbindings are passed to `f` in increasing order with respect to the ordering\nover the type of the keys."
        ],
        "signature": "let forEach: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Map.Dict.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.Map.Dict.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `f(kN, dN ... f(k1, d1, a)...)`, where `k1 ... kN` \nare the keys of all bindings in `m` (in increasing order), and `d1 ... dN` \nare the associated data."
        ],
        "signature": "let reduce: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.Map.Dict.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate\n`p`. Order unspecified"
        ],
        "signature": "let every: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the\npredicate `p`. Order unspecified"
        ],
        "signature": "let some: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'k, 'a, 'id> => int"
      },
      {
        "id": "Belt.Map.Dict.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'k, 'a, 'id> => list<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'k, 'a, 'id> => array<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: (array<('k, 'a)>, ~cmp: cmp<'k, 'id>) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.Map.Dict.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'k, 'a, 'id> => array<'k>"
      },
      {
        "id": "Belt.Map.Dict.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'k, 'a, 'id> => array<'a>"
      },
      {
        "id": "Belt.Map.Dict.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.Dict.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.Dict.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.Dict.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.Dict.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => option<'a>"
      },
      {
        "id": "Belt.Map.Dict.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => Js.undefined<'a>"
      },
      {
        "id": "Belt.Map.Dict.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'k, 'a, 'id>, 'k, 'a, ~cmp: cmp<'k, 'id>) => 'a"
      },
      {
        "id": "Belt.Map.Dict.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => 'a"
      },
      {
        "id": "Belt.Map.Dict.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [],
        "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit"
      },
      {
        "id": "Belt.Map.Dict.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` returns a map containing the same bindings as `m`, except\nfor `x` which is unbound in the returned map."
        ],
        "signature": "let remove: (t<'a, 'b, 'id>, 'a, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (\n  t<'a, 'b, 'id>,\n  array<'a>,\n  ~cmp: cmp<'a, 'id>,\n) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` returns a map containing the same bindings as `m`, plus a\nbinding of `x` to `y`. If `x` was already bound in `m`, its previous\nbinding disappears."
        ],
        "signature": "let set: (\n  t<'a, 'b, 'id>,\n  'a,\n  'b,\n  ~cmp: cmp<'a, 'id>,\n) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (\n  t<'a, 'b, 'id>,\n  'a,\n  option<'b> => option<'b>,\n  ~cmp: cmp<'a, 'id>,\n) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (\n  t<'a, 'b, 'id>,\n  'a,\n  option<'b> => option<'b>,\n  ~cmp: cmp<'a, 'id>,\n) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (\n  t<'a, 'b, 'id>,\n  t<'a, 'c, 'id>,\n  ('a, option<'b>, option<'c>) => option<'d>,\n  ~cmp: cmp<'a, 'id>,\n) => t<'a, 'd, 'id>"
      },
      {
        "id": "Belt.Map.Dict.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\nand of `m2`. The presence of each such binding, and the corresponding\nvalue, is determined with the function `f`."
        ],
        "signature": "let merge: (\n  t<'a, 'b, 'id>,\n  t<'a, 'c, 'id>,\n  ('a, option<'b>, option<'c>) => option<'d>,\n  ~cmp: cmp<'a, 'id>,\n) => t<'a, 'd, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (\n  t<'a, 'b, 'id>,\n  array<('a, 'b)>,\n  ~cmp: cmp<'a, 'id>,\n) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'k, 'a, 'id>, ('k, 'a) => bool) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.Map.Dict.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(m, p)` returns the map with all the bindings in `m` that satisfy\npredicate `p`."
        ],
        "signature": "let keep: (t<'k, 'a, 'id>, ('k, 'a) => bool) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.Map.Dict.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (\n  t<'k, 'a, 'id>,\n  ('k, 'a) => bool,\n) => (t<'k, 'a, 'id>, t<'k, 'a, 'id>)"
      },
      {
        "id": "Belt.Map.Dict.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains\nall the bindings of `s` that satisfy the predicate `p`, and `m2` is the map\nwith all the bindings of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (\n  t<'k, 'a, 'id>,\n  ('k, 'a) => bool,\n) => (t<'k, 'a, 'id>, t<'k, 'a, 'id>)"
      },
      {
        "id": "Belt.Map.Dict.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, m)` returns a triple `(l, data, r)`, where `l` is the map with\nall the bindings of `m` whose key is strictly less than `x`; `r` is the map\nwith all the bindings of `m` whose key is strictly greater than `x`; `data`\nis `None` if `m` contains no binding for `x`, or `Some(v)` if `m` binds `v`\nto `x`."
        ],
        "signature": "let split: (\n  t<'a, 'b, 'id>,\n  'a,\n  ~cmp: cmp<'a, 'id>,\n) => ((t<'a, 'b, 'id>, t<'a, 'b, 'id>), option<'b>)"
      },
      {
        "id": "Belt.Map.Dict.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated\nvalue `a` of all bindings of `m` has been replaced by the result of the\napplication of `f` to `a`. The bindings are passed to `f` in increasing\norder with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>"
      }
    ]
  },
  "belt/map/string": {
    "id": "Belt.Map.String",
    "name": "String",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Map.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.Map.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of maps from type `key` to type `'value`."
        ],
        "signature": "type t<'value>"
      },
      {
        "id": "Belt.Map.String.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t<'v>"
      },
      {
        "id": "Belt.Map.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'v> => bool"
      },
      {
        "id": "Belt.Map.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'v>, key) => bool"
      },
      {
        "id": "Belt.Map.String.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'v>, t<'v>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t<'v>, t<'v>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.String.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'v>, t<'v>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2)` tests whether the maps `m1` and `m2` are\nequal, that is, contain equal keys and associate them with\nequal data."
        ],
        "signature": "let eq: (t<'v>, t<'v>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`findFirstBy(m, p)` uses funcion `f` to find the first key value pair\nto match predicate `p`.\n\n```rescript\nlet s0 = fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2,\"(3, \"\"))])\nfindFirstBy(s0, (k, v) => k == 4) == option((4, \"4\"))\n```"
        ],
        "signature": "let findFirstBy: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'v>, (key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`.\n`f` receives the key as first argument, and the associated value\nas second argument. The bindings are passed to `f` in increasing\norder with respect to the ordering over the type of the keys."
        ],
        "signature": "let forEach: (t<'v>, (key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `(f kN dN ... (f k1 d1 a)...)`,\nwhere `k1 ... kN` are the keys of all bindings in `m`\n(in increasing order), and `d1 ... dN` are the associated data."
        ],
        "signature": "let reduce: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate `p`.\nOrder unspecified"
        ],
        "signature": "let every: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the predicate\n`p`. Order unspecified"
        ],
        "signature": "let some: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'v> => int"
      },
      {
        "id": "Belt.Map.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'v> => list<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'v> => array<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'v)> => t<'v>"
      },
      {
        "id": "Belt.Map.String.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'v> => array<key>"
      },
      {
        "id": "Belt.Map.String.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'v> => array<'v>"
      },
      {
        "id": "Belt.Map.String.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.String.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.String.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.String.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'v>, key) => option<'v>"
      },
      {
        "id": "Belt.Map.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'v>, key) => Js.undefined<'v>"
      },
      {
        "id": "Belt.Map.String.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'v>, key, 'v) => 'v"
      },
      {
        "id": "Belt.Map.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'v>, key) => 'v"
      },
      {
        "id": "Belt.Map.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.Map.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` returns a map containing the same bindings as\n    `m`, except for `x` which is unbound in the returned map."
        ],
        "signature": "let remove: (t<'v>, key) => t<'v>"
      },
      {
        "id": "Belt.Map.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'v>, array<key>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` returns a map containing the same bindings as\n`m`, plus a binding of `x` to `y`. If `x` was already bound\nin `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'v>, key, 'v) => t<'v>"
      },
      {
        "id": "Belt.Map.String.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'v>, key, option<'v> => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'v>, key, option<'v> => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (\n  t<'v>,\n  t<'v2>,\n  (key, option<'v>, option<'v2>) => option<'c>,\n) => t<'c>"
      },
      {
        "id": "Belt.Map.String.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\nand of `m2`. The presence of each such binding, and the corresponding\nvalue, is determined with the function `f`."
        ],
        "signature": "let merge: (\n  t<'v>,\n  t<'v2>,\n  (key, option<'v>, option<'v2>) => option<'c>,\n) => t<'c>"
      },
      {
        "id": "Belt.Map.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'v>, array<(key, 'v)>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'v>, (key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.String.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(m, p)` returns the map with all the bindings in `m` that satisfy predicate\n`p`."
        ],
        "signature": "let keep: (t<'v>, (key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.String.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.String.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains all the\nbindings of `s` that satisfy the predicate `p`, and `m2` is the map with all the\nbindings of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.String.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, m)` returns a triple `(l, data, r)`, where `l` is the map with all the\nbindings of `m` whose key is strictly less than `x`; `r` is the map with all the\nbindings of `m` whose key is strictly greater than `x`; `data` is `None` if `m`\ncontains no binding for `x`, or `Some(v)` if `m` binds `v` to `x`."
        ],
        "signature": "let split: (key, t<'v>) => (t<'v>, option<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.String.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'v>, 'v => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.String.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated value `a`\nof all bindings of `m` has been replaced by the result of the application of `f`\nto `a`. The bindings are passed to `f` in increasing order with respect to the\nordering over the type of the keys."
        ],
        "signature": "let map: (t<'v>, 'v => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.String.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'v>, (key, 'v) => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.String.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'v>, (key, 'v) => 'v2) => t<'v2>"
      }
    ]
  },
  "belt/map/int": {
    "id": "Belt.Map.Int",
    "name": "Int",
    "docstrings": [
      "## Examples\n\n```rescript\ntype t<'key, 'value, 'identity>\ntype id<'key, 'id> = Belt_Id.comparable<'key, 'id>\n```"
    ],
    "items": [
      {
        "id": "Belt.Map.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.Map.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of maps from type `key` to type `'value`."
        ],
        "signature": "type t<'value>"
      },
      {
        "id": "Belt.Map.Int.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t<'v>"
      },
      {
        "id": "Belt.Map.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'v> => bool"
      },
      {
        "id": "Belt.Map.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'v>, key) => bool"
      },
      {
        "id": "Belt.Map.Int.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'v>, t<'v>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t<'v>, t<'v>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.Int.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'v>, t<'v>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2)` tests whether the maps `m1` and `m2` are\nequal, that is, contain equal keys and associate them with\nequal data."
        ],
        "signature": "let eq: (t<'v>, t<'v>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`findFirstBy(m, p)` uses funcion `f` to find the first key value pair\nto match predicate `p`.\n\n```rescript\nlet s0 = fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2,\"(3, \"\"))])\nfindFirstBy(s0, (k, v) => k == 4) == option((4, \"4\"))\n```"
        ],
        "signature": "let findFirstBy: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'v>, (key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`.\n`f` receives the key as first argument, and the associated value\nas second argument. The bindings are passed to `f` in increasing\norder with respect to the ordering over the type of the keys."
        ],
        "signature": "let forEach: (t<'v>, (key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `(f kN dN ... (f k1 d1 a)...)`,\nwhere `k1 ... kN` are the keys of all bindings in `m`\n(in increasing order), and `d1 ... dN` are the associated data."
        ],
        "signature": "let reduce: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate `p`.\nOrder unspecified"
        ],
        "signature": "let every: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the predicate\n`p`. Order unspecified"
        ],
        "signature": "let some: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'v> => int"
      },
      {
        "id": "Belt.Map.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'v> => list<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'v> => array<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'v)> => t<'v>"
      },
      {
        "id": "Belt.Map.Int.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'v> => array<key>"
      },
      {
        "id": "Belt.Map.Int.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'v> => array<'v>"
      },
      {
        "id": "Belt.Map.Int.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.Int.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.Int.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.Int.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'v>, key) => option<'v>"
      },
      {
        "id": "Belt.Map.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'v>, key) => Js.undefined<'v>"
      },
      {
        "id": "Belt.Map.Int.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'v>, key, 'v) => 'v"
      },
      {
        "id": "Belt.Map.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'v>, key) => 'v"
      },
      {
        "id": "Belt.Map.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.Map.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` returns a map containing the same bindings as\n    `m`, except for `x` which is unbound in the returned map."
        ],
        "signature": "let remove: (t<'v>, key) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'v>, array<key>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` returns a map containing the same bindings as\n`m`, plus a binding of `x` to `y`. If `x` was already bound\nin `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'v>, key, 'v) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'v>, key, option<'v> => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'v>, key, option<'v> => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (\n  t<'v>,\n  t<'v2>,\n  (key, option<'v>, option<'v2>) => option<'c>,\n) => t<'c>"
      },
      {
        "id": "Belt.Map.Int.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\nand of `m2`. The presence of each such binding, and the corresponding\nvalue, is determined with the function `f`."
        ],
        "signature": "let merge: (\n  t<'v>,\n  t<'v2>,\n  (key, option<'v>, option<'v2>) => option<'c>,\n) => t<'c>"
      },
      {
        "id": "Belt.Map.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'v>, array<(key, 'v)>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'v>, (key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(m, p)` returns the map with all the bindings in `m` that satisfy predicate\n`p`."
        ],
        "signature": "let keep: (t<'v>, (key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.Int.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains all the\nbindings of `s` that satisfy the predicate `p`, and `m2` is the map with all the\nbindings of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.Int.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, m)` returns a triple `(l, data, r)`, where `l` is the map with all the\nbindings of `m` whose key is strictly less than `x`; `r` is the map with all the\nbindings of `m` whose key is strictly greater than `x`; `data` is `None` if `m`\ncontains no binding for `x`, or `Some(v)` if `m` binds `v` to `x`."
        ],
        "signature": "let split: (key, t<'v>) => (t<'v>, option<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.Int.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'v>, 'v => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.Int.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated value `a`\nof all bindings of `m` has been replaced by the result of the application of `f`\nto `a`. The bindings are passed to `f` in increasing order with respect to the\nordering over the type of the keys."
        ],
        "signature": "let map: (t<'v>, 'v => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.Int.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'v>, (key, 'v) => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.Int.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'v>, (key, 'v) => 'v2) => t<'v2>"
      }
    ]
  },
  "belt/set/dict": {
    "id": "Belt.Set.Dict",
    "name": "Dict",
    "docstrings": [
      "This module separates identity from data, it is a bit more verbose but slightly\nmore efficient due to the fact that there is no need to pack identity and data back\nafter each operation",
      "This module separates identity from data. It is a bit more verbose but slightly\nmore efficient due to the fact that there is no need to pack identity and data\nback after each operation."
    ],
    "items": [
      {
        "id": "Belt.Set.Dict.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'value` is the element type\n\n`'identity` the identity of the collection"
        ],
        "signature": "type t<'value, 'identity>"
      },
      {
        "id": "Belt.Set.Dict.cmp",
        "kind": "type",
        "name": "cmp",
        "docstrings": [
          "Type of compare function."
        ],
        "signature": "type cmp<'value, 'id> = Belt_Id.cmp<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [
          "## Examples\n\n```rescript\nlet s0 = Belt.Set.Dict.empty\n```"
        ],
        "signature": "let empty: t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new set from array of elements.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([1, 3, 2, 4], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.toArray /* [1, 2, 3, 4] */\n```"
        ],
        "signature": "let fromArray: (array<'value>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [
          "The same as [fromArray][#fromarray] except it is after assuming the input array\nis already sorted."
        ],
        "signature": "let fromSortedArrayUnsafe: array<'value> => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Checks if set is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet empty = Belt.Set.Dict.fromArray([], ~cmp=IntCmp.cmp)\nlet notEmpty = Belt.Set.Dict.fromArray([1], ~cmp=IntCmp.cmp)\n\nBelt.Set.Dict.isEmpty(empty) /* true */\nBelt.Set.Dict.isEmpty(notEmpty) /* false */\n```"
        ],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Set.Dict.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if an element exists in the set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet set = Belt.Set.Dict.fromArray([1, 4, 2, 5], ~cmp=IntCmp.cmp)\n\nset->Belt.Set.Dict.has(3, ~cmp=IntCmp.cmp) /* false */\nset->Belt.Set.Dict.has(1, ~cmp=IntCmp.cmp) /* true */\n```"
        ],
        "signature": "let has: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.Dict.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds element to set. If element existed in set, value is unchanged.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.empty\nlet s1 = s0->Belt.Set.Dict.add(1, ~cmp=IntCmp.cmp)\nlet s2 = s1->Belt.Set.Dict.add(2, ~cmp=IntCmp.cmp)\nlet s3 = s2->Belt.Set.Dict.add(2, ~cmp=IntCmp.cmp)\ns0->Belt.Set.Dict.toArray /* [] */\ns1->Belt.Set.Dict.toArray /* [1] */\ns2->Belt.Set.Dict.toArray /* [1, 2] */\ns3->Belt.Set.Dict.toArray /* [1,2 ] */\ns2 == s3 /* true */\n```"
        ],
        "signature": "let add: (\n  t<'value, 'id>,\n  'value,\n  ~cmp: cmp<'value, 'id>,\n) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "Adds each element of array to set. Unlike [add](#add), the reference of return value might be changed even if all values in array already exist in set\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet set = Belt.Set.Dict.empty\n\nlet newSet = set->Belt.Set.Dict.mergeMany([5, 4, 3, 2, 1], ~cmp=IntCmp.cmp)\nnewSet->Belt.Set.Dict.toArray /* [1, 2, 3, 4, 5] */\n```"
        ],
        "signature": "let mergeMany: (\n  t<'value, 'id>,\n  array<'value>,\n  ~cmp: cmp<'value, 'id>,\n) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "Removes element from set. If element did not exist in set, value is unchanged.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([2, 3, 1, 4, 5], ~cmp=IntCmp.cmp)\nlet s1 = s0->Belt.Set.Dict.remove(1, ~cmp=IntCmp.cmp)\nlet s2 = s1->Belt.Set.Dict.remove(3, ~cmp=IntCmp.cmp)\nlet s3 = s2->Belt.Set.Dict.remove(3, ~cmp=IntCmp.cmp)\n\ns1->Belt.Set.Dict.toArray /* [2,3,4,5] */\ns2->Belt.Set.Dict.toArray /* [2,4,5] */\ns2 == s3 /* true */\n```"
        ],
        "signature": "let remove: (\n  t<'value, 'id>,\n  'value,\n  ~cmp: cmp<'value, 'id>,\n) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "Removes each element of array from set. Unlike [remove](#remove), the reference of return value might be changed even if any values in array not existed in set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet set = Belt.Set.Dict.fromArray([1, 2, 3, 4], ~cmp=IntCmp.cmp)\n\nlet newSet = set->Belt.Set.Dict.removeMany([5, 4, 3, 2, 1], ~cmp=IntCmp.cmp)\nnewSet->Belt.Set.Dict.toArray /* [] */\n```"
        ],
        "signature": "let removeMany: (\n  t<'value, 'id>,\n  array<'value>,\n  ~cmp: cmp<'value, 'id>,\n) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "Returns union of two sets.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\nlet s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\nlet union = Belt.Set.Dict.union(s0, s1, ~cmp=IntCmp.cmp)\nunion->Belt.Set.Dict.toArray /* [1,2,3,4,5,6] */\n```"
        ],
        "signature": "let union: (\n  t<'value, 'id>,\n  t<'value, 'id>,\n  ~cmp: cmp<'value, 'id>,\n) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "Returns intersection of two sets.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\nlet s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\nlet intersect = Belt.Set.Dict.intersect(s0, s1, ~cmp=IntCmp.cmp)\nintersect->Belt.Set.Dict.toArray /* [2,3,5] */\n```"
        ],
        "signature": "let intersect: (\n  t<'value, 'id>,\n  t<'value, 'id>,\n  ~cmp: cmp<'value, 'id>,\n) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [
          "Returns elements from first set, not existing in second set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\nlet s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n\nlet diff1 = Belt.Set.Dict.diff(s0, s1, ~cmp=IntCmp.cmp)\nlet diff2 = Belt.Set.Dict.diff(s1, s0, ~cmp=IntCmp.cmp)\n\ndiff1->Belt.Set.Dict.toArray /* [6] */\ndiff2->Belt.Set.Dict.toArray /* [1,4] */\n```"
        ],
        "signature": "let diff: (\n  t<'value, 'id>,\n  t<'value, 'id>,\n  ~cmp: cmp<'value, 'id>,\n) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "Checks if second set is subset of first set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\nlet s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\nlet s2 = Belt.Set.Dict.intersect(s0, s1, ~cmp=IntCmp.cmp)\nBelt.Set.Dict.subset(s2, s0, ~cmp=IntCmp.cmp) /* true */\nBelt.Set.Dict.subset(s2, s1, ~cmp=IntCmp.cmp) /* true */\nBelt.Set.Dict.subset(s1, s0, ~cmp=IntCmp.cmp) /* false */\n```"
        ],
        "signature": "let subset: (\n  t<'value, 'id>,\n  t<'value, 'id>,\n  ~cmp: cmp<'value, 'id>,\n) => bool"
      },
      {
        "id": "Belt.Set.Dict.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets\nof sets. It compares size first and then iterates over each element following the\norder of elements."
        ],
        "signature": "let cmp: (\n  t<'value, 'id>,\n  t<'value, 'id>,\n  ~cmp: cmp<'value, 'id>,\n) => int"
      },
      {
        "id": "Belt.Set.Dict.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Checks if two sets are equal.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([5, 2, 3], ~cmp=IntCmp.cmp)\nlet s1 = Belt.Set.Dict.fromArray([3, 2, 5], ~cmp=IntCmp.cmp)\n\nBelt.Set.Dict.eq(s0, s1, ~cmp=IntCmp.cmp) /* true */\n```"
        ],
        "signature": "let eq: (\n  t<'value, 'id>,\n  t<'value, 'id>,\n  ~cmp: cmp<'value, 'id>,\n) => bool"
      },
      {
        "id": "Belt.Set.Dict.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as [forEach](##forEach) but takes uncurried functon."
        ],
        "signature": "let forEachU: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.Set.Dict.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Applies function `f` in turn to all elements of set in increasing order.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\nlet acc = ref(list{})\ns0->Belt.Set.Dict.forEach(x => acc := Belt.List.add(acc.contents, x))\nacc /* [6,5,3,2] */\n```"
        ],
        "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.Set.Dict.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Dict.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an accumulator, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\ns0->Belt.Set.Dict.reduce(list{}, (acc, element) => acc->Belt.List.add(element)) /* [6,5,3,2] */\n```"
        ],
        "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Dict.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isEven = x => mod(x, 2) == 0\n\nlet s0 = Belt.Set.Dict.fromArray([2, 4, 6, 8], ~cmp=IntCmp.cmp)\ns0->Belt.Set.Dict.every(isEven) /* true */\n```"
        ],
        "signature": "let every: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Checks if at least one element of the set satisfies the predicate.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isOdd = x => mod(x, 2) != 0\n\nlet s0 = Belt.Set.Dict.fromArray([1, 2, 4, 6, 8], ~cmp=IntCmp.cmp)\ns0->Belt.Set.Dict.some(isOdd) /* true */\n```"
        ],
        "signature": "let some: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns the set of all elements that satisfy the predicate.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isEven = x => mod(x, 2) == 0\n\nlet s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\nlet s1 = s0->Belt.Set.Dict.keep(isEven)\n\ns1->Belt.Set.Dict.toArray /* [2,4] */\n```"
        ],
        "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (\n  t<'value, 'id>,\n  'value => bool,\n) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.Dict.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "Returns a pair of sets, where first is the set of all the elements of set that satisfy the predicate, and second is the set of all the elements of set that do not satisfy the predicate.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isOdd = x => mod(x, 2) != 0\n\nlet s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\nlet (s1, s2) = s0->Belt.Set.Dict.partition(isOdd)\n\ns1->Belt.Set.Dict.toArray /* [1,3,5] */\ns2->Belt.Set.Dict.toArray /* [2,4] */\n```"
        ],
        "signature": "let partition: (\n  t<'value, 'id>,\n  'value => bool,\n) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.Dict.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns size of the set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.size /* 4 */\n```"
        ],
        "signature": "let size: t<'value, 'id> => int"
      },
      {
        "id": "Belt.Set.Dict.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "Returns list of ordered set elements.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.toList /* [1,2,3,5] */\n```"
        ],
        "signature": "let toList: t<'value, 'id> => list<'value>"
      },
      {
        "id": "Belt.Set.Dict.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of ordered set elements.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.toArray /* [1,2,3,5] */\n```"
        ],
        "signature": "let toArray: t<'value, 'id> => array<'value>"
      },
      {
        "id": "Belt.Set.Dict.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "Returns minimum value of the collection. `None` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.empty\nlet s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.minimum /* None */\ns1->Belt.Set.Dict.minimum /* Some(1) */\n```"
        ],
        "signature": "let minimum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.Dict.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "Returns minimum value of the collection. `undefined` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.empty\nlet s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.minUndefined /* undefined */\ns1->Belt.Set.Dict.minUndefined /* 1 */\n```"
        ],
        "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.Dict.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "Returns maximum value of the collection. `None` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.empty\nlet s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.maximum /* None */\ns1->Belt.Set.Dict.maximum /* Some(5) */\n```"
        ],
        "signature": "let maximum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.Dict.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "Returns maximum value of the collection. `undefined` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.empty\nlet s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.maxUndefined /* undefined */\ns1->Belt.Set.Dict.maxUndefined /* 5 */\n```"
        ],
        "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.Dict.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the reference of the value which is equivalent to value using the comparator\nspecifiecd by this collection. Returns `None` if element does not exist.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n\ns0->Belt.Set.Dict.get(3, ~cmp=IntCmp.cmp) /* Some(3) */\ns0->Belt.Set.Dict.get(20, ~cmp=IntCmp.cmp) /* None */\n```"
        ],
        "signature": "let get: (\n  t<'value, 'id>,\n  'value,\n  ~cmp: cmp<'value, 'id>,\n) => option<'value>"
      },
      {
        "id": "Belt.Set.Dict.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "Same as [get](#get) but returns `undefined` when element does not exist."
        ],
        "signature": "let getUndefined: (\n  t<'value, 'id>,\n  'value,\n  ~cmp: cmp<'value, 'id>,\n) => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.Dict.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as [get](#get) but raise when element does not exist."
        ],
        "signature": "let getExn: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => 'value"
      },
      {
        "id": "Belt.Set.Dict.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n\nlet ((smaller, larger), present) = s0->Belt.Set.Dict.split(3, ~cmp=IntCmp.cmp)\n\npresent /* true */\nsmaller->Belt.Set.Dict.toArray /* [1,2] */\nlarger->Belt.Set.Dict.toArray /* [4,5] */\n```"
        ],
        "signature": "let split: (\n  t<'value, 'id>,\n  'value,\n  ~cmp: cmp<'value, 'id>,\n) => ((t<'value, 'id>, t<'value, 'id>), bool)"
      },
      {
        "id": "Belt.Set.Dict.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b> => unit"
      }
    ]
  },
  "belt/set/string": {
    "id": "Belt.Set.String",
    "name": "String",
    "docstrings": [
      "Specialized when value type is `string`, more efficient than the generic type,\nits compare behavior is fixed using the built-in comparison",
      "This module is [`Belt.Set`]() specialized with value type to be a primitive type.\n  It is more efficient in general, the  API is the same with [`Belt_Set`]() except its value type is fixed,\n  and identity is not needed(using the built-in one)\n\n  **See** [`Belt.Set`]()"
    ],
    "items": [
      {
        "id": "Belt.Set.String.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = string"
      },
      {
        "id": "Belt.Set.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.Set.String.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t"
      },
      {
        "id": "Belt.Set.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.Set.String.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.Set.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.Set.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.Set.String.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "`add(s, x)` If `x` was already in `s`, `s` is returned unchanged."
        ],
        "signature": "let add: (t, value) => t"
      },
      {
        "id": "Belt.Set.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` If `x` was not in `m`, `m` is returned reference unchanged."
        ],
        "signature": "let remove: (t, value) => t"
      },
      {
        "id": "Belt.Set.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.String.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.Set.String.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.Set.String.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.Set.String.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "`subset(s1, s2)` tests whether the set `s1` is a subset of the set `s2`."
        ],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.Set.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets\nof sets."
        ],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.Set.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(s1, s2)` tests whether the sets `s1` and `s2` are equal, that is, contain\nequal elements."
        ],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.Set.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, value => unit) => unit"
      },
      {
        "id": "Belt.Set.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(s, f)` applies `f` in turn to all elements of `s`. In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.Set.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(p, s)` checks if all elements of the set satisfy the predicate `p`. Order\nunspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(p, s)` checks if at least one element of the set satisfies the predicate\n`p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.String.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, value => bool) => t"
      },
      {
        "id": "Belt.Set.String.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(p, s)` returns the set of all elements in `s` that satisfy predicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.Set.String.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.String.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(p, s)` returns a pair of sets `(s1, s2)`, where `s1` is the set of\nall the elements of `s` that satisfy the predicate `p`, and `s2` is the set of\nall the elements of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.Set.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.Set.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.Set.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.Set.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.Set.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.Set.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.Set.String.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, s)` returns a triple `(l, present, r)`, where `l` is the set of\nelements of `s` that are strictly less than `x`;`r` is the set of elements of\n`s` that are strictly greater than `x`; `present` is `false` if `s` contains no\nelement equal to `x`, or `true` if `s` contains an element equal to `x`."
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.Set.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/set/int": {
    "id": "Belt.Set.Int",
    "name": "Int",
    "docstrings": [
      "Specialized when value type is `int`, more efficient than the generic type, its\ncompare behavior is fixed using the built-in comparison",
      "This module is [`Belt.Set`]() specialized with value type to be a primitive type.\n  It is more efficient in general, the  API is the same with [`Belt_Set`]() except its value type is fixed,\n  and identity is not needed(using the built-in one)\n\n  **See** [`Belt.Set`]()"
    ],
    "items": [
      {
        "id": "Belt.Set.Int.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = int"
      },
      {
        "id": "Belt.Set.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.Set.Int.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t"
      },
      {
        "id": "Belt.Set.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.Set.Int.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.Set.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.Set.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.Set.Int.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "`add(s, x)` If `x` was already in `s`, `s` is returned unchanged."
        ],
        "signature": "let add: (t, value) => t"
      },
      {
        "id": "Belt.Set.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` If `x` was not in `m`, `m` is returned reference unchanged."
        ],
        "signature": "let remove: (t, value) => t"
      },
      {
        "id": "Belt.Set.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.Int.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.Set.Int.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.Set.Int.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.Set.Int.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "`subset(s1, s2)` tests whether the set `s1` is a subset of the set `s2`."
        ],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.Set.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets\nof sets."
        ],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.Set.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(s1, s2)` tests whether the sets `s1` and `s2` are equal, that is, contain\nequal elements."
        ],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.Set.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, value => unit) => unit"
      },
      {
        "id": "Belt.Set.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(s, f)` applies `f` in turn to all elements of `s`. In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.Set.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(p, s)` checks if all elements of the set satisfy the predicate `p`. Order\nunspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(p, s)` checks if at least one element of the set satisfies the predicate\n`p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, value => bool) => t"
      },
      {
        "id": "Belt.Set.Int.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(p, s)` returns the set of all elements in `s` that satisfy predicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.Set.Int.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.Int.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(p, s)` returns a pair of sets `(s1, s2)`, where `s1` is the set of\nall the elements of `s` that satisfy the predicate `p`, and `s2` is the set of\nall the elements of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.Set.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.Set.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.Set.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.Set.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.Set.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.Set.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.Set.Int.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, s)` returns a triple `(l, present, r)`, where `l` is the set of\nelements of `s` that are strictly less than `x`;`r` is the set of elements of\n`s` that are strictly greater than `x`; `present` is `false` if `s` contains no\nelement equal to `x`, or `true` if `s` contains an element equal to `x`."
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.Set.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/sortarray/string": {
    "id": "Belt.SortArray.String",
    "name": "String",
    "docstrings": [
      "Specalized when key type is `string`, more efficient than the generic type",
      "This is a specialized module for [`Belt_SortArray`](), the docs in that module also\napplies here, except the comparator is fixed and inlined"
    ],
    "items": [
      {
        "id": "Belt.SortArray.String.element",
        "kind": "type",
        "name": "element",
        "docstrings": [],
        "signature": "type element = string"
      },
      {
        "id": "Belt.SortArray.String.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "docstrings": [
          "The same as [`Belt_SortArray.strictlySortedLength`]() except the comparator is fixed\n\n**return** `+n` means increasing order  `-n` means negative order"
        ],
        "signature": "let strictlySortedLength: array<element> => int"
      },
      {
        "id": "Belt.SortArray.String.isSorted",
        "kind": "value",
        "name": "isSorted",
        "docstrings": [
          "`sorted(xs)` return true if `xs` is in non strict increasing order"
        ],
        "signature": "let isSorted: array<element> => bool"
      },
      {
        "id": "Belt.SortArray.String.stableSortInPlace",
        "kind": "value",
        "name": "stableSortInPlace",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortInPlaceBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSortInPlace: array<element> => unit"
      },
      {
        "id": "Belt.SortArray.String.stableSort",
        "kind": "value",
        "name": "stableSort",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSort: array<element> => array<element>"
      },
      {
        "id": "Belt.SortArray.String.binarySearch",
        "kind": "value",
        "name": "binarySearch",
        "docstrings": [
          "If value is not found and value is less than one or more elements in array,\nthe negative number returned is the bitwise complement of the index of the first element\nthat is larger than value.\n\nIf value is not found and value is greater than all elements in array,\nthe negative number returned is the bitwise complement of\n(the index of the last element plus 1)\n\nfor example, if `key` is smaller than all elements return `-1` since `lnot (-1) = 0`\nif `key` is larger than all elements return `- (len + 1)` since `lnot (-(len+1)) = len`"
        ],
        "signature": "let binarySearch: (array<element>, element) => int"
      },
      {
        "id": "Belt.SortArray.String.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "`union(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp)` assume\n`src` and `src2` is strictly sorted. for equivalent elements, it is picked from\n`src` also assume that `dst` is large enough to store all elements"
        ],
        "signature": "let union: (\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n) => int"
      },
      {
        "id": "Belt.SortArray.String.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n) => int"
      },
      {
        "id": "Belt.SortArray.String.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n) => int"
      }
    ]
  },
  "belt/sortarray/int": {
    "id": "Belt.SortArray.Int",
    "name": "Int",
    "docstrings": [
      "Specalized when key type is `int`, more efficient than the generic type",
      "This is a specialized module for [`Belt_SortArray`](), the docs in that module also\napplies here, except the comparator is fixed and inlined"
    ],
    "items": [
      {
        "id": "Belt.SortArray.Int.element",
        "kind": "type",
        "name": "element",
        "docstrings": [],
        "signature": "type element = int"
      },
      {
        "id": "Belt.SortArray.Int.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "docstrings": [
          "The same as [`Belt_SortArray.strictlySortedLength`]() except the comparator is fixed\n\n**return** `+n` means increasing order  `-n` means negative order"
        ],
        "signature": "let strictlySortedLength: array<element> => int"
      },
      {
        "id": "Belt.SortArray.Int.isSorted",
        "kind": "value",
        "name": "isSorted",
        "docstrings": [
          "`sorted(xs)` return true if `xs` is in non strict increasing order"
        ],
        "signature": "let isSorted: array<element> => bool"
      },
      {
        "id": "Belt.SortArray.Int.stableSortInPlace",
        "kind": "value",
        "name": "stableSortInPlace",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortInPlaceBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSortInPlace: array<element> => unit"
      },
      {
        "id": "Belt.SortArray.Int.stableSort",
        "kind": "value",
        "name": "stableSort",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSort: array<element> => array<element>"
      },
      {
        "id": "Belt.SortArray.Int.binarySearch",
        "kind": "value",
        "name": "binarySearch",
        "docstrings": [
          "If value is not found and value is less than one or more elements in array,\nthe negative number returned is the bitwise complement of the index of the first element\nthat is larger than value.\n\nIf value is not found and value is greater than all elements in array,\nthe negative number returned is the bitwise complement of\n(the index of the last element plus 1)\n\nfor example, if `key` is smaller than all elements return `-1` since `lnot (-1) = 0`\nif `key` is larger than all elements return `- (len + 1)` since `lnot (-(len+1)) = len`"
        ],
        "signature": "let binarySearch: (array<element>, element) => int"
      },
      {
        "id": "Belt.SortArray.Int.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "`union(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp)` assume\n`src` and `src2` is strictly sorted. for equivalent elements, it is picked from\n`src` also assume that `dst` is large enough to store all elements"
        ],
        "signature": "let union: (\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n) => int"
      },
      {
        "id": "Belt.SortArray.Int.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n) => int"
      },
      {
        "id": "Belt.SortArray.Int.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n  int,\n  array<element>,\n  int,\n) => int"
      }
    ]
  },
  "belt/id/makehashable": {
    "id": "Belt.Id.MakeHashable",
    "name": "MakeHashable",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeHashable.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeHashable.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeHashable.hash",
        "kind": "value",
        "name": "hash",
        "docstrings": [],
        "signature": "let hash: hash<t, identity>"
      },
      {
        "id": "Belt.Id.MakeHashable.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: eq<t, identity>"
      }
    ]
  },
  "belt/id/makehashableu": {
    "id": "Belt.Id.MakeHashableU",
    "name": "MakeHashableU",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeHashableU.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeHashableU.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeHashableU.hash",
        "kind": "value",
        "name": "hash",
        "docstrings": [],
        "signature": "let hash: hash<t, identity>"
      },
      {
        "id": "Belt.Id.MakeHashableU.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: eq<t, identity>"
      }
    ]
  },
  "belt/id/makecomparable": {
    "id": "Belt.Id.MakeComparable",
    "name": "MakeComparable",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeComparable.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeComparable.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeComparable.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: cmp<t, identity>"
      }
    ]
  },
  "belt/id/makecomparableu": {
    "id": "Belt.Id.MakeComparableU",
    "name": "MakeComparableU",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeComparableU.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeComparableU.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeComparableU.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: cmp<t, identity>"
      }
    ]
  },
  "belt/float": {
    "id": "Belt.Float",
    "name": "Float",
    "docstrings": [
      "[`Belt.Float`]()\n\n  Utilities for Float.",
      "This module includes convenience methods for handling `float` types."
    ],
    "items": [
      {
        "id": "Belt.Float.toInt",
        "kind": "value",
        "name": "toInt",
        "docstrings": [
          "Converts a given `float` to an `int`.\n\n## Examples\n\n```rescript\nJs.log(Belt.Float.toInt(1.0) === 1) /* true */\n```"
        ],
        "signature": "let toInt: float => int"
      },
      {
        "id": "Belt.Float.fromInt",
        "kind": "value",
        "name": "fromInt",
        "docstrings": [
          "Converts a given `int` to a `float`.\n\n## Examples\n\n```rescript\nJs.log(Belt.Float.fromInt(1) === 1.0) /* true */\n```"
        ],
        "signature": "let fromInt: int => float"
      },
      {
        "id": "Belt.Float.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "Converts a given `string` to a `float`. Returns `Some(float)` when the input is a number, `None` otherwise.\n\n## Examples\n\n```rescript\nJs.log(Belt.Float.fromString(\"1.0\") === Some(1.0)) /* true */\n```"
        ],
        "signature": "let fromString: string => option<float>"
      },
      {
        "id": "Belt.Float.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "Converts a given `float` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n## Examples\n\n```rescript\nJs.log(Belt.Float.toString(1.0) === \"1.0\") /* true */\n```"
        ],
        "signature": "let toString: float => string"
      },
      {
        "id": "Belt.Float.+",
        "kind": "value",
        "name": "+",
        "docstrings": [
          "Addition of two `float` values.\nCan be opened in a module to avoid dot-notation (`+.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n## Examples\n\n```rescript\nopen Belt.Float\nJs.log(2.0 + 2.0 === 4.0) /* true */\n```"
        ],
        "signature": "let +: (float, float) => float"
      },
      {
        "id": "Belt.Float.-",
        "kind": "value",
        "name": "-",
        "docstrings": [
          "Subtraction of two `float` values.\nCan be opened in a module to avoid dot-notation (`-.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n## Examples\n\n```rescript\nopen Belt.Float\nJs.log(2.0 - 1.0 === 1.0) /* true */\n```"
        ],
        "signature": "let -: (float, float) => float"
      },
      {
        "id": "Belt.Float.*",
        "kind": "value",
        "name": "*",
        "docstrings": [
          "Multiplication of two `float` values.\nCan be opened in a module to avoid dot-notation (`*.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n## Examples\n\n```rescript\nopen Belt.Float\nJs.log(2.0 * 2.0 === 4.0) /* true */\n```"
        ],
        "signature": "let *: (float, float) => float"
      },
      {
        "id": "Belt.Float./",
        "kind": "value",
        "name": "/",
        "docstrings": [
          "Division of two `float` values.\nCan be opened in a module to avoid dot-notation (`/.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n## Examples\n\n```rescript\nopen Belt.Float\nJs.log(4.0 / 2.0 === 2.0) /* true */\n```"
        ],
        "signature": "let /: (float, float) => float"
      }
    ]
  },
  "belt/int": {
    "id": "Belt.Int",
    "name": "Int",
    "docstrings": [
      "[`Belt.Int`]()\n\n  Utilities for Int.",
      "This module includes convenience methods for handling `int` types."
    ],
    "items": [
      {
        "id": "Belt.Int.toFloat",
        "kind": "value",
        "name": "toFloat",
        "docstrings": [
          "Converts a given `int` to a `float`.\n\n## Examples\n\n```rescript\nJs.log(Belt.Int.toFloat(1) === 1.0) /* true */\n```"
        ],
        "signature": "let toFloat: int => float"
      },
      {
        "id": "Belt.Int.fromFloat",
        "kind": "value",
        "name": "fromFloat",
        "docstrings": [
          "Converts a given `float` to an `int`.\n\n## Examples\n\n```rescript\nJs.log(Belt.Int.fromFloat(1.0) === 1) /* true */\n```"
        ],
        "signature": "let fromFloat: float => int"
      },
      {
        "id": "Belt.Int.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "Converts a given `string` to an `int`. Returns `Some(int)` when the input is a number, `None` otherwise.\n\n## Examples\n\n```rescript\nJs.log(Belt.Int.fromString(\"1\") === Some(1)) /* true */\n```"
        ],
        "signature": "let fromString: string => option<int>"
      },
      {
        "id": "Belt.Int.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "Converts a given `int` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n## Examples\n\n```rescript\nJs.log(Belt.Int.toString(1) === \"1\") /* true */\n```"
        ],
        "signature": "let toString: int => string"
      },
      {
        "id": "Belt.Int.+",
        "kind": "value",
        "name": "+",
        "docstrings": [
          "Addition of two `int` values. Same as the addition from `Pervasives`.\n\n## Examples\n\n```rescript\nopen Belt.Int\nJs.log(2 + 2 === 4) /* true */\n```"
        ],
        "signature": "let +: (int, int) => int"
      },
      {
        "id": "Belt.Int.-",
        "kind": "value",
        "name": "-",
        "docstrings": [
          "Subtraction of two `int` values. Same as the subtraction from `Pervasives`.\n\n## Examples\n\n```rescript\nopen Belt.Int\nJs.log(2 - 1 === 1) /* true */\n```"
        ],
        "signature": "let -: (int, int) => int"
      },
      {
        "id": "Belt.Int.*",
        "kind": "value",
        "name": "*",
        "docstrings": [
          "Multiplication of two `int` values. Same as the multiplication from `Pervasives`.\n\n## Examples\n\n```rescript\nopen Belt.Int\nJs.log(2 * 2 === 4) /* true */\n```"
        ],
        "signature": "let *: (int, int) => int"
      },
      {
        "id": "Belt.Int./",
        "kind": "value",
        "name": "/",
        "docstrings": [
          "Division of two `int` values. Same as the division from `Pervasives`.\n\n## Examples\n\n```rescript\nopen Belt.Int\nJs.log(4 / 2 === 2); /* true */\n```"
        ],
        "signature": "let /: (int, int) => int"
      }
    ]
  },
  "belt/result": {
    "id": "Belt.Result",
    "name": "Result",
    "docstrings": [
      "[`Belt.Result`]()\n\n  Utilities for result data type.",
      "Result types are really useful to describe the result of a certain operation\nwithout relying on exceptions or `option` types.\n\nThis module gives you useful utilities to create and combine `Result` data."
    ],
    "items": [
      {
        "id": "Belt.Result.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a, 'b> = result<'a, 'b> = Ok('a) | Error('b)"
      },
      {
        "id": "Belt.Result.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(res)`: when `res` is `Ok(n)`, returns `n` when `res` is `Error(m)`, raise an exception\n\n## Examples\n\n```rescript\nBelt.Result.getExn(Belt.Result.Ok(42)) == 42\n\nBelt.Result.getExn(Belt.Result.Error(\"Invalid data\")) /* raises exception */\n```"
        ],
        "signature": "let getExn: t<'a, 'b> => 'a"
      },
      {
        "id": "Belt.Result.mapWithDefaultU",
        "kind": "value",
        "name": "mapWithDefaultU",
        "docstrings": [],
        "signature": "let mapWithDefaultU: (t<'a, 'c>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Belt.Result.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [
          "`mapWithDefault(res, default, f)`: When res is `Ok(n)`, returns `f(n)`,\notherwise `default`.\n\n## Examples\n\n```rescript\nlet ok = Belt.Result.Ok(42)\nBelt.Result.mapWithDefault(ok, 0, (x) => x / 2) == 21\n\nlet error = Belt.Result.Error(\"Invalid data\")\nBelt.Result.mapWithDefault(error, 0, (x) => x / 2) == 0\n```"
        ],
        "signature": "let mapWithDefault: (t<'a, 'c>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Belt.Result.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a, 'c>, 'a => 'b) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(res, f)`: When res is `Ok(n)`, returns `Ok(f(n))`. Otherwise returns res\nunchanged. Function `f` takes a value of the same type as `n` and returns an\nordinary value.\n\n## Examples\n\n```rescript\nlet f = (x) => sqrt(Belt.Int.toFloat(x))\n\nBelt.Result.map(Ok(64), f) == Ok(8.0)\n\nBelt.Result.map(Error(\"Invalid data\"), f) == Error(\"Invalid data\")\n```"
        ],
        "signature": "let map: (t<'a, 'c>, 'a => 'b) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.flatMapU",
        "kind": "value",
        "name": "flatMapU",
        "docstrings": [],
        "signature": "let flatMapU: (t<'a, 'c>, 'a => t<'b, 'c>) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(res, f)`: When res is `Ok(n)`, returns `f(n)`. Otherwise, returns res\nunchanged. Function `f` takes a value of the same type as `n` and returns a\n`Belt.Result`.\n\n## Examples\n\n```rescript\nlet recip = (x) =>\n  if (x !== 0.0) {\n    Belt.Result.Ok(1.0 /. x)\n  } else {\n    Belt.Result.Error(\"Divide by zero\")\n  }\n\nBelt.Result.flatMap(Ok(2.0), recip) == Ok(0.5)\n\nBelt.Result.flatMap(Ok(0.0), recip) == Error(\"Divide by zero\")\n\nBelt.Result.flatMap(Error(\"Already bad\"), recip) == Error(\"Already bad\")\n```"
        ],
        "signature": "let flatMap: (t<'a, 'c>, 'a => t<'b, 'c>) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [
          "`getWithDefault(res, defaultValue)`: If `res` is `Ok(n)`, returns `n`,\notherwise `default`\n\n## Examples\n\n```rescript\nBelt.Result.getWithDefault(Ok(42), 0) == 42\n\nBelt.Result.getWithDefault(Error(\"Invalid Data\"), 0) == 0\n```"
        ],
        "signature": "let getWithDefault: (t<'a, 'b>, 'a) => 'a"
      },
      {
        "id": "Belt.Result.isOk",
        "kind": "value",
        "name": "isOk",
        "docstrings": [
          "`isOk(res)`: Returns `true` if `res` is of the form `Ok(n)`, `false` if it is\nthe `Error(e)` variant."
        ],
        "signature": "let isOk: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Result.isError",
        "kind": "value",
        "name": "isError",
        "docstrings": [
          "`isError(res)`: Returns `true` if `res` is of the form `Error(e)`, `false` if\nit is the `Ok(n)` variant."
        ],
        "signature": "let isError: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Result.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Result.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(res1, res2, f)`: Determine if two `Belt.Result` variables are equal with\nrespect to an equality function. If `res1` and `res2` are of the form `Ok(n)`\nand `Ok(m)`, return the result of `f(n, m)`. If one of `res1` and `res2` are of\nthe form `Error(e)`, return false If both `res1` and `res2` are of the form\n`Error(e)`, return true\n\n## Examples\n\n```rescript\nlet good1 = Belt.Result.Ok(42)\n\nlet good2 = Belt.Result.Ok(32)\n\nlet bad1 = Belt.Result.Error(\"invalid\")\n\nlet bad2 = Belt.Result.Error(\"really invalid\")\n\nlet mod10equal = (a, b) => mod(a, 10) === mod(b, 10)\n\nBelt.Result.eq(good1, good2, mod10equal) == true\n\nBelt.Result.eq(good1, bad1, mod10equal) == false\n\nBelt.Result.eq(bad2, good2, mod10equal) == false\n\nBelt.Result.eq(bad1, bad2, mod10equal) == true\n```"
        ],
        "signature": "let eq: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Result.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => int) => int"
      },
      {
        "id": "Belt.Result.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(res1, res2, f)`: Compare two `Belt.Result` variables with respect to a\ncomparison function. The comparison function returns -1 if the first variable\nis \"less than\" the second, 0 if the two variables are equal, and 1 if the first\nis \"greater than\" the second.\n\nIf `res1` and `res2` are of the form `Ok(n)` and `Ok(m)`, return the result of\n`f(n, m)`. If `res1` is of the form `Error(e)` and `res2` of the form `Ok(n)`,\nreturn -1 (nothing is less than something) If `res1` is of the form `Ok(n)` and\n`res2` of the form `Error(e)`, return 1 (something is greater than nothing) If\nboth `res1` and `res2` are of the form `Error(e)`, return 0 (equal)\n\n## Examples\n\n```rescript\nlet good1 = Belt.Result.Ok(59)\n\nlet good2 = Belt.Result.Ok(37)\n\nlet bad1 = Belt.Result.Error(\"invalid\")\n\nlet bad2 = Belt.Result.Error(\"really invalid\")\n\nlet mod10cmp = (a, b) => Pervasives.compare(mod(a, 10), mod(b, 10))\n\nBelt.Result.cmp(Ok(39), Ok(57), mod10cmp) == 1\n\nBelt.Result.cmp(Ok(57), Ok(39), mod10cmp) == (-1)\n\nBelt.Result.cmp(Ok(39), Error(\"y\"), mod10cmp) == 1\n\nBelt.Result.cmp(Error(\"x\"), Ok(57), mod10cmp) == (-1)\n\nBelt.Result.cmp(Error(\"x\"), Error(\"y\"), mod10cmp) == 0\n```"
        ],
        "signature": "let cmp: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => int) => int"
      }
    ]
  },
  "belt/option": {
    "id": "Belt.Option",
    "name": "Option",
    "docstrings": [
      "[`Belt.Option`]()\n\n  Utilities for option data type.",
      "In Belt we represent the existence and nonexistence of a value by wrapping it\nwith the `option` type.  In order to make it a bit more convenient to work with\noption-types, Belt provides utility-functions for it.\n\nThe `option` type is a part of the ReScript standard library which is defined like this:\n\n## Examples\n\n```rescript\ntype option<'a> = None | Some('a)\n```\n\n```rescript\nlet someString: option<string> = Some(\"hello\")\n```"
    ],
    "items": [
      {
        "id": "Belt.Option.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [
          "Uncurried version of `keep`"
        ],
        "signature": "let keepU: (option<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.Option.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "If `optionValue` is `Some(value)` and `p(value) = true`, it returns `Some(value)`; otherwise returns `None`\n\n## Examples\n\n```rescript\nBelt.Option.keep(Some(10), x => x > 5) /* returns `Some(10)` */\nBelt.Option.keep(Some(4), x => x > 5) /* returns `None` */\nBelt.Option.keep(None, x => x > 5) /* returns `None` */\n```"
        ],
        "signature": "let keep: (option<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.Option.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Uncurried version of `forEach`"
        ],
        "signature": "let forEachU: (option<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.Option.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "If `optionValue` is `Some(value`), it calls `f(value)`; otherwise returns `()`\n\n## Examples\n\n```rescript\nBelt.Option.forEach(Some(\"thing\"), x => Js.log(x)) /* logs \"thing\" */\nBelt.Option.forEach(None, x => Js.log(x)) /* returns () */\n```"
        ],
        "signature": "let forEach: (option<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.Option.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Raises an Error in case `None` is provided. Use with care.\n\n## Examples\n\n```rescript\nBelt.Option.getExn(Some(3)) /* 3 */\n\nBelt.Option.getExn(None) /* Raises an Error */\n```"
        ],
        "signature": "let getExn: option<'a> => 'a"
      },
      {
        "id": "Belt.Option.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(x)` returns `x`\n\nThis is an unsafe operation, it assumes `x` is neither `None`\nnor `Some(None(...)))`"
        ],
        "signature": "let getUnsafe: option<'a> => 'a"
      },
      {
        "id": "Belt.Option.mapWithDefaultU",
        "kind": "value",
        "name": "mapWithDefaultU",
        "docstrings": [
          "Uncurried version of `mapWithDefault`"
        ],
        "signature": "let mapWithDefaultU: (option<'a>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Belt.Option.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [
          "If `optionValue` is of `Some(value)`,\nthis function returns that value applied with `f`, in other words `f(value)`.\n\nIf `optionValue` is `None`, the default is returned.\n\n## Examples\n\n```rescript\nlet someValue = Some(3)\nsomeValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 8 */\n\nlet noneValue = None\nnoneValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 0 */\n```"
        ],
        "signature": "let mapWithDefault: (option<'a>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Belt.Option.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [
          "Uncurried version of `map`"
        ],
        "signature": "let mapU: (option<'a>, 'a => 'b) => option<'b>"
      },
      {
        "id": "Belt.Option.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "If `optionValue` is `Some(value)` this returns `f(value)`, otherwise it returns `None`.\n\n## Examples\n\n```rescript\nBelt.Option.map(Some(3), x => x * x) /* Some(9) */\n\nBelt.Option.map(None, x => x * x) /* None */\n```"
        ],
        "signature": "let map: (option<'a>, 'a => 'b) => option<'b>"
      },
      {
        "id": "Belt.Option.flatMapU",
        "kind": "value",
        "name": "flatMapU",
        "docstrings": [
          "Uncurried version of `flatMap`"
        ],
        "signature": "let flatMapU: (option<'a>, 'a => option<'b>) => option<'b>"
      },
      {
        "id": "Belt.Option.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "If `optionValue` is `Some(value)`, returns `f(value)`, otherwise returns\n`None`.<br/>\nThe function `f` must have a return type of `option<'b>`.\n\n## Examples\n\n```rescript\nlet addIfAboveOne = value =>\n   if (value > 1) {\n      Some(value + 1)\n   } else {\n      None\n   }\n\nBelt.Option.flatMap(Some(2), addIfAboveOne) /* Some(3) */\n\nBelt.Option.flatMap(Some(-4), addIfAboveOne) /* None */\n\nBelt.Option.flatMap(None, addIfAboveOne) /* None */\n```"
        ],
        "signature": "let flatMap: (option<'a>, 'a => option<'b>) => option<'b>"
      },
      {
        "id": "Belt.Option.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [
          "If `optionalValue` is `Some(value)`, returns `value`, otherwise default.\n\n## Examples\n\n```rescript\nBelt.Option.getWithDefault(None, \"Banana\") /* Banana */\n\nBelt.Option.getWithDefault(Some(\"Apple\"), \"Banana\") /* Apple */\n```\n\n```rescript\nlet greet = (firstName: option<string>) =>\n   \"Greetings \" ++ firstName->Belt.Option.getWithDefault(\"Anonymous\")\n\nSome(\"Jane\")->greet /* \"Greetings Jane\" */\n\nNone->greet /* \"Greetings Anonymous\" */\n```"
        ],
        "signature": "let getWithDefault: (option<'a>, 'a) => 'a"
      },
      {
        "id": "Belt.Option.orElse",
        "kind": "value",
        "name": "orElse",
        "docstrings": [
          "`orElse(optionalValue, otherOptional)` if `optionalValue` is `Some(value)`,\nreturns `Some(value)`, otherwise `otherOptional`\n\n## Examples\n\n```rescript\nBelt.Option.orElse(Some(1812), Some(1066)) == Some(1812)\nBelt.Option.orElse(None, Some(1066)) == Some(1066)\nBelt.Option.orElse(None, None) == None\n```"
        ],
        "signature": "let orElse: (option<'a>, option<'a>) => option<'a>"
      },
      {
        "id": "Belt.Option.isSome",
        "kind": "value",
        "name": "isSome",
        "docstrings": [
          "Returns `true` if the argument is `Some(value)`, `false` otherwise.\n\n## Examples\n\n```rescript\nBelt.Option.isSome(None) /* false */\n\nBelt.Option.isSome(Some(1)) /* true */\n```"
        ],
        "signature": "let isSome: option<'a> => bool"
      },
      {
        "id": "Belt.Option.isNone",
        "kind": "value",
        "name": "isNone",
        "docstrings": [
          "Returns `true` if the argument is `None`, `false` otherwise.\n\n## Examples\n\n```rescript\nBelt.Option.isNone(None) /* true */\n\nBelt.Option.isNone(Some(1)) /* false */\n```"
        ],
        "signature": "let isNone: option<'a> => bool"
      },
      {
        "id": "Belt.Option.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [
          "Uncurried version of `eq`"
        ],
        "signature": "let eqU: (option<'a>, option<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Option.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Evaluates two optional values for equality with respect to a predicate\nfunction. If both `optValue1` and `optValue2` are `None`, returns `true`.\nIf one of the arguments is `Some(value)` and the other is `None`, returns\n`false`.\n\nIf arguments are `Some(value1)` and `Some(value2)`, returns the result of\n`predicate(value1, value2)`; the predicate function must return a bool.\n\n## Examples\n\n```rescript\nlet clockEqual = (a, b) => mod(a, 12) == mod(b, 12)\n\nopen Belt.Option\n\neq(Some(3), Some(15), clockEqual) /* true */\n\neq(Some(3), None, clockEqual) /* false */\n\neq(None, Some(3), clockEqual) /* false */\n\neq(None, None, clockEqual) /* true */\n```"
        ],
        "signature": "let eq: (option<'a>, option<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Option.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [
          "Uncurried version of `cmp`"
        ],
        "signature": "let cmpU: (option<'a>, option<'b>, ('a, 'b) => int) => int"
      },
      {
        "id": "Belt.Option.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(optValue1, optValue2, comparisonFunction)` compares two optional values\nwith respect to given `comparisonFunction`.\n\nIf both `optValue1` and `optValue2` are `None`, it returns `0`.\n\nIf the first argument is `Some(value1)` and the second is `None`, returns `1`\n(something is greater than nothing).\n\nIf the first argument is `None` and the second is `Some(value2)`, returns `-1`\n(nothing is less than something).\n\nIf the arguments are `Some(value1)` and `Some(value2)`, returns the result of\n`comparisonFunction(value1, value2)`; comparisonFunction takes two arguments\nand returns `-1` if the first argument is less than the second, `0` if the\narguments are equal, and `1` if the first argument is greater than the second.\n\n## Examples\n\n```rescript\nlet clockCompare = (a, b) => compare(mod(a, 12), mod(b, 12))\n\nopen Belt.Option\n\ncmp(Some(3), Some(15), clockCompare) /* 0 */\n\ncmp(Some(3), Some(14), clockCompare) /* 1 */\n\ncmp(Some(2), Some(15), clockCompare) /* (-1) */\n\ncmp(None, Some(15), clockCompare) /* (-1) */\n\ncmp(Some(14), None, clockCompare) /* 1 */\n\ncmp(None, None, clockCompare) /* 0 */\n```"
        ],
        "signature": "let cmp: (option<'a>, option<'b>, ('a, 'b) => int) => int"
      }
    ]
  },
  "belt/hashmap": {
    "id": "Belt.HashMap",
    "name": "HashMap",
    "docstrings": [
      "[`Belt.HashMap`]()\n\n  The top level provides generic **mutable** hash map operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashMap.Int`]() and [`Belt.HashMap.String`]()",
      "A **mutable** Hash map which allows customized [`hash`]() behavior.\n\nAll data are parameterized by not its only type but also a unique identity in\nthe time of initialization, so that two _HashMaps of ints_ initialized with different\n_hash_ functions will have different type.\n\n## Examples\n\n```rescript\ntype t = int\nmodule I0 = unpack(Belt.Id.hashableU(~hash=(. a: t) => \"&\"(a, 0xff_ff), ~eq=(. a, b) => a == b))\nlet s0: t<_, string, _> = make(~hintSize=40, ~id=module(I0))\n\nmodule I1 = unpack(Belt.Id.hashableU(~hash=(. a: t) => \"&\"(a, 0xff), ~eq=(. a, b) => a == b))\nlet s1: t<_, string, _> = make(~hintSize=40, ~id=module(I1))\n```\n\nThe invariant must be held: for two elements who are _equal_,\ntheir hashed value should be the same\n\nHere the compiler would infer `s0` and `s1` having different type so that\nit would not mix.\n\n## Examples\n\n```rescript\nlet s0: t<int, I0.identity>\nlet s1: t<int, I1.identity>\n```\n\nWe can add elements to the collection:\n\n## Examples\n\n```rescript\nlet () = {\n  add(s1, 0, \"3\")\n  add(s1, 1, \"3\")\n}\n```\n\nSince this is an mutable data strucure, `s1` will contain two pairs."
    ],
    "items": [
      {
        "id": "Belt.HashMap.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of hash tables from type `'key` to type `'value`."
        ],
        "signature": "type t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making an empty hash map."
        ],
        "signature": "type id<'a, 'id> = Belt_Id.hashable<'a, 'id>"
      },
      {
        "id": "Belt.HashMap.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(~hintSize=10, ~id)` creates a new map by taking in the comparator and `hintSize`.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n\nBelt.HashMap.set(hMap, 0, \"a\")\n```"
        ],
        "signature": "let make: (~hintSize: int, ~id: id<'key, 'id>) => t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Clears a hash table.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.fromArray([(1, \"1\")], ~id=module(IntHash))\nBelt.HashMap.clear(hMap)\nBelt.HashMap.isEmpty(hMap) == true\n```"
        ],
        "signature": "let clear: t<'key, 'value, 'id> => unit"
      },
      {
        "id": "Belt.HashMap.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "`isEmpty(m)` checks whether a hash map is empty.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nBelt.HashMap.isEmpty(Belt.HashMap.fromArray([(1, \"1\")], ~id=module(IntHash))) == false\n```"
        ],
        "signature": "let isEmpty: t<'a, 'b, 'c> => bool"
      },
      {
        "id": "Belt.HashMap.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(hMap, k, v)` if `k` does not exist, add the binding `k,v`, otherwise, update the old value with the new `v`.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntHash))\n\nBelt.HashMap.set(s0, 2, \"3\")\n\nBelt.HashMap.valuesToArray(s0) == [\"1\", \"3\", \"3\"]\n```"
        ],
        "signature": "let set: (t<'key, 'value, 'id>, 'key, 'value) => unit"
      },
      {
        "id": "Belt.HashMap.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "Creates copy of a hash map.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntHash))\nlet s1 = Belt.HashMap.copy(s0)\n\nBelt.HashMap.set(s0, 2, \"3\")\n\nBelt.HashMap.get(s0, 2) != Belt.HashMap.get(s1, 2)\n```"
        ],
        "signature": "let copy: t<'key, 'value, 'id> => t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns value bound under specific key. If values not exist returns `None`.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\n\nBelt.HashMap.get(s0, 1) == Some(\"value1\")\nBelt.HashMap.get(s0, 2) == None\n```"
        ],
        "signature": "let get: (t<'key, 'value, 'id>, 'key) => option<'value>"
      },
      {
        "id": "Belt.HashMap.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if `x` is bound in `tbl`.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\n\nBelt.HashMap.has(s0, 1) == true\nBelt.HashMap.has(s0, 2) == false\n```"
        ],
        "signature": "let has: (t<'key, 'value, 'id>, 'key) => bool"
      },
      {
        "id": "Belt.HashMap.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "If bound exists, removes it from the hash map.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.remove(s0, 1)\nBelt.HashMap.has(s0, 1) == false\n```"
        ],
        "signature": "let remove: (t<'key, 'value, 'id>, 'key) => unit"
      },
      {
        "id": "Belt.HashMap.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as [forEach](#forEach) but takes uncurried function."
        ],
        "signature": "let forEachU: (t<'key, 'value, 'id>, ('key, 'value) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(tbl, f)` applies `f` to all bindings in table `tbl`. `f` receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to `f`.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.forEach(s0, (key, value) => Js.log2(key, value))\n// prints (1, \"value1\")\n```"
        ],
        "signature": "let forEach: (t<'key, 'value, 'id>, ('key, 'value) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'key, 'value, 'id>, 'c, ('c, 'key, 'value) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(tbl, init, f)` computes `(f(kN, dN) ... (f(k1, d1, init))...)`, where `k1 ... kN` are the keys of all bindings in `tbl`, and `d1 ... dN` are the associated values. Each binding is presented exactly once to `f`.\n\nThe order in which the bindings are passed to `f` is unspecified. However, if the table contains several bindings for the same key, they are passed to `f` in reverse order of introduction, that is, the most recent binding is passed first.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.set(s0, 2, \"value2\")\n\nBelt.HashMap.reduce(s0, \"\", (acc, key, value) => acc ++ (\", \" ++ value)) == \"value1, value2\"\n```"
        ],
        "signature": "let reduce: (t<'key, 'value, 'id>, 'c, ('c, 'key, 'value) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "docstrings": [
          "Same as [keepMapInPlace](#keepMapInPlace) but takes uncurried function."
        ],
        "signature": "let keepMapInPlaceU: (\n  t<'key, 'value, 'id>,\n  ('key, 'value) => option<'value>,\n) => unit"
      },
      {
        "id": "Belt.HashMap.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "docstrings": [
          "Filters out values for which function `f` returned `None`.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.set(s0, 2, \"value2\")\n\nBelt.HashMap.keepMapInPlace(s0, (key, value) => key == 1 ? None : Some(value))\n```"
        ],
        "signature": "let keepMapInPlace: (\n  t<'key, 'value, 'id>,\n  ('key, 'value) => option<'value>,\n) => unit"
      },
      {
        "id": "Belt.HashMap.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "`size(tbl)` returns the number of bindings in `tbl`. It takes constant time.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.set(s0, 2, \"value2\")\n\nBelt.HashMap.size(s0) == 2\n```"
        ],
        "signature": "let size: t<'a, 'b, 'c> => int"
      },
      {
        "id": "Belt.HashMap.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of key value pairs.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.set(s0, 2, \"value2\")\n\nBelt.HashMap.toArray(s0) == [(1, \"value1\"), (2, \"value2\")]\n```"
        ],
        "signature": "let toArray: t<'key, 'value, 'id> => array<('key, 'value)>"
      },
      {
        "id": "Belt.HashMap.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [
          "Returns array of keys.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.set(s0, 2, \"value2\")\n\nBelt.HashMap.keysToArray(s0) == [1, 2]\n```"
        ],
        "signature": "let keysToArray: t<'key, 'a, 'b> => array<'key>"
      },
      {
        "id": "Belt.HashMap.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [
          "Returns array of values.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\nBelt.HashMap.set(s0, 2, \"value2\")\n\nBelt.HashMap.valuesToArray(s0) == [\"value1\", \"value2\"]\n```"
        ],
        "signature": "let valuesToArray: t<'a, 'value, 'b> => array<'value>"
      },
      {
        "id": "Belt.HashMap.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new hash map from array of pairs.\n\nReturns array of values.\n\n## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(1, \"value1\"), (2, \"value2\")], ~id=module(IntHash))\nBelt.HashMap.toArray(s0) == [(1, \"value1\"), (2, \"value2\")]\n```"
        ],
        "signature": "let fromArray: (\n  array<('key, 'value)>,\n  ~id: id<'key, 'id>,\n) => t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.mergeMany(hMap, [(1, \"1\"), (2, \"2\")])\n```"
        ],
        "signature": "let mergeMany: (t<'key, 'value, 'id>, array<('key, 'value)>) => unit"
      },
      {
        "id": "Belt.HashMap.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [
          "## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(hMap, 1, \"1\")\n\nBelt.HashMap.getBucketHistogram(hMap)\n```"
        ],
        "signature": "let getBucketHistogram: t<'a, 'b, 'c> => array<int>"
      },
      {
        "id": "Belt.HashMap.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [
          "## Examples\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(hMap, 1, \"1\")\n\nBelt.HashMap.logStats(hMap)\n```"
        ],
        "signature": "let logStats: t<'a, 'b, 'c> => unit"
      }
    ]
  },
  "belt/hashset": {
    "id": "Belt.HashSet",
    "name": "HashSet",
    "docstrings": [
      "[`Belt.HashSet`]()\n\n  The top level provides generic **mutable** hash set operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashSet.Int`]() and [`Belt.HashSet.String`]()",
      "A **mutable** Hash set which allows customized `hash` behavior.\n\nAll data are parameterized by not its only type but also a unique identity in\nthe time of initialization, so that two _HashSets of ints_ initialized with\ndifferent _hash_ functions will have different type.\n\n## Examples\n\n```rescript\nmodule I0 = unpack(\n  Belt.Id.hashableU(\n    ~hash=(. a: int) => land(a, 65535),\n    ~eq=(. a, b) => a == b,\n  )\n)\n\nlet s0 = Belt.HashSet.make(~id=module(I0), ~hintSize=40)\n\nmodule I1 = unpack(\n  Belt.Id.hashableU(\n    ~hash=(. a: int) => land(a, 255),\n    ~eq=(. a, b) => a == b,\n  )\n)\n\nlet s1 = Belt.HashSet.make(~id=module(I1), ~hintSize=40)\n\nBelt.HashSet.add(s1, 0)\nBelt.HashSet.add(s1, 1)\n```\n\nThe invariant must be held: for two elements who are equal, their hashed\nvalue should be the same.\n\nHere the compiler would infer `s0` and `s1` having different type so that it\nwould not mix.\n\n## Examples\n\n```rescript\nlet s0: Belt.HashSet.t<int, I0.identity>\nlet s1: Belt.HashSet.t<int, I1.identity>\n```\n\nWe can add elements to the collection (see last two lines in the example\nabove). Since this is an mutable data structure, `s1` will contain two pairs."
    ],
    "items": [
      {
        "id": "Belt.HashSet.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The type of hash tables from type `'a` to type `'b`."
        ],
        "signature": "type id<'a, 'id> = Belt_Id.hashable<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int, ~id: id<'a, 'id>) => t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a, 'id> => unit"
      },
      {
        "id": "Belt.HashSet.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.HashSet.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t<'a, 'id>, 'a) => unit"
      },
      {
        "id": "Belt.HashSet.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t<'a, 'id> => t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'a, 'id>, 'a) => bool"
      },
      {
        "id": "Belt.HashSet.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t<'a, 'id>, 'a) => unit"
      },
      {
        "id": "Belt.HashSet.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a, 'id>, 'a => unit) => unit"
      },
      {
        "id": "Belt.HashSet.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Order unspecified."
        ],
        "signature": "let forEach: (t<'a, 'id>, 'a => unit) => unit"
      },
      {
        "id": "Belt.HashSet.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a, 'id>, 'c, ('c, 'a) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Order unspecified."
        ],
        "signature": "let reduce: (t<'a, 'id>, 'c, ('c, 'a) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a, 'id> => int"
      },
      {
        "id": "Belt.HashSet.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t<'a, 'b> => unit"
      },
      {
        "id": "Belt.HashSet.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'a, 'id> => array<'a>"
      },
      {
        "id": "Belt.HashSet.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: (array<'a>, ~id: id<'a, 'id>) => t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'a, 'id>, array<'a>) => unit"
      },
      {
        "id": "Belt.HashSet.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t<'a, 'b> => array<int>"
      }
    ]
  },
  "belt/mutablemap": {
    "id": "Belt.MutableMap",
    "name": "MutableMap",
    "docstrings": [
      "[`Belt.MutableMap`]()\n\n  The top level provides generic **mutable** map operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableMap.Int`]() and [`Belt.MutableMap.String`]()"
    ],
    "items": [
      {
        "id": "Belt.MutableMap.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.MutableMap.id",
        "kind": "type",
        "name": "id",
        "docstrings": [],
        "signature": "type id<'key, 'id> = Belt_Id.comparable<'key, 'id>"
      },
      {
        "id": "Belt.MutableMap.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~id: id<'k, 'id>) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.MutableMap.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a, 'b, 'c> => unit"
      },
      {
        "id": "Belt.MutableMap.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a, 'b, 'c> => bool"
      },
      {
        "id": "Belt.MutableMap.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'k, 'a, 'b>, 'k) => bool"
      },
      {
        "id": "Belt.MutableMap.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(m1, m2, cmp)` First compare by size, if size is the same, compare by\nkey, value pair."
        ],
        "signature": "let cmp: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2, eqf)` tests whether the maps `m1` and `m2` are equal, that is,\ncontain equal keys and associate them with equal data. `eqf` is the\nequality predicate used to compare the data associated with the keys."
        ],
        "signature": "let eq: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies f to all bindings in map `m`. `f` receives the `'k`\nas first argument, and the associated value as second argument. The\nbindings are passed to `f` in increasing order with respect to the ordering\nover the type of the keys."
        ],
        "signature": "let forEach: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f), computes`(f(kN, dN) ... (f(k1, d1, a))...)`, where`k1 ...\nkN`are the keys of all bindings in`m`(in increasing order), and`d1 ... dN`\nare the associated data."
        ],
        "signature": "let reduce: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate `p`."
        ],
        "signature": "let every: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the predicate `p`."
        ],
        "signature": "let some: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'k, 'a, 'id> => int"
      },
      {
        "id": "Belt.MutableMap.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'k, 'a, 'id> => list<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'k, 'a, 'id> => array<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: (array<('k, 'a)>, ~id: id<'k, 'id>) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.MutableMap.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'k, 'a, 'b> => array<'k>"
      },
      {
        "id": "Belt.MutableMap.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'b, 'a, 'c> => array<'a>"
      },
      {
        "id": "Belt.MutableMap.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.MutableMap.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.MutableMap.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.MutableMap.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.MutableMap.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'k, 'a, 'id>, 'k) => option<'a>"
      },
      {
        "id": "Belt.MutableMap.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'k, 'a, 'id>, 'k) => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableMap.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'k, 'a, 'id>, 'k, 'a) => 'a"
      },
      {
        "id": "Belt.MutableMap.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'k, 'a, 'id>, 'k) => 'a"
      },
      {
        "id": "Belt.MutableMap.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "Raise when invariant is not held."
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit"
      },
      {
        "id": "Belt.MutableMap.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` do the in-place modification."
        ],
        "signature": "let remove: (t<'k, 'a, 'id>, 'k) => unit"
      },
      {
        "id": "Belt.MutableMap.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'k, 'a, 'id>, array<'k>) => unit"
      },
      {
        "id": "Belt.MutableMap.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` do the in-place modification"
        ],
        "signature": "let set: (t<'k, 'a, 'id>, 'k, 'a) => unit"
      },
      {
        "id": "Belt.MutableMap.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'k, 'a, 'id>, 'k, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'k, 'a, 'id>, 'k, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'k, 'a, 'id>, array<('k, 'a)>) => unit"
      },
      {
        "id": "Belt.MutableMap.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.MutableMap.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated\nvalue a of all bindings of `m` has been replaced by the result of the\napplication of `f` to `a`. The bindings are passed to `f` in increasing\norder with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.MutableMap.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.MutableMap.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>"
      }
    ]
  },
  "belt/mutableset": {
    "id": "Belt.MutableSet",
    "name": "MutableSet",
    "docstrings": [
      "[`Belt.MutableSet`]()\n\n  The top level provides generic **mutable** set operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableSet.Int`]() and [`Belt.MutableSet.String`]()",
      "A **mutable** sorted set module which allows customized compare behavior.\nThe implementation uses balanced binary trees, and therefore searching and insertion take time logarithmic in the size of the map.\n\nIt also has two specialized inner modules [Belt.MutableSet.Int](mutable-set-int) and [Belt.MutableSet.String](mutable-set-string) - This module separates data from function which is more verbose but slightly more efficient\n\n## Examples\n\n```rescript\nmodule PairComparator = Belt.Id.MakeComparable({\n  type t = (int, int)\n  let cmp = ((a0, a1), (b0, b1)) =>\n    switch Pervasives.compare(a0, b0) {\n    | 0 => Pervasives.compare(a1, b1)\n    | c => c\n    }\n})\n\nlet mySet = Belt.MutableSet.make(~id=module(PairComparator))\nmySet->Belt.MutableSet.add((1, 2))\n```"
    ],
    "items": [
      {
        "id": "Belt.MutableSet.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'value` is the element type\n\n`'identity` the identity of the collection"
        ],
        "signature": "type t<'value, 'identity>"
      },
      {
        "id": "Belt.MutableSet.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making a set from scratch"
        ],
        "signature": "type id<'value, 'id> = Belt_Id.comparable<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new set by taking in the comparator"
        ],
        "signature": "let make: (~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new set from array of elements.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.toArray /* [1, 2, 3, 4] */\n```"
        ],
        "signature": "let fromArray: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [
          "The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted."
        ],
        "signature": "let fromSortedArrayUnsafe: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "Returns copy of a set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\nlet copied = s0->Belt.MutableSet.copy\ncopied->Belt.MutableSet.toArray /* [1, 2, 3, 4] */\n```"
        ],
        "signature": "let copy: t<'value, 'id> => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Checks if set is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet empty = Belt.MutableSet.fromArray([], ~id=module(IntCmp))\nlet notEmpty = Belt.MutableSet.fromArray([1], ~id=module(IntCmp))\n\nBelt.MutableSet.isEmpty(empty) /* true */\nBelt.MutableSet.isEmpty(notEmpty) /* false */\n```"
        ],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.MutableSet.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if element exists in set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet set = Belt.MutableSet.fromArray([1, 4, 2, 5], ~id=module(IntCmp))\n\nset->Belt.MutableSet.has(3) /* false */\nset->Belt.MutableSet.has(1) /* true */\n```"
        ],
        "signature": "let has: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.MutableSet.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds element to set. If element existed in set, value is unchanged.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.make(~id=module(IntCmp))\ns0->Belt.MutableSet.add(1)\ns0->Belt.MutableSet.add(2)\ns0->Belt.MutableSet.add(2)\n\ns0->Belt.MutableSet.toArray /* [1, 2] */\n```"
        ],
        "signature": "let add: (t<'value, 'id>, 'value) => unit"
      },
      {
        "id": "Belt.MutableSet.addCheck",
        "kind": "value",
        "name": "addCheck",
        "docstrings": [],
        "signature": "let addCheck: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.MutableSet.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "Adds each element of array to set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet set = Belt.MutableSet.make(~id=module(IntCmp))\n\nset->Belt.MutableSet.mergeMany([5, 4, 3, 2, 1])\nset->Belt.MutableSet.toArray /* [1, 2, 3, 4, 5] */\n```"
        ],
        "signature": "let mergeMany: (t<'value, 'id>, array<'value>) => unit"
      },
      {
        "id": "Belt.MutableSet.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "Removes element from set. If element did not exist in set, value is unchanged.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([2, 3, 1, 4, 5], ~id=module(IntCmp))\ns0->Belt.MutableSet.remove(1)\ns0->Belt.MutableSet.remove(3)\ns0->Belt.MutableSet.remove(3)\n\ns0->Belt.MutableSet.toArray /* [2,4,5] */\n```"
        ],
        "signature": "let remove: (t<'value, 'id>, 'value) => unit"
      },
      {
        "id": "Belt.MutableSet.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "docstrings": [],
        "signature": "let removeCheck: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.MutableSet.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "Removes each element of array from set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet set = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))\n\nset->Belt.MutableSet.removeMany([5, 4, 3, 2, 1])\nset->Belt.MutableSet.toArray /* [] */\n```"
        ],
        "signature": "let removeMany: (t<'value, 'id>, array<'value>) => unit"
      },
      {
        "id": "Belt.MutableSet.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "Returns union of two sets.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\nlet union = Belt.MutableSet.union(s0, s1)\nunion->Belt.MutableSet.toArray /* [1,2,3,4,5,6] */\n```"
        ],
        "signature": "let union: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "Returns intersection of two sets.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\nlet intersect = Belt.MutableSet.intersect(s0, s1)\nintersect->Belt.MutableSet.toArray /* [2,3,5] */\n```"
        ],
        "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [
          "Returns elements from first set, not existing in second set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\nBelt.MutableSet.toArray(Belt.MutableSet.diff(s0, s1)) /* [6] */\nBelt.MutableSet.toArray(Belt.MutableSet.diff(s1, s0)) /* [1,4] */\n```"
        ],
        "signature": "let diff: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "Checks if second set is subset of first set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\nlet s2 = Belt.MutableSet.intersect(s0, s1)\nBelt.MutableSet.subset(s2, s0) /* true */\nBelt.MutableSet.subset(s2, s1) /* true */\nBelt.MutableSet.subset(s1, s0) /* false */\n```"
        ],
        "signature": "let subset: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.MutableSet.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets of sets.\nIt compares size first and then iterates over each element following the order of elements."
        ],
        "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>) => int"
      },
      {
        "id": "Belt.MutableSet.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Checks if two sets are equal.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([5, 2, 3], ~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([3, 2, 5], ~id=module(IntCmp))\n\nBelt.MutableSet.eq(s0, s1) /* true */\n```"
        ],
        "signature": "let eq: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.MutableSet.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as `Belt.MutableSet.forEach` but takes uncurried functon."
        ],
        "signature": "let forEachU: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Applies function `f` in turn to all elements of set in increasing order.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\nlet acc = ref(list{})\ns0->Belt.MutableSet.forEach(x => acc := Belt.List.add(acc.contents, x))\nacc /* [6,5,3,2] */\n```"
        ],
        "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an accumulator, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\ns0->Belt.MutableSet.reduce(list{}, (acc, element) => acc->Belt.List.add(element)) /* [6,5,3,2] */\n```"
        ],
        "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isEven = x => mod(x, 2) == 0\n\nlet s0 = Belt.MutableSet.fromArray([2, 4, 6, 8], ~id=module(IntCmp))\ns0->Belt.MutableSet.every(isEven) /* true */\n```"
        ],
        "signature": "let every: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Checks if at least one element of the set satisfies the predicate.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isOdd = x => mod(x, 2) != 0\n\nlet s0 = Belt.MutableSet.fromArray([1, 2, 4, 6, 8], ~id=module(IntCmp))\ns0->Belt.MutableSet.some(isOdd) /* true */\n```"
        ],
        "signature": "let some: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns the set of all elements that satisfy the predicate.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isEven = x => mod(x, 2) == 0\n\nlet s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\nlet s1 = s0->Belt.MutableSet.keep(isEven)\n\ns1->Belt.MutableSet.toArray /* [2, 4] */\n```"
        ],
        "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (\n  t<'value, 'id>,\n  'value => bool,\n) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.MutableSet.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet isOdd = x => mod(x, 2) != 0\n\nlet s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\nlet (s1, s2) = s0->Belt.MutableSet.partition(isOdd)\n\ns1->Belt.MutableSet.toArray /* [1,3,5] */\ns2->Belt.MutableSet.toArray /* [2,4] */\n```"
        ],
        "signature": "let partition: (\n  t<'value, 'id>,\n  'value => bool,\n) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.MutableSet.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns size of the set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.size /* 4 */\n```"
        ],
        "signature": "let size: t<'value, 'id> => int"
      },
      {
        "id": "Belt.MutableSet.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "Returns list of ordered set elements.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.toList /* [1,2,3,5] */\n```"
        ],
        "signature": "let toList: t<'value, 'id> => list<'value>"
      },
      {
        "id": "Belt.MutableSet.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of ordered set elements.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.toArray /* [1,2,3,5] */\n```"
        ],
        "signature": "let toArray: t<'value, 'id> => array<'value>"
      },
      {
        "id": "Belt.MutableSet.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "Returns minimum value of the collection. `None` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.make(~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.minimum /* None */\ns1->Belt.MutableSet.minimum /* Some(1) */\n```"
        ],
        "signature": "let minimum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.MutableSet.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "Returns minimum value of the collection. `undefined` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.make(~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.minUndefined /* undefined */\ns1->Belt.MutableSet.minUndefined /* 1 */\n```"
        ],
        "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.MutableSet.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "Returns maximum value of the collection. `None` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.make(~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.maximum /* None */\ns1->Belt.MutableSet.maximum /* Some(5) */\n```"
        ],
        "signature": "let maximum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.MutableSet.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "Returns maximum value of the collection. `undefined` if collection is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.make(~id=module(IntCmp))\nlet s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.maxUndefined /* undefined */\ns1->Belt.MutableSet.maxUndefined /* 5 */\n```"
        ],
        "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.MutableSet.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n\ns0->Belt.MutableSet.get(3) /* Some(3) */\ns0->Belt.MutableSet.get(20) /* None */\n```"
        ],
        "signature": "let get: (t<'value, 'id>, 'value) => option<'value>"
      },
      {
        "id": "Belt.MutableSet.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "Same as `Belt.MutableSet.get` but returns `undefined` when element does not exist."
        ],
        "signature": "let getUndefined: (t<'value, 'id>, 'value) => Js.undefined<'value>"
      },
      {
        "id": "Belt.MutableSet.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as `Belt.MutableSet.get` but raise when element does not exist."
        ],
        "signature": "let getExn: (t<'value, 'id>, 'value) => 'value"
      },
      {
        "id": "Belt.MutableSet.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = Pervasives.compare\n})\n\nlet s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n\nlet ((smaller, larger), present) = s0->Belt.MutableSet.split(3)\n\npresent /* true */\nsmaller->Belt.MutableSet.toArray /* [1,2] */\nlarger->Belt.MutableSet.toArray /* [4,5] */\n```"
        ],
        "signature": "let split: (\n  t<'value, 'id>,\n  'value,\n) => ((t<'value, 'id>, t<'value, 'id>), bool)"
      },
      {
        "id": "Belt.MutableSet.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b> => unit"
      }
    ]
  },
  "belt/map": {
    "id": "Belt.Map",
    "name": "Map",
    "docstrings": [
      "[`Belt.Map`](),\n\n  The top level provides generic **immutable** map operations.\n\n  It also has three specialized inner modules\n  [`Belt.Map.Int`](), [`Belt.Map.String`]() and\n\n  [`Belt.Map.Dict`](): This module separates data from function\n  which  is more verbose but slightly more efficient",
      "The top level provides generic immutable map operations.\n\nIt also has three specialized inner modules `Belt.Map.Int`, `Belt.Map.String`\nand `Belt.Map.Dict`."
    ],
    "items": [
      {
        "id": "Belt.Map.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'key` is the field type\n\n`'value` is the element type\n\n`'identity` the identity of the collection"
        ],
        "signature": "type t<'key, 'value, 'identity>"
      },
      {
        "id": "Belt.Map.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making an empty map."
        ],
        "signature": "type id<'key, 'id> = Belt_Id.comparable<'key, 'id>"
      },
      {
        "id": "Belt.Map.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(~id)` creates a new map by taking in the comparator.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet m = Belt.Map.make(~id=module(IntCmp))\n\nBelt.Map.set(m, 0, \"a\")\n```"
        ],
        "signature": "let make: (~id: id<'k, 'id>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "`isEmpty(m)` checks whether a map m is empty.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.isEmpty(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp))) == false\n```"
        ],
        "signature": "let isEmpty: t<'a, 'b, 'c> => bool"
      },
      {
        "id": "Belt.Map.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "`has(m, k)` checks whether `m` has the key `k`.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.has(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp)), 1) == true\n```"
        ],
        "signature": "let has: (t<'k, 'v, 'id>, 'k) => bool"
      },
      {
        "id": "Belt.Map.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(m0, m1, vcmp);`\n\nTotal ordering of map given total ordering of value function.\n\nIt will compare size first and each element following the order one by one."
        ],
        "signature": "let cmp: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "eq(m1, m2, veq)` tests whether the maps `m1` and `m2` are equal, that is,\ncontain equal keys and associate them with equal data. `veq` is the\nequality predicate used to compare the data associated with the keys."
        ],
        "signature": "let eq: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`\nfindFirstBy(m, p)` uses function `f` to find the first key value pair to match predicate `p`.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\nBelt.Map.findFirstBy(s0, (k, v) => k == 4) /* (4, \"4\") */\n```"
        ],
        "signature": "let findFirstBy: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'k, 'v, 'id>, ('k, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the\n`'k` as first argument, and the associated value as second argument. The\nbindings are passed to `f` in increasing order with respect to the ordering\nover the type of the keys.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\nlet acc = ref(list{})\n\nBelt.Map.forEach(s0, (k, v) => acc := list{(k, v), ...acc.contents})\n\nacc.contents == list{(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\")}\n```"
        ],
        "signature": "let forEach: (t<'k, 'v, 'id>, ('k, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'k, 'v, 'id>, 'acc, ('acc, 'k, 'v) => 'acc) => 'acc"
      },
      {
        "id": "Belt.Map.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `(f(kN, dN) ... (f(k1, d1, a))...)`, where `k1\n... kN` are the keys of all bindings in m (in increasing order), and `d1\n... dN` are the associated data.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"3\")])\n\nBelt.Map.reduce(s0, list{}, (acc, k, v) => list{\n    (k, v),\n    ...acc,\n}) /* [(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\"), 0] */\n```"
        ],
        "signature": "let reduce: (t<'k, 'v, 'id>, 'acc, ('acc, 'k, 'v) => 'acc) => 'acc"
      },
      {
        "id": "Belt.Map.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate\n`p`. Order unspecified"
        ],
        "signature": "let every: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the predicate \n`p`. Order unspecified"
        ],
        "signature": "let some: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "`size(s)`\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.size(Belt.Map.fromArray([(2, \"2\"), (2, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == 2\n```"
        ],
        "signature": "let size: t<'k, 'v, 'id> => int"
      },
      {
        "id": "Belt.Map.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "`toArray(s)`\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n  (1, \"1\"),\n  (2, \"2\"),\n  (3, \"3\"),\n  ]\n```"
        ],
        "signature": "let toArray: t<'k, 'v, 'id> => array<('k, 'v)>"
      },
      {
        "id": "Belt.Map.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order. See `Belt.Map.toArray`"
        ],
        "signature": "let toList: t<'k, 'v, 'id> => list<('k, 'v)>"
      },
      {
        "id": "Belt.Map.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray(kvs, ~id);`\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n    (1, \"1\"),\n    (2, \"2\"),\n    (3, \"3\"),\n  ]\n```"
        ],
        "signature": "let fromArray: (array<('k, 'v)>, ~id: id<'k, 'id>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [
          "`keysToArray(s);`\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.keysToArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n    1,\n    2,\n    3,\n  ]\n```"
        ],
        "signature": "let keysToArray: t<'k, 'v, 'id> => array<'k>"
      },
      {
        "id": "Belt.Map.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [
          "`valuesToArray(s);`\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.valuesToArray(\n  Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)),\n) == [\"1\", \"2\", \"3\"]\n```"
        ],
        "signature": "let valuesToArray: t<'k, 'v, 'id> => array<'v>"
      },
      {
        "id": "Belt.Map.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [
          "`minKey(s)` returns the minimum key, None if not exist."
        ],
        "signature": "let minKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [
          "See `Belt.Map.minKey`"
        ],
        "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [
          "`maxKey(s)` returns the maximum key, None if not exist."
        ],
        "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [
          "See `Belt.Map.maxKey`"
        ],
        "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "`minimum(s)` returns the minimum key value pair, None if not exist."
        ],
        "signature": "let minimum: t<'k, 'v, 'a> => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "See `Belt.Map.minimum`"
        ],
        "signature": "let minUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>"
      },
      {
        "id": "Belt.Map.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "`maximum(s)` returns the maximum key value pair, None if not exist."
        ],
        "signature": "let maximum: t<'k, 'v, 'a> => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "See `Belt.Map.maximum`"
        ],
        "signature": "let maxUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>"
      },
      {
        "id": "Belt.Map.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "`get(s, k)`\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) ==\n  Some(\"2\")\n\nBelt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) == None\n```"
        ],
        "signature": "let get: (t<'k, 'v, 'id>, 'k) => option<'v>"
      },
      {
        "id": "Belt.Map.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "See `Belt.Map.get`. Returns `undefined` when not found"
        ],
        "signature": "let getUndefined: (t<'k, 'v, 'id>, 'k) => Js.undefined<'v>"
      },
      {
        "id": "Belt.Map.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [
          "`getWithDefault(s, k, default)`\n\nSee `Belt.Map.get`\n\nReturns default when `k` is not found."
        ],
        "signature": "let getWithDefault: (t<'k, 'v, 'id>, 'k, 'v) => 'v"
      },
      {
        "id": "Belt.Map.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(s, k)`\n\nSee `Belt.Map.getExn`\n\nraise when `k` not exist"
        ],
        "signature": "let getExn: (t<'k, 'v, 'id>, 'k) => 'v"
      },
      {
        "id": "Belt.Map.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` when `x` is not in `m`, `m` is returned reference unchanged.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\nlet s1 = Belt.Map.remove(s0, 1)\n\nlet s2 = Belt.Map.remove(s1, 1)\n\ns1 === s2\n\nBelt.Map.keysToArray(s1) == [2, 3]\n```"
        ],
        "signature": "let remove: (t<'k, 'v, 'id>, 'k) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "`removeMany(s, xs)`\n\nRemoving each of `xs` to `s`, note unlike `Belt.Map.remove`, the reference\nof return value might be changed even if none in `xs` exists `s`."
        ],
        "signature": "let removeMany: (t<'k, 'v, 'id>, array<'k>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` returns a map containing the same bindings as `m`, with a\nnew binding of `x` to `y`. If `x` was already bound in `m`, its previous\nbinding disappears.\n\n## Examples\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\nlet s1 = Belt.Map.set(s0, 2, \"3\")\n\nBelt.Map.valuesToArray(s1) == [\"1\", \"3\", \"3\"]\n```"
        ],
        "signature": "let set: (t<'k, 'v, 'id>, 'k, 'v) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (\n  t<'k, 'v, 'id>,\n  'k,\n  option<'v> => option<'v>,\n) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.update",
        "kind": "value",
        "name": "update",
        "docstrings": [
          "`update(m, x, f)` returns a map containing the same bindings as `m`, except\nfor the binding of `x`. Depending on the value of `y` where `y` is\n`f(get(m, x))`, the binding of `x` is added, removed or updated. If `y` is\n`None`, the binding is removed if it exists; otherwise, if `y` is `Some(z)`\nthen `x` is associated to `z` in the resulting map."
        ],
        "signature": "let update: (\n  t<'k, 'v, 'id>,\n  'k,\n  option<'v> => option<'v>,\n) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "`mergeMany(s, xs)`\n\nAdding each of `xs` to `s`, note unlike `add`, the reference of return\nvalue might be changed even if all values in `xs` exist `s`."
        ],
        "signature": "let mergeMany: (t<'k, 'v, 'id>, array<('k, 'v)>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (\n  t<'k, 'v, 'id>,\n  t<'k, 'v2, 'id>,\n  ('k, option<'v>, option<'v2>) => option<'v3>,\n) => t<'k, 'v3, 'id>"
      },
      {
        "id": "Belt.Map.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\nand of `m2`. The presence of each such binding, and the corresponding\nvalue, is determined with the function `f`."
        ],
        "signature": "let merge: (\n  t<'k, 'v, 'id>,\n  t<'k, 'v2, 'id>,\n  ('k, option<'v>, option<'v2>) => option<'v3>,\n) => t<'k, 'v3, 'id>"
      },
      {
        "id": "Belt.Map.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'k, 'v, 'id>, ('k, 'v) => bool) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(m, p)` returns the map with all the bindings in m that satisfy\npredicate `p`."
        ],
        "signature": "let keep: (t<'k, 'v, 'id>, ('k, 'v) => bool) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (\n  t<'k, 'v, 'id>,\n  ('k, 'v) => bool,\n) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)"
      },
      {
        "id": "Belt.Map.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains\nall the bindings of `s` that satisfy the predicate `p`, and `m2` is the map\nwith all the bindings of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (\n  t<'k, 'v, 'id>,\n  ('k, 'v) => bool,\n) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)"
      },
      {
        "id": "Belt.Map.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, m)` returns a tuple `(l, r)`, data, where `l` is the map with all\nthe bindings of `m` whose 'k is strictly less than `x`; `r` is the map with\nall the bindings of m whose 'k is strictly greater than `x`; `data` is\n`None` if `m` contains no binding for `x`, or `Some(v)` if `m` binds `v` to\n`x`."
        ],
        "signature": "let split: (\n  t<'k, 'v, 'id>,\n  'k,\n) => ((t<'k, 'v, 'id>, t<'k, 'v, 'id>), option<'v>)"
      },
      {
        "id": "Belt.Map.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'k, 'v, 'id>, 'v => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f) returns a map with same domain as`m`, where the associated\nvalue`a`of all bindings of`m`has been replaced by the result of the\napplication of`f`to`a`. The bindings are passed to`f` in increasing order\nwith respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'k, 'v, 'id>, 'v => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'k, 'v, 'id>, ('k, 'v) => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [
          "`mapWithKey(m, f)`\n\nThe same as `Belt.Map.map` except that `f` is supplied with one more\nargument: the key."
        ],
        "signature": "let mapWithKey: (t<'k, 'v, 'id>, ('k, 'v) => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.getData",
        "kind": "value",
        "name": "getData",
        "docstrings": [
          "`getData(s0)`\n\nAdvanced usage only\n\nReturns the raw data (detached from comparator), but its type is still\nmanifested, so that user can pass identity directly without boxing."
        ],
        "signature": "let getData: t<'k, 'v, 'id> => Belt_MapDict.t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.getId",
        "kind": "value",
        "name": "getId",
        "docstrings": [
          "Advanced usage only. Returns the identity of s0."
        ],
        "signature": "let getId: t<'k, 'v, 'id> => id<'k, 'id>"
      },
      {
        "id": "Belt.Map.packIdData",
        "kind": "value",
        "name": "packIdData",
        "docstrings": [
          "`packIdData(~id, ~data)`\n\nAdvanced usage only\n\nReturns the packed collection."
        ],
        "signature": "let packIdData: (\n  ~id: id<'k, 'id>,\n  ~data: Belt_MapDict.t<'k, 'v, 'id>,\n) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit"
      }
    ]
  },
  "belt/set": {
    "id": "Belt.Set",
    "name": "Set",
    "docstrings": [
      "[`Belt.Set`]()\n\n  The top level provides generic **immutable** set operations.\n\n  It also has three specialized inner modules\n  [`Belt.Set.Int`](), [`Belt.Set.String`]() and\n\n  [`Belt.Set.Dict`](): This module separates data from function\n  which is more verbose but slightly more efficient",
      "An _immutable_ sorted set module which allows customized _compare_ behavior.\n\nThe implementation uses balanced binary trees, and therefore searching\nand insertion take time logarithmic in the size of the map.\n\nFor more info on this module's usage of identity, `make` and others, please see\nthe top level documentation of Belt, **A special encoding for collection safety**.\n\n## Examples\n\n```rescript\nmodule PairComparator =\n  Belt.Id.MakeComparable({\n    type t = (int, int)\n    let cmp = ((a0, a1), (b0, b1)) =>\n      switch (Pervasives.compare(a0, b0)) {\n      | 0 => Pervasives.compare(a1, b1)\n      | c => c\n      }\n  })\n\nlet mySet = Belt.Set.make(~id=module(PairComparator))\nlet mySet2 = Belt.Set.add(mySet, (1, 2))\n```\n\n**Note:** This module's examples will assume a predeclared module for integers\ncalled `IntCmp`. It is declared like this:\n\n```rescript\nmodule IntCmp =\n  Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n```"
    ],
    "items": [
      {
        "id": "Belt.Set.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'value` is the element type\n\n`'identity` the identity of the collection"
        ],
        "signature": "type t<'value, 'identity>"
      },
      {
        "id": "Belt.Set.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making a set from scratch"
        ],
        "signature": "type id<'value, 'id> = Belt_Id.comparable<'value, 'id>"
      },
      {
        "id": "Belt.Set.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new set by taking in the comparator\n\n## Examples\n\n```rescript\nlet set = Belt.Set.make(~id=module(IntCmp))\n```"
        ],
        "signature": "let make: (~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new set from array of elements.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\ns0->Belt.Set.toArray /* [1, 2, 3, 4] */\n```"
        ],
        "signature": "let fromArray: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [
          "The same as [fromArray][#fromarray] except it is after assuming the input array\nis already sorted."
        ],
        "signature": "let fromSortedArrayUnsafe: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Checks if set is empty.\n\n## Examples\n\n```rescript\nlet empty = Belt.Set.fromArray([], ~id=module(IntCmp))\nlet notEmpty = Belt.Set.fromArray([1],~id=module(IntCmp))\n\nBelt.Set.isEmpty(empty) /* true */\nBelt.Set.isEmpty(notEmpty) /* false */\n```"
        ],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Set.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if element exists in set.\n\n## Examples\n\n```rescript\nlet set = Belt.Set.fromArray([1, 4, 2, 5], ~id=module(IntCmp))\n\nset->Belt.Set.has(3) /* false */\nset->Belt.Set.has(1) /* true */\n```"
        ],
        "signature": "let has: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.Set.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds element to set. If element existed in set, value is unchanged.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.make(~id=module(IntCmp))\nlet s1 = s0->Belt.Set.add(1)\nlet s2 = s1->Belt.Set.add(2)\nlet s3 = s2->Belt.Set.add(2)\ns0->Belt.Set.toArray /* [] */\ns1->Belt.Set.toArray /* [1] */\ns2->Belt.Set.toArray /* [1, 2] */\ns3->Belt.Set.toArray /* [1,2 ] */\ns2 == s3 /* true */\n```"
        ],
        "signature": "let add: (t<'value, 'id>, 'value) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "Adds each element of array to set. Unlike `Belt.Set.add`](#add), the reference of return value might be changed even if all values in array already exist in set\n\n## Examples\n\n```rescript\nlet set = Belt.Set.make(~id=module(IntCmp))\n\nlet newSet = set->Belt.Set.mergeMany([5, 4, 3, 2, 1])\nnewSet->Belt.Set.toArray /* [1, 2, 3, 4, 5] */\n```"
        ],
        "signature": "let mergeMany: (t<'value, 'id>, array<'value>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "Removes element from set. If element did not exist in set, value is unchanged.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([2,3,1,4,5], ~id=module(IntCmp))\nlet s1 = s0->Belt.Set.remove(1)\nlet s2 = s1->Belt.Set.remove(3)\nlet s3 = s2->Belt.Set.remove(3)\n\ns1->Belt.Set.toArray /* [2,3,4,5] */\ns2->Belt.Set.toArray /* [2,4,5] */\ns2 == s3 /* true */\n```"
        ],
        "signature": "let remove: (t<'value, 'id>, 'value) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "Removes each element of array from set. Unlike [remove](#remove), the reference of return value might be changed even if none of values in array existed in set.\n\n## Examples\n\n```rescript\nlet set = Belt.Set.fromArray([1, 2, 3, 4],~id=module(IntCmp))\n\nlet newSet = set->Belt.Set.removeMany([5, 4, 3, 2, 1])\nnewSet->Belt.Set.toArray /* [] */\n```"
        ],
        "signature": "let removeMany: (t<'value, 'id>, array<'value>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "Returns union of two sets.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\nlet union = Belt.Set.union(s0, s1)\nunion->Belt.Set.toArray /* [1,2,3,4,5,6] */\n```"
        ],
        "signature": "let union: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "Returns intersection of two sets.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\nlet intersect = Belt.Set.intersect(s0, s1)\nintersect->Belt.Set.toArray /* [2,3,5] */\n```"
        ],
        "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [
          "Returns elements from first set, not existing in second set.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\nBelt.Set.toArray(Belt.Set.diff(s0, s1)) /* [6] */\nBelt.Set.toArray(Belt.Set.diff(s1,s0)) /* [1,4] */\n```"
        ],
        "signature": "let diff: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "Checks if second set is subset of first set.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\nlet s2 = Belt.Set.intersect(s0, s1)\nBelt.Set.subset(s2, s0) /* true */\nBelt.Set.subset(s2, s1) /* true */\nBelt.Set.subset(s1, s0) /* false */\n```"
        ],
        "signature": "let subset: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets\nof sets. It compares size first and then iterates over each element following\nthe order of elements."
        ],
        "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>) => int"
      },
      {
        "id": "Belt.Set.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Checks if two sets are equal.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([5,2,3], ~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([3,2,5], ~id=module(IntCmp))\n\nBelt.Set.eq(s0, s1) /* true */\n```"
        ],
        "signature": "let eq: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as [forEach](#forEach) but takes uncurried functon."
        ],
        "signature": "let forEachU: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.Set.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Applies function `f` in turn to all elements of set in increasing order.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\nlet acc = ref(list{})\ns0->Belt.Set.forEach(x => {\n  acc := Belt.List.add(acc.contents, x)\n})\nacc /* [6,5,3,2] */\n```"
        ],
        "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.Set.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an accumulator, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\ns0->Belt.Set.reduce(list{}, (acc, element) =>\n  acc->Belt.List.add(element)\n) /* [6,5,3,2] */\n```"
        ],
        "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nlet s0 = Belt.Set.fromArray([2,4,6,8], ~id=module(IntCmp))\ns0->Belt.Set.every(isEven) /* true */\n```"
        ],
        "signature": "let every: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Checks if at least one element of the set satisfies the predicate.\n\n## Examples\n\n```rescript\nlet isOdd = x => mod(x, 2) != 0\n\nlet s0 = Belt.Set.fromArray([1,2,4,6,8], ~id=module(IntCmp))\ns0->Belt.Set.some(isOdd) /* true */\n```"
        ],
        "signature": "let some: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns the set of all elements that satisfy the predicate.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nlet s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\nlet s1 = s0->Belt.Set.keep(isEven)\n\ns1->Belt.Set.toArray /* [2,4] */\n```"
        ],
        "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (\n  t<'value, 'id>,\n  'value => bool,\n) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "Returns a pair of sets, where first is the set of all the elements of set that satisfy the predicate, and second is the set of all the elements of set that do not satisfy the predicate.\n\n## Examples\n\n```rescript\nlet isOdd = x => mod(x, 2) != 0\n\nlet s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\nlet (s1, s2) = s0->Belt.Set.partition(isOdd)\n\ns1->Belt.Set.toArray /* [1,3,5] */\ns2->Belt.Set.toArray /* [2,4] */\n```"
        ],
        "signature": "let partition: (\n  t<'value, 'id>,\n  'value => bool,\n) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns size of the set.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([1,2,3,4], ~id=module(IntCmp))\n\ns0->Belt.Set.size /* 4 */\n```"
        ],
        "signature": "let size: t<'value, 'id> => int"
      },
      {
        "id": "Belt.Set.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of ordered set elements.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\ns0->Belt.Set.toArray /* [1,2,3,5] */\n```"
        ],
        "signature": "let toArray: t<'value, 'id> => array<'value>"
      },
      {
        "id": "Belt.Set.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "Returns list of ordered set elements.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\ns0->Belt.Set.toList /* [1,2,3,5] */\n```"
        ],
        "signature": "let toList: t<'value, 'id> => list<'value>"
      },
      {
        "id": "Belt.Set.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "Returns minimum value of the collection. `None` if collection is empty.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.make(~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\ns0->Belt.Set.minimum /* None */\ns1->Belt.Set.minimum /* Some(1) */\n```"
        ],
        "signature": "let minimum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "Returns minimum value of the collection. `undefined` if collection is empty.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.make(~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\ns0->Belt.Set.minUndefined /* undefined */\ns1->Belt.Set.minUndefined /* 1 */\n```"
        ],
        "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "Returns maximum value of the collection. `None` if collection is empty.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.make(~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\ns0->Belt.Set.maximum /* None */\ns1->Belt.Set.maximum /* Some(5) */\n```"
        ],
        "signature": "let maximum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "Returns maximum value of the collection. `undefined` if collection is empty.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.make(~id=module(IntCmp))\nlet s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\ns0->Belt.Set.maxUndefined /* undefined */\ns1->Belt.Set.maxUndefined /* 5 */\n```"
        ],
        "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n\ns0->Belt.Set.get(3) /* Some(3) */\ns0->Belt.Set.get(20) /* None */\n```"
        ],
        "signature": "let get: (t<'value, 'id>, 'value) => option<'value>"
      },
      {
        "id": "Belt.Set.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "Same as [get](#get) but returns `undefined` when element does not exist."
        ],
        "signature": "let getUndefined: (t<'value, 'id>, 'value) => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as [get](#get) but raise when element does not exist."
        ],
        "signature": "let getExn: (t<'value, 'id>, 'value) => 'value"
      },
      {
        "id": "Belt.Set.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n## Examples\n\n```rescript\nlet s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n\nlet ((smaller, larger), present) = s0->Belt.Set.split(3)\n\npresent /* true */\nsmaller->Belt.Set.toArray /* [1,2] */\nlarger->Belt.Set.toArray /* [4,5] */\n\n```"
        ],
        "signature": "let split: (\n  t<'value, 'id>,\n  'value,\n) => ((t<'value, 'id>, t<'value, 'id>), bool)"
      },
      {
        "id": "Belt.Set.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b> => unit"
      },
      {
        "id": "Belt.Set.getData",
        "kind": "value",
        "name": "getData",
        "docstrings": [
          "**Advanced usage only**\n\nReturns the raw data (detached from comparator), but its type is still manifested,\nso that user can pass identity directly without boxing."
        ],
        "signature": "let getData: t<'value, 'id> => Belt_SetDict.t<'value, 'id>"
      },
      {
        "id": "Belt.Set.getId",
        "kind": "value",
        "name": "getId",
        "docstrings": [
          "**Advanced usage only**\n\nReturns the identity of set."
        ],
        "signature": "let getId: t<'value, 'id> => id<'value, 'id>"
      },
      {
        "id": "Belt.Set.packIdData",
        "kind": "value",
        "name": "packIdData",
        "docstrings": [
          "**Advanced usage only**\n\nReturns the packed collection."
        ],
        "signature": "let packIdData: (\n  ~id: id<'value, 'id>,\n  ~data: Belt_SetDict.t<'value, 'id>,\n) => t<'value, 'id>"
      }
    ]
  },
  "belt/range": {
    "id": "Belt.Range",
    "name": "Range",
    "docstrings": [
      "[`Belt.Range`]()\n\n  Utilities for a closed range `(from, start)`",
      "A small utility module to provide inclusive range operations for `[start, finish]`.\nInternally it is relying on loops instead of creating new arrays, which makes it\npretty performant and memory friendly."
    ],
    "items": [
      {
        "id": "Belt.Range.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (int, int, int => unit) => unit"
      },
      {
        "id": "Belt.Range.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(start, finish, action)` equivalent to `Belt.Array.forEach(Belt.Array.range(start, finish), action))`\n\n## Examples\n\n```rescript\nBelt.Range.forEach(0, 4, (i) => Js.log(i))\n\n// Prints:\n// 0\n// 1\n// 2\n// 3\n// 4\n```"
        ],
        "signature": "let forEach: (int, int, int => unit) => unit"
      },
      {
        "id": "Belt.Range.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (int, int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(start, finish, p)` equivalent to `Belt.Array.every(Belt.Array.range(start, finish), p)`\n## Examples\n\n```rescript\nBelt.Range.every(0, 4, (i) => i < 5) /* true */\n\nBelt.Range.every(0, 4, (i) => i < 4) /* false */\n```"
        ],
        "signature": "let every: (int, int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.everyByU",
        "kind": "value",
        "name": "everyByU",
        "docstrings": [],
        "signature": "let everyByU: (int, int, ~step: int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.everyBy",
        "kind": "value",
        "name": "everyBy",
        "docstrings": [
          "`everyBy(start, finish, ~step, p)`. See `Belt.Array.rangeBy`, equivalent to\n`Belt.Array.every(Belt.Array.rangeBy(start, finish, ~step), p)`\n\n## Examples\n\n```rescript\nBelt.Range.everyBy(0, 4, ~step=1, (i) => mod(i, 2) === 0) /* false */\n\nBelt.Range.everyBy(0, 4, ~step=2, (i) => mod(i, 2) === 0) /* true */\n```"
        ],
        "signature": "let everyBy: (int, int, ~step: int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (int, int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(start, finish, p)` equivalent to `Belt.Array.some(Belt.Array.range(start, finish), p)`\n\n## Examples\n\n```rescript\nBelt.Range.some(0, 4, (i) => i > 5) /* false */\n\nBelt.Range.some(0, 4, (i) => i > 2) /* true */\n```"
        ],
        "signature": "let some: (int, int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.someByU",
        "kind": "value",
        "name": "someByU",
        "docstrings": [],
        "signature": "let someByU: (int, int, ~step: int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.someBy",
        "kind": "value",
        "name": "someBy",
        "docstrings": [
          "`someBy(start, finish, ~step, p)` See `Belt.Array.rangeBy`, equivalent to\n`Belt.Array.some(Belt.Array.rangeBy(start, finish, ~step), p)`\n\n## Examples\n\n```rescript\nBelt.Range.someBy(1, 5, ~step=2, (i) => mod(i, 2) === 0) /* false */\nBelt.Range.someBy(0, 4, ~step=2, (i) => mod(i, 2) === 0) /* true */\n```"
        ],
        "signature": "let someBy: (int, int, ~step: int, int => bool) => bool"
      }
    ]
  },
  "belt/list": {
    "id": "Belt.List",
    "name": "List",
    "docstrings": [
      "[`Belt.List`]()\n\n  Utilities for List data type",
      "Collection functions for manipulating the `list` data structures, a singly-linked list.\n\n**Prefer Array** if you need any of the following:\n\n- Random access of element\n- Better interop with JavaScript\n- Better memory usage & performance."
    ],
    "items": [
      {
        "id": "Belt.List.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'a t` is compatible with built-in `list` type"
        ],
        "signature": "type t<'a> = list<'a>"
      },
      {
        "id": "Belt.List.length",
        "kind": "value",
        "name": "length",
        "docstrings": [
          "Returns the length of a list.\n\n## Examples\n\n```rescript\nBelt.List.length(list{1, 2, 3}) // 3\n```"
        ],
        "signature": "let length: t<'a> => int"
      },
      {
        "id": "Belt.List.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "See `Belt.List.length`"
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.List.head",
        "kind": "value",
        "name": "head",
        "docstrings": [
          "Returns `Some(value)` where `value` is the first element in the list, or\n`None` if `someList` is an empty list.\n\n## Examples\n\n```rescript\nBelt.List.head(list{}) // None\nBelt.List.head(list{1, 2, 3}) // Some(1)\n```"
        ],
        "signature": "let head: t<'a> => option<'a>"
      },
      {
        "id": "Belt.List.headExn",
        "kind": "value",
        "name": "headExn",
        "docstrings": [
          "Same as `Belt.List.head` but raises an exception if `someList` is empty. Use\nwith care.\n\n## Examples\n\n```rescript\nBelt.List.headExn(list{1, 2, 3}) // 1\n\nBelt.List.headExn(list{}) // Raises an Error\n```"
        ],
        "signature": "let headExn: t<'a> => 'a"
      },
      {
        "id": "Belt.List.tail",
        "kind": "value",
        "name": "tail",
        "docstrings": [
          "Returns `None` if `someList` is empty, otherwise it returns `Some(tail)`\nwhere `tail` is everything except the first element of `someList`.\n\n## Examples\n\n```rescript\nBelt.List.tail(list{1, 2, 3}) // Some(list{2, 3})\n\nBelt.List.tail(list{}) // None\n```"
        ],
        "signature": "let tail: t<'a> => option<t<'a>>"
      },
      {
        "id": "Belt.List.tailExn",
        "kind": "value",
        "name": "tailExn",
        "docstrings": [
          "Same as `Belt.List.tail` but raises an exception if `someList` is empty. Use\nwith care.\n\n## Examples\n\n```rescript\nBelt.List.tailExn(list{1, 2, 3}) // list{2, 3}\n\nBelt.List.tailExn(list{}) // Raises an Error\n```"
        ],
        "signature": "let tailExn: t<'a> => t<'a>"
      },
      {
        "id": "Belt.List.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds `value` to the beginning of `someList`.\n\n## Examples\n\n```rescript\nBelt.List.add(list{2, 3}, 1) // list{1, 2, 3}\n\nBelt.List.add(list{\"World\", \"!\"}, \"Hello\") // list{\"Hello\", \"World\", \"!\"}\n```"
        ],
        "signature": "let add: (t<'a>, 'a) => t<'a>"
      },
      {
        "id": "Belt.List.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Return the nth element in `someList`, or `None` if `index` is larger than the\nlength.\n\n## Examples\n\n```rescript\nlet abc = list{\"A\", \"B\", \"C\"}\n\nabc->Belt.List.get(1) // Some(\"B\")\n\nabc->Belt.List.get(4) // None\n```"
        ],
        "signature": "let get: (t<'a>, int) => option<'a>"
      },
      {
        "id": "Belt.List.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as `Belt.List.get` but raises an exception if `index` is larger than the\nlength. Use with care.\n\n## Examples\n\n```rescript\nlet abc = list{\"A\", \"B\", \"C\"}\n\nabc->Belt.List.getExn(1) // \"B\"\n\nabc->Belt.List.getExn(4) // Raises an Error\n```"
        ],
        "signature": "let getExn: (t<'a>, int) => 'a"
      },
      {
        "id": "Belt.List.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Returns a list of length `numItems` with each element filled with value `v`. Returns an empty list if `numItems` is negative.\n\n## Examples\n\n```rescript\nBelt.List.make(3, 1) // list{1, 1, 1}\n```"
        ],
        "signature": "let make: (int, 'a) => t<'a>"
      },
      {
        "id": "Belt.List.makeByU",
        "kind": "value",
        "name": "makeByU",
        "docstrings": [
          "Uncurried version of [makeBy](#makeBy)"
        ],
        "signature": "let makeByU: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.List.makeBy",
        "kind": "value",
        "name": "makeBy",
        "docstrings": [
          "Return a list of length `numItems` with element `i` initialized with `f(i)`.\nReturns an empty list if `numItems` is negative.\n\n## Examples\n\n```rescript\nBelt.List.makeBy(5, i => i) // list{0, 1, 2, 3, 4}\n\nBelt.List.makeBy(5, i => i * i) // list{0, 1, 4, 9, 16}\n```"
        ],
        "signature": "let makeBy: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.List.shuffle",
        "kind": "value",
        "name": "shuffle",
        "docstrings": [
          "Returns a new list in random order.\n\n## Examples\n\n```rescript\nBelt.List.shuffle(list{1, 2, 3}) // list{2, 1, 3}\n```"
        ],
        "signature": "let shuffle: t<'a> => t<'a>"
      },
      {
        "id": "Belt.List.drop",
        "kind": "value",
        "name": "drop",
        "docstrings": [
          "Return a new list, dropping the first `n` elements. Returns `None` if `someList` has fewer than `n` elements.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->Belt.List.drop(2) // Some(list{3})\n\nlist{1, 2, 3}->Belt.List.drop(3) // Some(list{})\n\nlist{1, 2, 3}->Belt.List.drop(4) // None\n```"
        ],
        "signature": "let drop: (t<'a>, int) => option<t<'a>>"
      },
      {
        "id": "Belt.List.take",
        "kind": "value",
        "name": "take",
        "docstrings": [
          "Returns a list with the first `n` elements from `someList`, or `None` if `someList` has fewer than `n` elements.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->Belt.List.take(1) // Some(list{1})\n\nlist{1, 2, 3}->Belt.List.take(2) // Some(list{1, 2})\n\nlist{1, 2, 3}->Belt.List.take(4) // None\n```"
        ],
        "signature": "let take: (t<'a>, int) => option<t<'a>>"
      },
      {
        "id": "Belt.List.splitAt",
        "kind": "value",
        "name": "splitAt",
        "docstrings": [
          "Split the list `someList` at `index`. Returns `None` when the length of `someList` is less than `index`.\n\n## Examples\n\n```rescript\nlist{\"Hello\", \"World\"}->Belt.List.splitAt(1) // Some((list{\"Hello\"}, list{\"World\"}))\n\nlist{0, 1, 2, 3, 4}->Belt.List.splitAt(2) // Some((list{0, 1}, list{2, 3, 4}))\n```"
        ],
        "signature": "let splitAt: (t<'a>, int) => option<(list<'a>, list<'a>)>"
      },
      {
        "id": "Belt.List.concat",
        "kind": "value",
        "name": "concat",
        "docstrings": [
          "Returns the list obtained by adding `secondList` after `firstList`.\n\n## Examples\n\n```rescript\nBelt.List.concat(list{1, 2, 3}, list{4, 5}) // list{1, 2, 3, 4, 5}\n```"
        ],
        "signature": "let concat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Belt.List.concatMany",
        "kind": "value",
        "name": "concatMany",
        "docstrings": [
          "Returns the list obtained by concatenating all the lists in array `a`, in\norder.\n\n## Examples\n\n```rescript\nBelt.List.concatMany([list{1, 2, 3}, list{}, list{3}]) // list{1, 2, 3, 3}\n```"
        ],
        "signature": "let concatMany: array<t<'a>> => t<'a>"
      },
      {
        "id": "Belt.List.reverseConcat",
        "kind": "value",
        "name": "reverseConcat",
        "docstrings": [
          "Equivalent to writing: `concat(reverse(firstList, secondList)`\n\n## Examples\n\n```rescript\nBelt.List.reverseConcat(list{1, 2}, list{3, 4}) // list{2, 1, 3, 4}\n```"
        ],
        "signature": "let reverseConcat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Belt.List.flatten",
        "kind": "value",
        "name": "flatten",
        "docstrings": [
          "Return the list obtained by concatenating all the lists in list `ls`, in order.\n\n## Examples\n\n```rescript\nBelt.List.flatten(list{list{1, 2, 3}, list{}, list{3}}) // list{1, 2, 3, 3}\n```"
        ],
        "signature": "let flatten: t<t<'a>> => t<'a>"
      },
      {
        "id": "Belt.List.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [
          "Uncurried version of [map](#map)."
        ],
        "signature": "let mapU: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "Returns a new list with `f` applied to each element of `someList`.\n\n## Examples\n\n```rescript\nlist{1, 2}->Belt.List.map(x => x + 1) // list{3, 4}\n```"
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.zip",
        "kind": "value",
        "name": "zip",
        "docstrings": [
          "Returns a list of pairs from the two lists with the length of the shorter list.\n\n## Examples\n\n```rescript\nBelt.List.zip(list{1, 2}, list{3, 4, 5}) // list{(1, 3), (2, 4)}\n```"
        ],
        "signature": "let zip: (t<'a>, t<'b>) => t<('a, 'b)>"
      },
      {
        "id": "Belt.List.zipByU",
        "kind": "value",
        "name": "zipByU",
        "docstrings": [
          "Uncurried version of [zipBy](#zipBy)."
        ],
        "signature": "let zipByU: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.zipBy",
        "kind": "value",
        "name": "zipBy",
        "docstrings": [
          "See [Belt.List.zip](#zip)\n\n## Examples\n\n```rescript\nBelt.List.zipBy(list{1, 2, 3}, list{4, 5}, (a, b) => 2 * a + b) // list{6, 9}\n```"
        ],
        "signature": "let zipBy: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.mapWithIndexU",
        "kind": "value",
        "name": "mapWithIndexU",
        "docstrings": [
          "Uncurried version of [mapWithIndex](#mapWithIndex)."
        ],
        "signature": "let mapWithIndexU: (t<'a>, (int, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.mapWithIndex",
        "kind": "value",
        "name": "mapWithIndex",
        "docstrings": [
          "Applies `f` to each element of `someList`.\nFunction `f` takes two arguments: the index starting from 0 and the element from `someList`, in that order.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->Belt.List.mapWithIndex((index, x) => index + x) // list{1, 3, 5}\n```"
        ],
        "signature": "let mapWithIndex: (t<'a>, (int, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Converts the given array to a list.\n\n## Examples\n\n```rescript\nBelt.List.fromArray([1, 2, 3]) // list{1, 2, 3}\n```"
        ],
        "signature": "let fromArray: array<'a> => t<'a>"
      },
      {
        "id": "Belt.List.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Converts the given list to an array.\n\n## Examples\n\n```rescript\nBelt.List.toArray(list{1, 2, 3}) // [1, 2, 3]\n```"
        ],
        "signature": "let toArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.List.reverse",
        "kind": "value",
        "name": "reverse",
        "docstrings": [
          "Returns a new list whose elements are those of `someList` in reversed order.\n\n## Examples\n\n```rescript\nBelt.List.reverse(list{1, 2, 3}) /* list{3, 2, 1} */\n```"
        ],
        "signature": "let reverse: t<'a> => t<'a>"
      },
      {
        "id": "Belt.List.mapReverseU",
        "kind": "value",
        "name": "mapReverseU",
        "docstrings": [
          "Uncurried version of [mapReverse](#mapReverse)."
        ],
        "signature": "let mapReverseU: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.mapReverse",
        "kind": "value",
        "name": "mapReverse",
        "docstrings": [
          "Equivalent to:\n\n```res\nmap(someList, f)->reverse\n```\n\n## Examples\n\n```rescript\nlist{3, 4, 5}->Belt.List.mapReverse(x => x * x) /* list{25, 16, 9} */\n```"
        ],
        "signature": "let mapReverse: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Uncurried version of [forEach](#forEach)."
        ],
        "signature": "let forEachU: (t<'a>, 'a => 'b) => unit"
      },
      {
        "id": "Belt.List.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Call `f` on each element of `someList` from the beginning to end.\n`f` returns `unit`, so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.\n\n## Examples\n\n```rescript\nBelt.List.forEach(list{\"a\", \"b\", \"c\"}, x => Js.log(\"Item: \" ++ x))\n/*\n  prints:\n  Item: a\n  Item: b\n  Item: c\n*/\n```"
        ],
        "signature": "let forEach: (t<'a>, 'a => 'b) => unit"
      },
      {
        "id": "Belt.List.forEachWithIndexU",
        "kind": "value",
        "name": "forEachWithIndexU",
        "docstrings": [
          "Uncurried version of [forEachWithIndex](#forEachWithIndex)."
        ],
        "signature": "let forEachWithIndexU: (t<'a>, (int, 'a) => 'b) => unit"
      },
      {
        "id": "Belt.List.forEachWithIndex",
        "kind": "value",
        "name": "forEachWithIndex",
        "docstrings": [
          "Call `f` on each element of `someList` from beginning to end.\nFunction `f` takes two arguments: the index starting from 0 and the element from `someList`. `f` returns `unit`.\n\n## Examples\n\n```rescript\nBelt.List.forEachWithIndex(list{\"a\", \"b\", \"c\"}, (index, x) => {\n  Js.log(\"Item \" ++ Belt.Int.toString(index) ++ \" is \" ++ x)\n})\n/*\n  prints:\n  Item 0 is a\n  Item 1 is b\n  Item 2 is cc\n*/\n```"
        ],
        "signature": "let forEachWithIndex: (t<'a>, (int, 'a) => 'b) => unit"
      },
      {
        "id": "Belt.List.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [
          "Uncurried version of [reduce](#reduce)."
        ],
        "signature": "let reduceU: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies `f` to each element of `someList` from beginning to end. Function `f` has two parameters: the item from the list and an accumulator, which starts with a value of `initialValue`. reduce returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->Belt.List.reduce(0, (a, b) => a + b) /* 10 */\n\n/* same as */\n\nlist{1, 2, 3, 4}->Belt.List.reduce(0, (acc, item) => acc + item) /* 10 */\n```"
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceWithIndexU",
        "kind": "value",
        "name": "reduceWithIndexU",
        "docstrings": [
          "Uncurried version of [reduceWithIndex](#reduceWithIndex)."
        ],
        "signature": "let reduceWithIndexU: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceWithIndex",
        "kind": "value",
        "name": "reduceWithIndex",
        "docstrings": [
          "Applies `f` to each element of `someList` from beginning to end. Function `f` has three parameters: the item from the list and an accumulator, which starts with a value of `initialValue` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->Belt.List.reduceWithIndex(0, (acc, item, index) => acc + item + index) /* 16 */\n```"
        ],
        "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceReverseU",
        "kind": "value",
        "name": "reduceReverseU",
        "docstrings": [
          "Uncurried version of [reduceReverse](#reduceReverse)."
        ],
        "signature": "let reduceReverseU: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceReverse",
        "kind": "value",
        "name": "reduceReverse",
        "docstrings": [
          "Works like [reduce](#reduce), except that function `f` is applied to each\nitem of `someList` from the last back to the first.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->Belt.List.reduceReverse(0, (a, b) => a + b) /* 10 */\n\nlist{1, 2, 3, 4}->Belt.List.reduceReverse(10, (a, b) => a - b) /* 0 */\n\nlist{1, 2, 3, 4}->Belt.List.reduceReverse(list{}, Belt.List.add) // list{1, 2, 3, 4}\n```"
        ],
        "signature": "let reduceReverse: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.mapReverse2U",
        "kind": "value",
        "name": "mapReverse2U",
        "docstrings": [
          "Uncurried version of [mapReverse2](#mapReverse2)."
        ],
        "signature": "let mapReverse2U: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.mapReverse2",
        "kind": "value",
        "name": "mapReverse2",
        "docstrings": [
          "Equivalent to: `zipBy(xs, ys, f)->reverse`\n\n## Examples\n\n```rescript\n\nBelt.List.mapReverse2(list{1, 2, 3}, list{1, 2}, (a, b) => a + b) // list{4, 2}\n```"
        ],
        "signature": "let mapReverse2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.forEach2U",
        "kind": "value",
        "name": "forEach2U",
        "docstrings": [
          "Uncurried version of [forEach2](#forEach2)."
        ],
        "signature": "let forEach2U: (t<'a>, t<'b>, ('a, 'b) => 'c) => unit"
      },
      {
        "id": "Belt.List.forEach2",
        "kind": "value",
        "name": "forEach2",
        "docstrings": [
          "Stops at the length of the shorter list.\n\n## Examples\n\n```rescript\nBelt.List.forEach2(list{\"Z\", \"Y\"}, list{\"A\", \"B\", \"C\"}, (x, y) => Js.log2(x, y))\n\n/*\n  prints:\n  \"Z\" \"A\"\n  \"Y\" \"B\"\n*/\n```"
        ],
        "signature": "let forEach2: (t<'a>, t<'b>, ('a, 'b) => 'c) => unit"
      },
      {
        "id": "Belt.List.reduce2U",
        "kind": "value",
        "name": "reduce2U",
        "docstrings": [
          "Uncurried version of [reduce2](#reduce2)."
        ],
        "signature": "let reduce2U: (t<'b>, t<'c>, 'a, ('a, 'b, 'c) => 'a) => 'a"
      },
      {
        "id": "Belt.List.reduce2",
        "kind": "value",
        "name": "reduce2",
        "docstrings": [
          "Applies `f` to each element of `firstList` and `secondList` from beginning to end. Stops with the shorter list. Function `f` has three parameters: an accumulator which starts with a value of `initialValue`, an item from `firstList`, and an item from `secondList`. `reduce2` returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nBelt.List.reduce2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) /* 0 + (1 * 1 + 4) + (2 * 2 + 5) */\n```"
        ],
        "signature": "let reduce2: (t<'b>, t<'c>, 'a, ('a, 'b, 'c) => 'a) => 'a"
      },
      {
        "id": "Belt.List.reduceReverse2U",
        "kind": "value",
        "name": "reduceReverse2U",
        "docstrings": [
          "Uncurried version of [reduceReverse2](#reduceReverse2)."
        ],
        "signature": "let reduceReverse2U: (t<'a>, t<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.List.reduceReverse2",
        "kind": "value",
        "name": "reduceReverse2",
        "docstrings": [
          "Applies `f` to each element of `firstList` and `secondList` from end to\nbeginning. Stops with the shorter list. Function `f` has three parameters: an\naccumulator which starts with a value of init, an item from `firstList`,\nand an item from `secondList`. `reduce2` returns the final value of the\naccumulator.\n\n## Examples\n\n```rescript\nBelt.List.reduceReverse2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) /*  + (1 * 1 + 4) + (2 * 2 + 5) */\n```"
        ],
        "signature": "let reduceReverse2: (t<'a>, t<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.List.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [
          "Uncurried version of [every](#every)."
        ],
        "signature": "let everyU: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.List.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Returns `true` if all elements satisfy `pred`, where `pred` is a predicate: a function taking an element and returning a bool.\n\n## Examples\n\n```rescript\nlet isBelow10 = value => value < 10\n\nlist{1, 9, 8, 2}->Belt.List.every(isBelow10) /* true */\n\nlist{1, 99, 8, 2}->Belt.List.every(isBelow10) /* false */\n```"
        ],
        "signature": "let every: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.List.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [
          "Uncurried version of [some](#some)."
        ],
        "signature": "let someU: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.List.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Returns `true` if at least _one_ of the elements in `someList` satisfies\n`pred`, where `pred` is a predicate: a function taking an element and\nreturning a bool.\n\n## Examples\n\n```rescript\nlet isAbove100 = value => value > 100\n\nlist{101, 1, 2, 3}->Belt.List.some(isAbove100) /* true */\n\nlist{1, 2, 3, 4}->Belt.List.some(isAbove100) /* false */\n```"
        ],
        "signature": "let some: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.List.every2U",
        "kind": "value",
        "name": "every2U",
        "docstrings": [
          "Uncurried version of [every2](#every2)."
        ],
        "signature": "let every2U: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.every2",
        "kind": "value",
        "name": "every2",
        "docstrings": [
          "Returns `true` if predicate `pred(a, b)` is `true` for all pairs of elements\nup to the shorter length (i.e. `min(length(firstList), length(secondList))`)\n\n## Examples\n\n```rescript\nBelt.List.every2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) /* true */\n\nBelt.List.every2(list{}, list{1}, (a, b) => a > b) /* true */\n\nBelt.List.every2(list{2, 3}, list{1}, (a, b) => a > b) /* true */\n\nBelt.List.every2(list{0, 1}, list{5, 0}, (a, b) => a > b) /* false */\n```"
        ],
        "signature": "let every2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.some2U",
        "kind": "value",
        "name": "some2U",
        "docstrings": [
          "Uncurried version of [some2](#some2)."
        ],
        "signature": "let some2U: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.some2",
        "kind": "value",
        "name": "some2",
        "docstrings": [
          "Returns `true` if predicate `pred(a, b)` is true for any pair of elements up\nto the shorter length (i.e. `min(length(firstList), length(secondList))`)\n\n## Examples\n\n```rescript\nBelt.List.some2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) /* true */\n\nBelt.List.some2(list{}, list{1}, (a, b) => a > b) /* false */\n\nBelt.List.some2(list{2, 3}, list{1}, (a, b) => a > b) /* true */\n\nBelt.List.some2(list{0, 1}, list{5, 0}, (a, b) => a > b) /* true */\n```"
        ],
        "signature": "let some2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.cmpByLength",
        "kind": "value",
        "name": "cmpByLength",
        "docstrings": [
          "Compare two lists solely by length. Returns `-1` if `length(firstList)` is\nless than `length(secondList)`, `0` if `length(firstList)` equals\n`length(secondList)`, and `1` if `length(firstList)` is greater than\n`length(secondList)`.\n\n## Examples\n\n```rescript\nBelt.List.cmpByLength(list{1, 2}, list{3, 4, 5, 6}) /* -1 */\n\nBelt.List.cmpByLength(list{1, 2, 3}, list{4, 5, 6}) /* = 0 */\n\nBelt.List.cmpByLength(list{1, 2, 3, 4}, list{5, 6}) /* = 1 */\n```"
        ],
        "signature": "let cmpByLength: (t<'a>, t<'a>) => int"
      },
      {
        "id": "Belt.List.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [
          "Uncurried version of [cmp](#cmp)."
        ],
        "signature": "let cmpU: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.List.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Compare elements one by one `compareFn(a, b)`. `compareFn` returns a negative number if `a` is \"less than\" `b`, zero if `a` is \"equal to\" `b`, a positive number if `a` is \"greater than\" `b`.\n\nThe comparison returns the first non-zero result of `compareFn`, or zero if `compareFn` returns zero for all `a` and `b`.\n\nIf all items have compared equal, but `firstList` is exhausted first, return `-1`. (`firstList` is shorter).\nIf all items have compared equal, but `secondList` is exhausted first, return `1` (`firstList` is longer).\n\n## Examples\n\n```rescript\nBelt.List.cmp(list{3}, list{3, 7}, (a, b) => compare(a, b)) /* (-1) */\n\nBelt.List.cmp(list{5, 3}, list{5}, (a, b) => compare(a, b)) /* 1 */\n\nBelt.List.cmp(list{1, 3, 5}, list{1, 4, 2}, (a, b) => compare(a, b)) /* (-1) */\n\nBelt.List.cmp(list{1, 3, 5}, list{1, 2, 3}, (a, b) => compare(a, b)) /* 1 */\n\nBelt.List.cmp(list{1, 3, 5}, list{1, 3, 5}, (a, b) => compare(a, b)) /* 0 */\n```\n\n**Please note:** The total ordering of List is different from Array,\nfor Array, we compare the length first and, only if the lengths are equal, elements one by one.\nFor lists, we just compare elements one by one."
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.List.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [
          "Uncurried version of [eq](#eq)."
        ],
        "signature": "let eqU: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.List.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Check equality of `firstList` and `secondList` using `eqElem` for equality on\nelements, where `eqElem` is a function that returns `true` if items `x` and\n`y` meet some criterion for equality, `false` otherwise. eq `false` if length\nof `firstList` and `secondList` are not the same.\n\n## Examples\n\n```rescript\nBelt.List.eq(list{1, 2, 3}, list{1, 2}, (a, b) => a == b) /* false */\n\nBelt.List.eq(list{1, 2}, list{1, 2}, (a, b) => a == b) /* true */\n\nBelt.List.eq(list{1, 2, 3}, list{(-1), (-2), (-3)}, (a, b) => abs(a) == abs(b)) /* true */\n```"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.List.hasU",
        "kind": "value",
        "name": "hasU",
        "docstrings": [
          "Uncurried version of [has](#has)."
        ],
        "signature": "let hasU: (t<'a>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Returns `true` if the list contains at least one element for which\n`eqFunction(x)` returns true.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->Belt.List.has(2, (a, b) => a == b) /* true */\n\nlist{1, 2, 3}->Belt.List.has(4, (a, b) => a == b) /* false */\n\nlist{(-1), (-2), (-3)}->Belt.List.has(2, (a, b) => abs(a) == abs(b)) /* true */\n```"
        ],
        "signature": "let has: (t<'a>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.getByU",
        "kind": "value",
        "name": "getByU",
        "docstrings": [
          "Uncurried version of [getBy](#getBy)."
        ],
        "signature": "let getByU: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.List.getBy",
        "kind": "value",
        "name": "getBy",
        "docstrings": [
          "Returns `Some(value)` for the first value in `someList` that satisfies the\npredicate function `pred`. Returns `None` if no element satisfies the function.\n\n## Examples\n\n```rescript\nBelt.List.getBy(list{1, 4, 3, 2}, x => x > 3) /* Some(4) */\n\nBelt.List.getBy(list{1, 4, 3, 2}, x => x > 4) /* None */\n```"
        ],
        "signature": "let getBy: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.List.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [
          "Uncurried version of [keep](#keep)."
        ],
        "signature": "let keepU: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Belt.List.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nBelt.List.keep(list{1, 2, 3, 4}, isEven) /* list{2, 4} */\n\nBelt.List.keep(list{None, Some(2), Some(3), None}, Belt.Option.isSome) /* list{Some(2), Some(3)} */\n```"
        ],
        "signature": "let keep: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Belt.List.filter",
        "kind": "value",
        "name": "filter",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nBelt.List.filter(list{1, 2, 3, 4}, isEven) /* list{2, 4} */\n\nBelt.List.filter(list{None, Some(2), Some(3), None}, Belt.Option.isSome) /* list{Some(2), Some(3)} */\n```"
        ],
        "signature": "let filter: (t<'a>, 'a => bool) => t<'a>",
        "deprecated": "This function will soon be deprecated. Please, use `List.keep` instead."
      },
      {
        "id": "Belt.List.keepWithIndexU",
        "kind": "value",
        "name": "keepWithIndexU",
        "docstrings": [
          "Uncurried version of [keepWithIndex](#keepWithIndex)."
        ],
        "signature": "let keepWithIndexU: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.List.keepWithIndex",
        "kind": "value",
        "name": "keepWithIndex",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nBelt.List.keepWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) /* list{1, 3} */\n```"
        ],
        "signature": "let keepWithIndex: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.List.filterWithIndex",
        "kind": "value",
        "name": "filterWithIndex",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nBelt.List.filterWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) /* list{1, 3} */\n```"
        ],
        "signature": "let filterWithIndex: (t<'a>, ('a, int) => bool) => t<'a>",
        "deprecated": "This function will soon be deprecated. Please, use `List.keepWithIndex` \\\n     instead."
      },
      {
        "id": "Belt.List.keepMapU",
        "kind": "value",
        "name": "keepMapU",
        "docstrings": [
          "Uncurried version of [keepMap](#keepMap)."
        ],
        "signature": "let keepMapU: (t<'a>, 'a => option<'b>) => t<'b>"
      },
      {
        "id": "Belt.List.keepMap",
        "kind": "value",
        "name": "keepMap",
        "docstrings": [
          "Applies `f` to each element of `someList`. If `f(x)` returns `Some(value)`, then `value` is _kept_ in the resulting list.\nIf `f(x)` returns `None`, the element is _not_ retained in the result.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nlist{1, 2, 3, 4}\n->Belt.List.keepMap(x =>\n    if (isEven(x)) {\n      Some(x)\n    } else {\n      None\n    }\n  ) /* list{2, 4} */\n\nlist{Some(1), Some(2), None}->Belt.List.keepMap(x => x) /* list{1, 2} */\n```"
        ],
        "signature": "let keepMap: (t<'a>, 'a => option<'b>) => t<'b>"
      },
      {
        "id": "Belt.List.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [
          "Uncurried version of [partition](#partition)."
        ],
        "signature": "let partitionU: (t<'a>, 'a => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.List.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "Creates a pair of lists; the first list consists of all elements of `someList` that satisfy the predicate function `pred`; the second list consists of all elements of `someList` that _do not_ satisfy `pred.\n\nIn other words:\n\n```rescript\n(elementsThatSatisfies, elementsThatDoesNotSatisfy)\n```\n\n## Examples\n\n```rescript\nBelt.List.partition(list{1, 2, 3, 4}, x => x > 2) /* (list{3, 4}, list{1, 2}) */\n```"
        ],
        "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.List.unzip",
        "kind": "value",
        "name": "unzip",
        "docstrings": [
          "Takes a list of pairs and creates a pair of lists. The first list contains all the first items of the pairs; the second list contains all the second items.\n\n## Examples\n\n```rescript\nBelt.List.unzip(list{(1, 2), (3, 4)}) /* (list{1, 3}, list{2, 4}) */\n\nBelt.List.unzip(list{(\"H\", \"W\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"l\", \"l\"), (\"o\", \"d\"), (\" \", \"!\")})\n/* (list{\"H\", \"e\", \"l\", \"l\", \"o\", \" \"}, list{\"W\", \"o\", \"r\", \"l\", \"d\", \"!\"}) */\n```"
        ],
        "signature": "let unzip: t<('a, 'b)> => (t<'a>, t<'b>)"
      },
      {
        "id": "Belt.List.getAssocU",
        "kind": "value",
        "name": "getAssocU",
        "docstrings": [
          "Uncurried version of [getAssoc](#getAssoc)."
        ],
        "signature": "let getAssocU: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => option<'c>"
      },
      {
        "id": "Belt.List.getAssoc",
        "kind": "value",
        "name": "getAssoc",
        "docstrings": [
          "Return the second element of a pair in `someList` where the first element equals `k` as per the predicate function `eqFunction`, or `None` if not found.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.getAssoc(3, (a, b) => a == b) /* Some(\"c\") */\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->Belt.List.getAssoc(15, (k, item) => k /* 15 */ == item /* 9, 5, 22 */)\n/* Some(\"afternoon\") */\n```"
        ],
        "signature": "let getAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => option<'c>"
      },
      {
        "id": "Belt.List.hasAssocU",
        "kind": "value",
        "name": "hasAssocU",
        "docstrings": [
          "Uncurried version of [hasAssoc](#hasAssoc)."
        ],
        "signature": "let hasAssocU: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.hasAssoc",
        "kind": "value",
        "name": "hasAssoc",
        "docstrings": [
          "Returns `true` if there is a pair in `someList` where the first element equals `k` as per the predicate function `eqFunction`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.hasAssoc(1, (a, b) => a == b) /* true */\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->Belt.List.hasAssoc(25, (k, item) => k /* 25 */ == item /* 9, 5, 22 */) /* false */\n```"
        ],
        "signature": "let hasAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.removeAssocU",
        "kind": "value",
        "name": "removeAssocU",
        "docstrings": [
          "Uncurried version of [removeAssoc](#removeAssoc)."
        ],
        "signature": "let removeAssocU: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.removeAssoc",
        "kind": "value",
        "name": "removeAssoc",
        "docstrings": [
          "Return a list after removing the first pair whose first value is `k` per the equality predicate `eqFunction`; if not found, return a new list identical to `someList`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.removeAssoc(1, (a, b) => a == b) /* list{(2, \"b\"), (3, \"c\")} */\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->Belt.List.removeAssoc(9, (k, item) => k /* 9 */ == item /* 9, 5, 22 */)\n/* list{(15, \"afternoon\"), (22, \"night\")} */\n```"
        ],
        "signature": "let removeAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.setAssocU",
        "kind": "value",
        "name": "setAssocU",
        "docstrings": [
          "Uncurried version of [setAssoc](#setAssoc)."
        ],
        "signature": "let setAssocU: (t<('a, 'c)>, 'a, 'c, ('a, 'a) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.setAssoc",
        "kind": "value",
        "name": "setAssoc",
        "docstrings": [
          "If `k` exists in `someList` by satisfying the `eqFunction` predicate, return a new list with the key and value replaced by the new `k` and `v`; otherwise, return a new list with the pair `k`, `v` added to the head of `someList`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.setAssoc(2, \"x\", (a, b) => a == b) /* list{(1, \"a\"), (2, \"x\"), (3, \"c\")} */\n\nlist{(1, \"a\"), (3, \"c\")}->Belt.List.setAssoc(2, \"b\", (a, b) => a == b) /* list{(2, \"b\"), (1, \"a\"), (3, \"c\")} */\n\nlist{(9, \"morning\"), (3, \"morning?!\"), (22, \"night\")}\n->Belt.List.setAssoc(15, \"afternoon\", (a, b) => mod(a, 12) == mod(b, 12))\n/* list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")} */\n```\n\n**Please note**\n\nIn the last example, since: `15 mod 12` equals `3 mod 12`\n\nBoth the key _and_ the value are replaced in the list."
        ],
        "signature": "let setAssoc: (t<('a, 'c)>, 'a, 'c, ('a, 'a) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.sortU",
        "kind": "value",
        "name": "sortU",
        "docstrings": [
          "Uncurried version of [sort](#sort)."
        ],
        "signature": "let sortU: (t<'a>, ('a, 'a) => int) => t<'a>"
      },
      {
        "id": "Belt.List.sort",
        "kind": "value",
        "name": "sort",
        "docstrings": [
          "Returns a sorted list.\n\n## Examples\n\n```rescript\nBelt.List.sort(list{5, 4, 9, 3, 7}, (a, b) => a - b) // list{3, 4, 5, 7, 9}\n```"
        ],
        "signature": "let sort: (t<'a>, ('a, 'a) => int) => t<'a>"
      }
    ]
  },
  "belt/mutablestack": {
    "id": "Belt.MutableStack",
    "name": "MutableStack",
    "docstrings": [
      "[`Belt.MutableStack`]()\n\n  An FILO(first in last out) stack data structure",
      "First in last out stack. This module implements stacks, with in-place\nmodification."
    ],
    "items": [
      {
        "id": "Belt.MutableStack.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableStack.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Returns a new stack, initially empty."
        ],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableStack.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Discard all elements from the stack."
        ],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableStack.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(x)` O(1) operation, return a new stack."
        ],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.MutableStack.push",
        "kind": "value",
        "name": "push",
        "docstrings": [],
        "signature": "let push: (t<'a>, 'a) => unit"
      },
      {
        "id": "Belt.MutableStack.popUndefined",
        "kind": "value",
        "name": "popUndefined",
        "docstrings": [],
        "signature": "let popUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableStack.pop",
        "kind": "value",
        "name": "pop",
        "docstrings": [],
        "signature": "let pop: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableStack.topUndefined",
        "kind": "value",
        "name": "topUndefined",
        "docstrings": [],
        "signature": "let topUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableStack.top",
        "kind": "value",
        "name": "top",
        "docstrings": [],
        "signature": "let top: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableStack.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableStack.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableStack.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.MutableStack.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.MutableStack.dynamicPopIterU",
        "kind": "value",
        "name": "dynamicPopIterU",
        "docstrings": [],
        "signature": "let dynamicPopIterU: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.MutableStack.dynamicPopIter",
        "kind": "value",
        "name": "dynamicPopIter",
        "docstrings": [
          "`dynamicPopIter(s, f)` apply `f` to each element of `s`. The item is poped\nbefore applying `f`, `s` will be empty after this opeartion. This function is\nuseful for worklist algorithm."
        ],
        "signature": "let dynamicPopIter: (t<'a>, 'a => unit) => unit"
      }
    ]
  },
  "belt/mutablequeue": {
    "id": "Belt.MutableQueue",
    "name": "MutableQueue",
    "docstrings": [
      "[`Belt.MutableQueue`]()\n\n  An FIFO(first in first out) queue data structure",
      "A FIFO (first in first out) queue data structure."
    ],
    "items": [
      {
        "id": "Belt.MutableQueue.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of queues containing elements of `type('a)`."
        ],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableQueue.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Returns a new queue, initially empty."
        ],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableQueue.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Discard all elements from the queue."
        ],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableQueue.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Returns `true` if the given queue is empty, `false` otherwise."
        ],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableQueue.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` a is equivalent to `Array.forEach(a, add(q, a));`"
        ],
        "signature": "let fromArray: array<'a> => t<'a>"
      },
      {
        "id": "Belt.MutableQueue.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "`add(q, x)` adds the element `x` at the end of the queue `q`."
        ],
        "signature": "let add: (t<'a>, 'a) => unit"
      },
      {
        "id": "Belt.MutableQueue.peek",
        "kind": "value",
        "name": "peek",
        "docstrings": [
          "`peekOpt(q)` returns the first element in queue `q`, without removing it from the queue."
        ],
        "signature": "let peek: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableQueue.peekUndefined",
        "kind": "value",
        "name": "peekUndefined",
        "docstrings": [
          "`peekUndefined(q)` returns `undefined` if not found."
        ],
        "signature": "let peekUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableQueue.peekExn",
        "kind": "value",
        "name": "peekExn",
        "docstrings": [
          "raise an exception if `q` is empty"
        ],
        "signature": "let peekExn: t<'a> => 'a"
      },
      {
        "id": "Belt.MutableQueue.pop",
        "kind": "value",
        "name": "pop",
        "docstrings": [
          "`pop(q)` removes and returns the first element in queue `q`."
        ],
        "signature": "let pop: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableQueue.popUndefined",
        "kind": "value",
        "name": "popUndefined",
        "docstrings": [
          "`popUndefined(q)` removes and returns the first element in queue `q`. it will\nreturn `undefined` if it is already empty."
        ],
        "signature": "let popUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableQueue.popExn",
        "kind": "value",
        "name": "popExn",
        "docstrings": [
          "`popExn(q)` raise an exception if q is empty."
        ],
        "signature": "let popExn: t<'a> => 'a"
      },
      {
        "id": "Belt.MutableQueue.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(q)` returns a fresh queue."
        ],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.MutableQueue.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns the number of elements in a queue."
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableQueue.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableQueue.map",
        "kind": "value",
        "name": "map",
        "docstrings": [],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableQueue.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.MutableQueue.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(q, f) applies`f`in turn to all elements of`q`, from the least\nrecently entered to the most recently entered. The queue itself is unchanged."
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.MutableQueue.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableQueue.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(q, accu, f)` is equivalent to `List.reduce(l, accu, f)`, where `l` is the\nlist of `q`'s elements. The queue remains unchanged."
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableQueue.transfer",
        "kind": "value",
        "name": "transfer",
        "docstrings": [
          "`transfer(q1, q2)` adds all of `q1`'s elements at the end of the queue `q2`,\nthen clears `q1`. It is equivalent to the sequence `forEach((x) => add(x, q2), q1)`;\nclear `q1`, but runs in constant time."
        ],
        "signature": "let transfer: (t<'a>, t<'a>) => unit"
      },
      {
        "id": "Belt.MutableQueue.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "First added will be in the beginning of the array."
        ],
        "signature": "let toArray: t<'a> => array<'a>"
      }
    ]
  },
  "belt/sortarray": {
    "id": "Belt.SortArray",
    "name": "SortArray",
    "docstrings": [
      "[`Belt.SortArray`]()\n\n  The top level provides some generic sort related utilities.\n\n  It also has two specialized inner modules\n  [`Belt.SortArray.Int`]() and [`Belt.SortArray.String`]()",
      "A module for Array sort relevant utiliites"
    ],
    "items": [
      {
        "id": "Belt.SortArray.strictlySortedLengthU",
        "kind": "value",
        "name": "strictlySortedLengthU",
        "docstrings": [],
        "signature": "let strictlySortedLengthU: (array<'a>, ('a, 'a) => bool) => int"
      },
      {
        "id": "Belt.SortArray.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "docstrings": [
          "`strictlySortedLenght(xs, cmp);` return `+n` means increasing order `-n` means negative order\n\n## Examples\n\n```rescript\nBelt.SortArray.strictlySortedLength([1, 2, 3, 4, 3], (x, y) => x < y) == 4\n\nBelt.SortArray.strictlySortedLength([], (x, y) => x < y) == 0\n\nBelt.SortArray.strictlySortedLength([1], (x, y) => x < y) == 1\n\nBelt.SortArray.strictlySortedLength([4, 3, 2, 1], (x, y) => x < y) == -4\n```"
        ],
        "signature": "let strictlySortedLength: (array<'a>, ('a, 'a) => bool) => int"
      },
      {
        "id": "Belt.SortArray.isSortedU",
        "kind": "value",
        "name": "isSortedU",
        "docstrings": [],
        "signature": "let isSortedU: (array<'a>, ('a, 'a) => int) => bool"
      },
      {
        "id": "Belt.SortArray.isSorted",
        "kind": "value",
        "name": "isSorted",
        "docstrings": [
          "`isSorted(arr, cmp)`: Returns true if array is increasingly sorted (equal is okay)"
        ],
        "signature": "let isSorted: (array<'a>, ('a, 'a) => int) => bool"
      },
      {
        "id": "Belt.SortArray.stableSortInPlaceByU",
        "kind": "value",
        "name": "stableSortInPlaceByU",
        "docstrings": [],
        "signature": "let stableSortInPlaceByU: (array<'a>, ('a, 'a) => int) => unit"
      },
      {
        "id": "Belt.SortArray.stableSortInPlaceBy",
        "kind": "value",
        "name": "stableSortInPlaceBy",
        "docstrings": [],
        "signature": "let stableSortInPlaceBy: (array<'a>, ('a, 'a) => int) => unit"
      },
      {
        "id": "Belt.SortArray.stableSortByU",
        "kind": "value",
        "name": "stableSortByU",
        "docstrings": [],
        "signature": "let stableSortByU: (array<'a>, ('a, 'a) => int) => array<'a>"
      },
      {
        "id": "Belt.SortArray.stableSortBy",
        "kind": "value",
        "name": "stableSortBy",
        "docstrings": [
          "`stableSortBy(xs, cmp)`: Returns a fresh array Sort `xs` in place using\ncomparator `cmp`, the stable means if the elements are equal, their order will\nbe preserved"
        ],
        "signature": "let stableSortBy: (array<'a>, ('a, 'a) => int) => array<'a>"
      },
      {
        "id": "Belt.SortArray.binarySearchByU",
        "kind": "value",
        "name": "binarySearchByU",
        "docstrings": [],
        "signature": "let binarySearchByU: (array<'a>, 'a, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.binarySearchBy",
        "kind": "value",
        "name": "binarySearchBy",
        "docstrings": [
          "If value is not found and value is less than one or more elements in array, the\nnegative number returned is the bitwise complement of the index of the first\nelement that is larger than value.\n\nIf value is not found and value is greater\nthan all elements in array, the negative number returned is the bitwise\ncomplement of (the index of the last element plus 1)for example, if `key` is\nsmaller than all elements return `-1` since `lnot(-1) == 0` if `key` is larger\nthan all elements return `lnot(-1) == 0` since `lnot(- (len + 1)) == len`\n\n## Examples\n\n```rescript\nBelt.SortArray.binarySearchBy([1, 2, 3, 4, 33, 35, 36], 33, Pervasives.compare) == 4\n\nlnot(Belt.SortArray.binarySearchBy([1, 3, 5, 7], 4, Pervasives.compare)) == 2\n```"
        ],
        "signature": "let binarySearchBy: (array<'a>, 'a, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.unionU",
        "kind": "value",
        "name": "unionU",
        "docstrings": [],
        "signature": "let unionU: (\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  ('a, 'a) => int,\n) => int"
      },
      {
        "id": "Belt.SortArray.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp` assume `src` and\n`src2` is strictly sorted. for equivalent elements, it is picked from `src`\nalso assume that `dst` is large enough to store all elements"
        ],
        "signature": "let union: (\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  ('a, 'a) => int,\n) => int"
      },
      {
        "id": "Belt.SortArray.intersectU",
        "kind": "value",
        "name": "intersectU",
        "docstrings": [],
        "signature": "let intersectU: (\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  ('a, 'a) => int,\n) => int"
      },
      {
        "id": "Belt.SortArray.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n\n**return** the `offset` in the output array"
        ],
        "signature": "let intersect: (\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  ('a, 'a) => int,\n) => int"
      },
      {
        "id": "Belt.SortArray.diffU",
        "kind": "value",
        "name": "diffU",
        "docstrings": [],
        "signature": "let diffU: (\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  ('a, 'a) => int,\n) => int"
      },
      {
        "id": "Belt.SortArray.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  int,\n  array<'a>,\n  int,\n  ('a, 'a) => int,\n) => int"
      }
    ]
  },
  "belt/array": {
    "id": "Belt.Array",
    "name": "Array",
    "docstrings": [
      "[`Belt.Array`]()\n\n  **mutable array**: Utilities functions",
      "Utilities for `Array` functions.\n\n### Note about index syntax\n\nCode like `arr[0]` does *not* compile to JavaScript `arr[0]`. Reason transforms\nthe `[]` index syntax into a function: `Array.get(arr, 0)`. By default, this\nuses the default standard library's `Array.get` function, which may raise an\nexception if the index isn't found. If you `open Belt`, it will use the\n`Belt.Array.get` function which returns options instead of raising exceptions. \n[See this for more information](../belt.mdx#array-access-runtime-safety)."
    ],
    "items": [
      {
        "id": "Belt.Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a> = array<'a>"
      },
      {
        "id": "Belt.Array.length",
        "kind": "value",
        "name": "length",
        "docstrings": [
          "Return the size of the array\n\n## Examples\n\n```rescript\n// Returns 1\nBelt.Array.length([\"test\"])\n```"
        ],
        "signature": "let length: t<'a> => int"
      },
      {
        "id": "Belt.Array.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "See [`Belt.Array.length`]()"
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.Array.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "If `i <= 0 <= length(arr)` returns `Some(value)` where `value` is the item at index `i`.\nIf `i` is out of range returns `None`.\n\n## Examples\n\n```rescript\nBelt.Array.get([\"a\", \"b\", \"c\"], 0) == Some(\"a\")\nBelt.Array.get([\"a\", \"b\", \"c\"], 3) == None\nBelt.Array.get([\"a\", \"b\", \"c\"], -1) == None\n```"
        ],
        "signature": "let get: (t<'a>, int) => option<'a>"
      },
      {
        "id": "Belt.Array.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Raise an exception if `i` is out of range.\nOtherwise return the value at index `i` in `arr`."
        ],
        "signature": "let getExn: (t<'a>, int) => 'a"
      },
      {
        "id": "Belt.Array.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(arr, i)`\n\n**Unsafe**\n\nno bounds checking; this would cause type error if `i` does not stay within range"
        ],
        "signature": "let getUnsafe: (t<'a>, int) => 'a"
      },
      {
        "id": "Belt.Array.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "`getUndefined(arr, i)`\n\nIt does the samething in the runtime as [`getUnsafe`]();\nit is _type safe_ since the return type still track whether it is\nin range or not"
        ],
        "signature": "let getUndefined: (t<'a>, int) => Js.undefined<'a>"
      },
      {
        "id": "Belt.Array.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(arr, n, x)` modifies `arr` in place; it replaces the nth element of `arr`\nwith `x`. Returning `false` means not updated due to out of range."
        ],
        "signature": "let set: (t<'a>, int, 'a) => bool"
      },
      {
        "id": "Belt.Array.setExn",
        "kind": "value",
        "name": "setExn",
        "docstrings": [
          "`setExn(arr, i, x)` raise an exception if `i` is out of range."
        ],
        "signature": "let setExn: (t<'a>, int, 'a) => unit"
      },
      {
        "id": "Belt.Array.setUnsafe",
        "kind": "value",
        "name": "setUnsafe",
        "docstrings": [],
        "signature": "let setUnsafe: (t<'a>, int, 'a) => unit"
      },
      {
        "id": "Belt.Array.shuffleInPlace",
        "kind": "value",
        "name": "shuffleInPlace",
        "docstrings": [
          "`shuffleInPlace(arr)` randomly re-orders the items in `arr`"
        ],
        "signature": "let shuffleInPlace: t<'a> => unit"
      },
      {
        "id": "Belt.Array.shuffle",
        "kind": "value",
        "name": "shuffle",
        "docstrings": [
          "Returns a fresh array with items in original array randomly shuffled."
        ],
        "signature": "let shuffle: t<'a> => t<'a>"
      },
      {
        "id": "Belt.Array.reverseInPlace",
        "kind": "value",
        "name": "reverseInPlace",
        "docstrings": [
          "`reverseInPlace(arr)` reverses items in `arr` in place.\n\n## Examples\n\n```rescript\nlet arr = [10, 11, 12, 13, 14]\n\nlet () = Belt.Array.reverseInPlace(arr)\n\narr == [14, 13, 12, 11, 10]\n```"
        ],
        "signature": "let reverseInPlace: t<'a> => unit"
      },
      {
        "id": "Belt.Array.reverse",
        "kind": "value",
        "name": "reverse",
        "docstrings": [
          "`reverse(arr)` returns a fresh array with items in arr in reverse order.\n\n## Examples\n\n```rescript\nBelt.Array.reverse([10, 11, 12, 13, 14]) == [14, 13, 12, 11, 10]\n```"
        ],
        "signature": "let reverse: t<'a> => t<'a>"
      },
      {
        "id": "Belt.Array.makeUninitialized",
        "kind": "value",
        "name": "makeUninitialized",
        "docstrings": [
          "`makeUninitialized(n)` creates an array of length `n` filled with the undefined\nvalue. You must specify the type of data that will eventually fill the array.\n\n## Examples\n\n```rescript\nlet arr: array<Js.undefined<string>> = Belt.Array.makeUninitialized(5)\n\nBelt.Array.getExn(arr, 0) == Js.undefined\n```"
        ],
        "signature": "let makeUninitialized: int => array<Js.undefined<'a>>"
      },
      {
        "id": "Belt.Array.makeUninitializedUnsafe",
        "kind": "value",
        "name": "makeUninitializedUnsafe",
        "docstrings": [
          "**Unsafe**\n\n## Examples\n\n```rescript\nlet arr = Belt.Array.makeUninitializedUnsafe(5)\n\nJs.log(Belt.Array.getExn(arr, 0)) // undefined\n\nBelt.Array.setExn(arr, 0, \"example\")\n\nJs.log(Belt.Array.getExn(arr, 0) == \"example\")\n```"
        ],
        "signature": "let makeUninitializedUnsafe: int => t<'a>"
      },
      {
        "id": "Belt.Array.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(n, e)` return an array of size `n` filled with value `e`.\nReturns an empty array when `n` is negative."
        ],
        "signature": "let make: (int, 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.range",
        "kind": "value",
        "name": "range",
        "docstrings": [
          "`range(start, finish)` create an inclusive array.\n\n## Examples\n\n```rescript\nBelt.Array.range(0, 3) == [0, 1, 2, 3]\n\nBelt.Array.range(3, 0) == []\n\nBelt.Array.range(3, 3) == [3]\n```"
        ],
        "signature": "let range: (int, int) => array<int>"
      },
      {
        "id": "Belt.Array.rangeBy",
        "kind": "value",
        "name": "rangeBy",
        "docstrings": [
          "`rangeBy(start, finish, ~step)` returns empty array when step is 0 or negative.\nIt also return an empty array when `start > finish`.\n\n## Examples\n\n```rescript\nBelt.Array.rangeBy(0, 10, ~step=3) == [0, 3, 6, 9]\n\nBelt.Array.rangeBy(0, 12, ~step=3) == [0, 3, 6, 9, 12]\n\nBelt.Array.rangeBy(33, 0, ~step=1) == []\n\nBelt.Array.rangeBy(33, 0, ~step=-1) == []\n\nBelt.Array.rangeBy(3, 12, ~step=-1) == []\n\nBelt.Array.rangeBy(3, 3, ~step=0) == []\n\nBelt.Array.rangeBy(3, 3, ~step=1) == [3]\n```"
        ],
        "signature": "let rangeBy: (int, int, ~step: int) => array<int>"
      },
      {
        "id": "Belt.Array.makeByU",
        "kind": "value",
        "name": "makeByU",
        "docstrings": [],
        "signature": "let makeByU: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.makeBy",
        "kind": "value",
        "name": "makeBy",
        "docstrings": [
          "`makeBy(n, f)` return an empty array when n is negative return an array of size\nn populated by `f(i)` start from `0` to `n - 1`.\n\n## Examples\n\n```rescript\nBelt.Array.makeBy(5, (i) => i) == [0, 1, 2, 3, 4]\n\nBelt.Array.makeBy(5, (i) => i * i) == [0, 1, 4, 9, 16]\n```"
        ],
        "signature": "let makeBy: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.makeByAndShuffleU",
        "kind": "value",
        "name": "makeByAndShuffleU",
        "docstrings": [],
        "signature": "let makeByAndShuffleU: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.makeByAndShuffle",
        "kind": "value",
        "name": "makeByAndShuffle",
        "docstrings": [
          "Equivalent to `shuffle(makeBy(n, f))`"
        ],
        "signature": "let makeByAndShuffle: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.zip",
        "kind": "value",
        "name": "zip",
        "docstrings": [
          "`zip(a, b)` create an array of pairs from corresponding elements of a and b.\nStop with the shorter array.\n\n## Examples\n\n```rescript\nBelt.Array.zip([1, 2], [3, 4, 5]) == [(1, 3), (2, 4)]\n```"
        ],
        "signature": "let zip: (t<'a>, array<'b>) => array<('a, 'b)>"
      },
      {
        "id": "Belt.Array.zipByU",
        "kind": "value",
        "name": "zipByU",
        "docstrings": [],
        "signature": "let zipByU: (t<'a>, array<'b>, ('a, 'b) => 'c) => array<'c>"
      },
      {
        "id": "Belt.Array.zipBy",
        "kind": "value",
        "name": "zipBy",
        "docstrings": [
          "`zipBy(xs, ys, f)` create an array by applying `f` to corresponding elements of\n`xs` and `ys`. Stops with shorter array.\n\nEquivalent to `map(zip(xs, ys), ((a, b)) => f(a, b))`\n\n## Examples\n\n```rescript\nBelt.Array.zipBy([1, 2, 3], [4, 5], (a, b) => 2 * a + b) == [6, 9]\n```"
        ],
        "signature": "let zipBy: (t<'a>, array<'b>, ('a, 'b) => 'c) => array<'c>"
      },
      {
        "id": "Belt.Array.unzip",
        "kind": "value",
        "name": "unzip",
        "docstrings": [
          "`unzip(a)` takes an array of pairs and creates a pair of arrays. The first array\ncontains all the first items of the pairs; the second array contains all the\nsecond items.\n\n## Examples\n\n```rescript\nBelt.Array.unzip([(1, 2), (3, 4)]) == ([1, 3], [2, 4])\n\nBelt.Array.unzip([(1, 2), (3, 4), (5, 6), (7, 8)]) == ([1, 3, 5, 7], [2, 4, 6, 8])\n```"
        ],
        "signature": "let unzip: array<('a, 'b)> => (t<'a>, array<'b>)"
      },
      {
        "id": "Belt.Array.concat",
        "kind": "value",
        "name": "concat",
        "docstrings": [
          "`concat(xs, ys)` returns a fresh array containing the concatenation of the arrays\n`v1` and `v2`, so even if `v1` or `v2` is empty; it can not be shared.\n\n## Examples\n\n```rescript\nBelt.Array.concat([1, 2, 3], [4, 5]) == [1, 2, 3, 4, 5]\n\nBelt.Array.concat([], [\"a\", \"b\", \"c\"]) == [\"a\", \"b\", \"c\"]\n```"
        ],
        "signature": "let concat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Belt.Array.concatMany",
        "kind": "value",
        "name": "concatMany",
        "docstrings": [
          "`concatMany(xss)` returns a fresh array as the concatenation of `xss` (an array of arrays)\n\n## Examples\n\n```rescript\nBelt.Array.concatMany([[1, 2, 3], [4, 5, 6], [7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]\n```"
        ],
        "signature": "let concatMany: array<t<'a>> => t<'a>"
      },
      {
        "id": "Belt.Array.slice",
        "kind": "value",
        "name": "slice",
        "docstrings": [
          "`slice(xs, offset, len)` creates a new array with the len elements of `xs`\nstarting at `offset` for `offset` can be negative;and is evaluated as\n`length(xs) - offset(slice, xs) - 1(1)` means get the last element as a\nsingleton array `slice(xs, ~-len, len)` will return a copy of the array if the\narray does not have enough data; `slice` extracts through the end of sequence.\n\nif `len` is negative; returns the empty array.\n\n## Examples\n\n```rescript\nBelt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=2, ~len=3) == [12, 13, 14]\n\nBelt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=-4, ~len=3) == [13, 14, 15]\n\nBelt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=4, ~len=9) == [14, 15, 16]\n```"
        ],
        "signature": "let slice: (t<'a>, ~offset: int, ~len: int) => t<'a>"
      },
      {
        "id": "Belt.Array.sliceToEnd",
        "kind": "value",
        "name": "sliceToEnd",
        "docstrings": [
          "`sliceToEnd(xs, offset)` creates a new array with the elements of `xs` starting\nat `offset`\n\n`offset` can be negative; and is evaluated as `length(xs) - offset(sliceToEnd, xs) - 1`\nmeans get the last element as a singleton array\n\n`sliceToEnd(xs, 0)` will return a copy of the array\n\n## Examples\n\n```rescript\nBelt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], 2) == [12, 13, 14, 15, 16]\n\nBelt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], -4) == [13, 14, 15, 16]\n```"
        ],
        "signature": "let sliceToEnd: (t<'a>, int) => t<'a>"
      },
      {
        "id": "Belt.Array.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(a)` returns a copy of `a`; that is; a fresh array containing the same\nelements as `a`."
        ],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.Array.fill",
        "kind": "value",
        "name": "fill",
        "docstrings": [
          "`fill(arr, ~offset, ~len, x)` modifies `arr` in place, storing `x` in elements\nnumber `offset` to `offset + len - 1`. `offset` can be negative; and is evaluated\nas `length(arr - offset)`.\n\n`fill(arr, ~offset=-1, ~len=1)` means fill the last element, if the array does not have enough data; `fill` will ignore it\n\n## Examples\n\n```rescript\nlet arr = Belt.Array.makeBy(5, (i) => i)\n\nBelt.Array.fill(arr, ~offset=2, ~len=2, 9)\n\narr == [0, 1, 9, 9, 4]\n\nBelt.Array.fill(arr, ~offset=7, ~len=2, 8)\n\narr == [0, 1, 9, 9, 4]"
        ],
        "signature": "let fill: (t<'a>, ~offset: int, ~len: int, 'a) => unit"
      },
      {
        "id": "Belt.Array.blit",
        "kind": "value",
        "name": "blit",
        "docstrings": [
          "`blit(~src=v1, ~srcOffset=o1, ~dst=v2, ~dstOffset=o2, ~len)` copies `len` elements\nfrom array `v1`;starting at element number `o1`;to array `v2`, starting at element\nnumber `o2`. It works correctly even if `v1` and `v2` are the same array and the\nsource and destination chunks overlap.\n\n`offset` can be negative; `-1` means `len - 1`; if `len + offset` is still negative;it will be set as 0\n\nFor each of the examples;presume that `v1 == [10, 11, 12, 13, 14, 15, 16, 17]` and `v2 == [20, 21, 22, 23, 24, 25, 26, 27]`. The result shown is the content of the destination array.\n\n## Examples\n\n```rescript\nlet v1 = [10, 11, 12, 13, 14, 15, 16, 17]\nlet v2 = [20, 21, 22, 23, 24, 25, 26, 27]\n\nBelt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v2, ~dstOffset=2, ~len=3)\nv2 == [20, 21, 14, 15, 16, 25, 26, 27]\n\nBelt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v1, ~dstOffset=2, ~len=3)\nv1 == [10, 11, 14, 15, 16, 15, 16, 17]\n```"
        ],
        "signature": "let blit: (\n  ~src: t<'a>,\n  ~srcOffset: int,\n  ~dst: t<'a>,\n  ~dstOffset: int,\n  ~len: int,\n) => unit"
      },
      {
        "id": "Belt.Array.blitUnsafe",
        "kind": "value",
        "name": "blitUnsafe",
        "docstrings": [
          "Unsafe blit without bounds checking."
        ],
        "signature": "let blitUnsafe: (\n  ~src: t<'a>,\n  ~srcOffset: int,\n  ~dst: t<'a>,\n  ~dstOffset: int,\n  ~len: int,\n) => unit"
      },
      {
        "id": "Belt.Array.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.Array.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(xs, f)`\n\nCall `f` on each element of `xs` from the beginning to end. `f` returns `unit`\nso no new array is created. Use `forEach` when you are primarily concerned with\nrepetitively creating side effects.\n\n## Examples\n\n```rescript\nBelt.Array.forEach([\"a\", \"b\", \"c\"], x => Js.log(\"Item: \" ++ x))\n\n/*\n  prints:\n  Item: a\n  Item: b\n  Item: c\n*/\nlet total = ref(0)\n\nBelt.Array.forEach([1, 2, 3, 4], x => total := total.contents + x)\n\ntotal.contents == 1 + 2 + 3 + 4\n```"
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.Array.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, 'a => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(xs, f)` returns a new array by calling `f` for each element of `xs` from\nthe beginning to end.\n\n## Examples\n\n```rescript\nBelt.Array.map([1, 2], (x) => x + 1) == [3, 4]\n```"
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.flatMapU",
        "kind": "value",
        "name": "flatMapU",
        "docstrings": [],
        "signature": "let flatMapU: (t<'a>, 'a => array<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(xs, f)` returns a new array by calling `f` for each element of `xs` from\nthe beginning to end, concatenating the results.\n\n## Examples\n\n```rescript\nBelt.Array.flatMap([1, 2], x => [x + 10, x + 20]) == [11, 21, 12, 22]\n```"
        ],
        "signature": "let flatMap: (t<'a>, 'a => array<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.getByU",
        "kind": "value",
        "name": "getByU",
        "docstrings": [],
        "signature": "let getByU: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.Array.getBy",
        "kind": "value",
        "name": "getBy",
        "docstrings": [
          "`getBy(xs, p)` returns `Some(value)` for the first value in `xs` that satisifies\nthe predicate function `p`; returns `None` if no element satisifies the function.\n\n## Examples\n\n```rescript\nBelt.Array.getBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(4)\nBelt.Array.getBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n```"
        ],
        "signature": "let getBy: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.Array.getIndexByU",
        "kind": "value",
        "name": "getIndexByU",
        "docstrings": [],
        "signature": "let getIndexByU: (t<'a>, 'a => bool) => option<int>"
      },
      {
        "id": "Belt.Array.getIndexBy",
        "kind": "value",
        "name": "getIndexBy",
        "docstrings": [
          "`getIndexBy(xs, p)` returns `Some(index)` for the first value in `xs` that\nsatisifies the predicate function `p`; returns `None` if no element satisifies\nthe function.\n\n## Examples\n\n```rescript\nBelt.Array.getIndexBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(1)\nBelt.Array.getIndexBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n```"
        ],
        "signature": "let getIndexBy: (t<'a>, 'a => bool) => option<int>"
      },
      {
        "id": "Belt.Array.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(xs, p)` returns a new array that keep all elements satisfy `p`."
        ],
        "signature": "let keep: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keepWithIndexU",
        "kind": "value",
        "name": "keepWithIndexU",
        "docstrings": [],
        "signature": "let keepWithIndexU: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keepWithIndex",
        "kind": "value",
        "name": "keepWithIndex",
        "docstrings": [
          "`keepWithIndex(xs, p)` returns a new array that keep all elements satisfy `p`.\n\n## Examples\n\n```rescript\nBelt.Array.keepWithIndex([1, 2, 3], (_x, i) => i == 1) == [2]\n```"
        ],
        "signature": "let keepWithIndex: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keepMapU",
        "kind": "value",
        "name": "keepMapU",
        "docstrings": [],
        "signature": "let keepMapU: (t<'a>, 'a => option<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.keepMap",
        "kind": "value",
        "name": "keepMap",
        "docstrings": [
          "`keepMap(xs, p)` returns a new array that keep all elements that return a non\nNone applied `p`.\n\n## Examples\n\n```rescript\nBelt.Array.keepMap([1, 2, 3], x =>\n  if mod(x, 2) == 0 {\n    Some(x)\n  } else {\n    None\n  }\n)\n== [2]\n```"
        ],
        "signature": "let keepMap: (t<'a>, 'a => option<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.forEachWithIndexU",
        "kind": "value",
        "name": "forEachWithIndexU",
        "docstrings": [],
        "signature": "let forEachWithIndexU: (t<'a>, (int, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Array.forEachWithIndex",
        "kind": "value",
        "name": "forEachWithIndex",
        "docstrings": [
          "`forEachWithIndex(xs, f)` same as `Belt.Array.forEach`, except that `f` is\nsupplied two arguments: the index starting from 0 and the element from `xs`.\n\n## Examples\n\n```rescript\nBelt.Array.forEachWithIndex([\"a\", \"b\", \"c\"], (i, x) => Js.log(\"Item \" ++ Belt.Int.toString(i) ++ \" is \" ++ x))\n\n/*\n  prints:\n  Item 0 is a\n  Item 1 is b\n  Item 2 is cc\n*/\nlet total = ref(0)\n\nBelt.Array.forEachWithIndex([10, 11, 12, 13], (i, x) => total := total.contents + x + i)\n\ntotal.contents == 0 + 10 + 1 + 11 + 2 + 12 + 3 + 13\n```"
        ],
        "signature": "let forEachWithIndex: (t<'a>, (int, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Array.mapWithIndexU",
        "kind": "value",
        "name": "mapWithIndexU",
        "docstrings": [],
        "signature": "let mapWithIndexU: (t<'a>, (int, 'a) => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.mapWithIndex",
        "kind": "value",
        "name": "mapWithIndex",
        "docstrings": [
          "`mapWithIndex(xs, f)` applies `f` to each element of `xs`. Function `f` takes\ntwo arguments: the index starting from 0 and the element from `xs`.\n\n## Examples\n\n```rescript\nBelt.Array.mapWithIndex([1, 2, 3], (i, x) => i + x) == [0 + 1, 1 + 2, 2 + 3]\n```"
        ],
        "signature": "let mapWithIndex: (t<'a>, (int, 'a) => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'a>, 'a => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.Array.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(f, a)` split array into tuple of two arrays based on predicate `f`;\nfirst of tuple where predicate cause true, second where predicate cause false\n\n## Examples\n\n```rescript\nBelt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) == 0) == ([2, 4], [1, 3, 5])\n\nBelt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) != 0) == ([1, 3, 5], [2, 4])\n```"
        ],
        "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.Array.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (array<'b>, 'a, ('a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(xs, init, f)` applies `f` to each element of `xs` from beginning to end.\nFunction `f` has two parameters: the item from the list and an accumulator;\nwhich starts with a value of `init`. `reduce` returns the final value of the\naccumulator.\n\n## Examples\n\n```rescript\nBelt.Array.reduce([2, 3, 4], 1, (a, b) => a + b) == 10\n\nBelt.Array.reduce([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"abcd\"\n```"
        ],
        "signature": "let reduce: (array<'b>, 'a, ('a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduceReverseU",
        "kind": "value",
        "name": "reduceReverseU",
        "docstrings": [],
        "signature": "let reduceReverseU: (array<'b>, 'a, ('a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduceReverse",
        "kind": "value",
        "name": "reduceReverse",
        "docstrings": [
          "`reduceReverse(xs, init, f)` works like `Belt.Array.reduce` except that\nfunction `f` is applied to each item of `xs` from the last back to the first.\n\n## Examples\n\n```rescript\nBelt.Array.reduceReverse([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"dcba\"\n```"
        ],
        "signature": "let reduceReverse: (array<'b>, 'a, ('a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduceReverse2U",
        "kind": "value",
        "name": "reduceReverse2U",
        "docstrings": [],
        "signature": "let reduceReverse2U: (t<'a>, array<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.Array.reduceReverse2",
        "kind": "value",
        "name": "reduceReverse2",
        "docstrings": [
          "`reduceReverse2(xs, ys, init, f)` reduces two arrays xs and ys;taking items\nstarting at `min(length(xs), length(ys))` down to and including zero.\n\n## Examples\n\n```rescript\nBelt.Array.reduceReverse2([1, 2, 3], [1, 2], 0, (acc, x, y) => acc + x + y) == 6\n```"
        ],
        "signature": "let reduceReverse2: (t<'a>, array<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.Array.reduceWithIndexU",
        "kind": "value",
        "name": "reduceWithIndexU",
        "docstrings": [],
        "signature": "let reduceWithIndexU: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.Array.reduceWithIndex",
        "kind": "value",
        "name": "reduceWithIndex",
        "docstrings": [
          "Applies `f` to each element of `xs` from beginning to end. Function `f` has\nthree parameters: the item from the array and an accumulator, which starts \nwith a value of `init` and the index of each element. `reduceWithIndex` returns\nthe final value of the accumulator.\n\n## Examples\n\n```rescript\nBelt.Array.reduceWithIndex([1, 2, 3, 4], 0, (acc, x, i) => acc + x + i) == 16\n```"
        ],
        "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.Array.joinWithU",
        "kind": "value",
        "name": "joinWithU",
        "docstrings": [],
        "signature": "let joinWithU: (t<'a>, string, 'a => string) => string"
      },
      {
        "id": "Belt.Array.joinWith",
        "kind": "value",
        "name": "joinWith",
        "docstrings": [
          "`joinWith(xs, sep, toString)`\n\nConcatenates all the elements of `xs` converted to string with `toString`, each\nseparated by `sep`, the string given as the second argument, into a single string.\nIf the array has only one element, then that element will be returned without \nusing the separator. If the array is empty, the empty string will be returned.\n\n## Examples\n\n```rescript\nBelt.Array.joinWith([0, 1], \", \", Js.Int.toString) == \"0, 1\"\nBelt.Array.joinWith([], \" \", Js.Int.toString) == \"\"\nBelt.Array.joinWith([1], \" \", Js.Int.toString) == \"1\"\n```"
        ],
        "signature": "let joinWith: (t<'a>, string, 'a => string) => string"
      },
      {
        "id": "Belt.Array.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.Array.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(xs, p)` returns true if at least one of the elements in `xs` satifies `p`;\nwhere `p` is a predicate: a function taking an element and returning a `bool`.\n\n## Examples\n\n```rescript\nBelt.Array.some([2, 3, 4], (x) => mod(x, 2) == 1) == true\n\nBelt.Array.some([(-1), (-3), (-5)], (x) => x > 0) == false\n```"
        ],
        "signature": "let some: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.Array.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.Array.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(xs, p)` returns `true` if all elements satisfy `p`; where `p` is a\npredicate: a function taking an element and returning a `bool`.\n\n## Examples\n\n```rescript\nBelt.Array.every([1, 3, 5], (x) => mod(x, 2) == 1) == true\n\nBelt.Array.every([1, (-3), 5], (x) => x > 0) == false\n```"
        ],
        "signature": "let every: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.Array.every2U",
        "kind": "value",
        "name": "every2U",
        "docstrings": [],
        "signature": "let every2U: (t<'a>, array<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.every2",
        "kind": "value",
        "name": "every2",
        "docstrings": [
          "`every2(xs, ys, p)` returns true if `p(xi, yi)` is true for all pairs of\nelements up to the shorter length (i.e. `min(length(xs), length(ys))`)\n\n## Examples\n\n```rescript\nBelt.Array.every2([1, 2, 3], [0, 1], (a, b) => a > b) == true\n\nBelt.Array.every2([], [1], (x, y) => x > y) == true\n\nBelt.Array.every2([2, 3], [1], (x, y) => x > y) == true\n\nBelt.Array.every2([0, 1], [5, 0], (x, y) => x > y) == false\n```"
        ],
        "signature": "let every2: (t<'a>, array<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.some2U",
        "kind": "value",
        "name": "some2U",
        "docstrings": [],
        "signature": "let some2U: (t<'a>, array<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.some2",
        "kind": "value",
        "name": "some2",
        "docstrings": [
          "`some2(xs, ys, p)` returns true if `p(xi, yi)` is true for any pair of elements\nup to the shorter length (i.e. `min(length(xs), length(ys))`)\n\n## Examples\n\n```rescript\nBelt.Array.some2([0, 2], [1, 0, 3], (a, b) => a > b) == true\n\nBelt.Array.some2([], [1], (x, y) => x > y) == false\n\nBelt.Array.some2([2, 3], [1, 4], (x, y) => x > y) == true\n```"
        ],
        "signature": "let some2: (t<'a>, array<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.Array.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(xs, ys, f)` compared by length if `length(xs) != length(ys)`; returning `-1`\nif `length(xs) < length(ys)` or 1 if `length(xs) > length(ys)`. Otherwise\ncompare one by one `f(x, y)`. `f` returns a negative number if `x` is less than `y`\nzero if `x` is equal to `y` a positive number if `x` is greater than\n`y`. The comparison returns the first non-zero result of `f`; or zero if `f`\nreturns zero for all `x` and `y`.\n\n## Examples\n\n```rescript\nBelt.Array.cmp([1, 3, 5], [1, 4, 2], (a, b) => compare(a, b)) == -1\n\nBelt.Array.cmp([1, 3, 5], [1, 2, 3], (a, b) => compare(a, b)) == 1\n\nBelt.Array.cmp([1, 3, 5], [1, 3, 5], (a, b) => compare(a, b)) == 0\n```"
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.Array.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Array.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(xs, ys)` return `false` if length is not the same otherwise compare items\none by one using `f(xi, yi)`; and return true if all results are true false otherwise\n\n## Examples\n\n```rescript\nBelt.Array.eq([1, 2, 3], [(-1), (-2), (-3)], (a, b) => abs(a) == abs(b)) == true\n```"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Array.truncateToLengthUnsafe",
        "kind": "value",
        "name": "truncateToLengthUnsafe",
        "docstrings": [
          "Unsafe `truncateToLengthUnsafe(xs, n)` sets length of array `xs` to `n`. If `n`\nis greater than the length of `xs`; the extra elements are set to `Js.Null_undefined.null`.\nIf `n` is less than zero; raises a `RangeError`.\n\n## Examples\n\n```rescript\nlet arr = [\"ant\", \"bee\", \"cat\", \"dog\", \"elk\"]\n\nBelt.Array.truncateToLengthUnsafe(arr, 3)\n\narr == [\"ant\", \"bee\", \"cat\"]\n```"
        ],
        "signature": "let truncateToLengthUnsafe: (t<'a>, int) => unit"
      },
      {
        "id": "Belt.Array.initU",
        "kind": "value",
        "name": "initU",
        "docstrings": [],
        "signature": "let initU: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.init",
        "kind": "value",
        "name": "init",
        "docstrings": [],
        "signature": "let init: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.push",
        "kind": "value",
        "name": "push",
        "docstrings": [
          "`arr->push(item)` pushes an element `item` into an array `arr`."
        ],
        "signature": "let push: (t<'a>, 'a) => unit"
      }
    ]
  },
  "belt/id": {
    "id": "Belt.Id",
    "name": "Id",
    "docstrings": [
      "[`Belt.Id`]()\n\n  Provide utilities to create identified comparators or hashes for\n  data structures used below.\n\n  It create a unique identifier per module of\n  functions so that different data structures with slightly different\n  comparison functions won't mix",
      "[`Belt.Id`]()\n\nProvide utiliites to create identified comparators or hashes for\ndata structures used below.\n\nIt create a unique identifer per module of functions so that different data structures with slightly different\ncomparison functions won't mix."
    ],
    "items": [
      {
        "id": "Belt.Id.hash",
        "kind": "type",
        "name": "hash",
        "docstrings": [
          "`('a, 'id) hash`\n\nIts runtime represenation is a `hash` function, but signed with a\ntype parameter, so that different hash functions type mismatch"
        ],
        "signature": "type hash<'a, 'id>"
      },
      {
        "id": "Belt.Id.eq",
        "kind": "type",
        "name": "eq",
        "docstrings": [
          "`('a, 'id) eq`\n\nIts runtime represenation is an `eq` function, but signed with a\ntype parameter, so that different hash functions type mismatch"
        ],
        "signature": "type eq<'a, 'id>"
      },
      {
        "id": "Belt.Id.cmp",
        "kind": "type",
        "name": "cmp",
        "docstrings": [
          "`('a,'id) cmp`\n\nIts runtime representation is a `cmp` function, but signed with a\ntype parameter, so that different hash functions type mismatch"
        ],
        "signature": "type cmp<'a, 'id>"
      },
      {
        "id": "Belt.Id.comparable",
        "kind": "type",
        "name": "comparable",
        "docstrings": [
          "`('key, 'id) cmparable` is a module of functions, here it only includes `cmp`.\n\nUnlike normal functions, when created, it comes with a unique identity (guaranteed\nby the type system).\n\nIt can be created using function [`comparableU`]() or [`comparable`]().\n\nThe idea of a unique identity when created is that it makes sure two sets would type\nmismatch if they use different comparison function"
        ],
        "signature": "type comparable<'key, 'id> = module(Comparable\n  with type identity = 'id\n  with type t = 'key)"
      },
      {
        "id": "Belt.Id.comparableU",
        "kind": "value",
        "name": "comparableU",
        "docstrings": [],
        "signature": "let comparableU: (\n  ~cmp: ('a, 'a) => int,\n) => module(Comparable with type t = 'a)"
      },
      {
        "id": "Belt.Id.comparable",
        "kind": "value",
        "name": "comparable",
        "docstrings": [
          "## Examples\n\n```rescript\nmodule C = (\n  val Belt.Id.comparable ~cmp:(compare : int -> int -> int)\n)\nlet m = Belt.Set.make(module C)\n```\nNote that the name of C can not be ignored"
        ],
        "signature": "let comparable: (\n  ~cmp: ('a, 'a) => int,\n) => module(Comparable with type t = 'a)"
      },
      {
        "id": "Belt.Id.hashable",
        "kind": "type",
        "name": "hashable",
        "docstrings": [
          "`('key, 'id) hashable` is a module of functions, here it only includes `hash`, `eq`.\n\nUnlike normal functions, when created, it comes with a unique identity (guaranteed\nby the type system).\n\nIt can be created using function [`hashableU`]() or [`hashable`]().\n\nThe idea of a unique identity when created is that it makes sure two hash sets would type\nmismatch if they use different comparison function"
        ],
        "signature": "type hashable<'key, 'id> = module(Hashable\n  with type identity = 'id\n  with type t = 'key)"
      },
      {
        "id": "Belt.Id.hashableU",
        "kind": "value",
        "name": "hashableU",
        "docstrings": [],
        "signature": "let hashableU: (\n  ~hash: 'a => int,\n  ~eq: ('a, 'a) => bool,\n) => module(Hashable with type t = 'a)"
      },
      {
        "id": "Belt.Id.hashable",
        "kind": "value",
        "name": "hashable",
        "docstrings": [],
        "signature": "let hashable: (\n  ~hash: 'a => int,\n  ~eq: ('a, 'a) => bool,\n) => module(Hashable with type t = 'a)"
      },
      {
        "id": "Belt.Id.getHashInternal",
        "kind": "value",
        "name": "getHashInternal",
        "docstrings": [],
        "signature": "let getHashInternal: hash<'a, 'id> => 'a => int"
      },
      {
        "id": "Belt.Id.getEqInternal",
        "kind": "value",
        "name": "getEqInternal",
        "docstrings": [],
        "signature": "let getEqInternal: eq<'a, 'id> => ('a, 'a) => bool"
      },
      {
        "id": "Belt.Id.getCmpInternal",
        "kind": "value",
        "name": "getCmpInternal",
        "docstrings": [],
        "signature": "let getCmpInternal: cmp<'a, 'id> => ('a, 'a) => int"
      }
    ]
  }
}