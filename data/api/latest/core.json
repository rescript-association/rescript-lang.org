{
  "core": {
    "id": "Core",
    "name": "Core",
    "docstrings": [],
    "items": [
      {
        "id": "Core.timeoutId",
        "kind": "type",
        "name": "timeoutId",
        "docstrings": [
          "An `id` representing a timeout started via `setTimeout`.\n\nSee [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) on MDN."
        ],
        "signature": "type timeoutId = Js.Global.timeoutId"
      },
      {
        "id": "Core.setTimeout",
        "kind": "value",
        "name": "setTimeout",
        "docstrings": [
          "`setTimeout(callback, durationInMilliseconds)` starts a timer that will execute `callback` after `durationInMilliseconds`.\n\nSee [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) on MDN.\n\n## Examples\n```rescript\n// Log to the console after 2 seconds (2000 milliseconds).\nlet timeoutId = setTimeout(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000)\n```"
        ],
        "signature": "let setTimeout: (unit => unit, int) => timeoutId"
      },
      {
        "id": "Core.setTimeoutFloat",
        "kind": "value",
        "name": "setTimeoutFloat",
        "docstrings": [
          "`setTimeoutFloat(callback, durationInMilliseconds)` starts a timer that will execute `callback` after `durationInMilliseconds`.\n\nThe same as `setTimeout`, but allows you to pass a `float` instead of an `int` for the duration.\n\nSee [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) on MDN.\n\n## Examples\n```rescript\n// Log to the console after 2 seconds (2000 milliseconds).\nlet timeoutId = setTimeoutFloat(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000.)\n```"
        ],
        "signature": "let setTimeoutFloat: (unit => unit, float) => timeoutId"
      },
      {
        "id": "Core.clearTimeout",
        "kind": "value",
        "name": "clearTimeout",
        "docstrings": [
          "`clearTimeout(timeoutId)` clears a scheduled timeout if it hasn't already executed.\n\nSee [`clearTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout) on MDN.\n\n## Examples\n```rescript\nlet timeoutId = setTimeout(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000)\n\n// Clearing the timeout right away, before 2 seconds has passed, means that the above callback logging to the console will never run.\nclearTimeout(timeoutId)\n```"
        ],
        "signature": "let clearTimeout: timeoutId => unit"
      },
      {
        "id": "Core.intervalId",
        "kind": "type",
        "name": "intervalId",
        "docstrings": [
          "An `id` representing an interval started via `setInterval`.\n\nSee [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) on MDN."
        ],
        "signature": "type intervalId = Js.Global.intervalId"
      },
      {
        "id": "Core.setInterval",
        "kind": "value",
        "name": "setInterval",
        "docstrings": [
          "`setInterval(callback, intervalInMilliseconds)` starts an interval that will execute `callback` every `durationInMilliseconds` milliseconds.\n\nSee [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) on MDN.\n\n## Examples\n```rescript\n// Log to the console ever 2 seconds (2000 milliseconds).\nlet intervalId = setInterval(() => {\n  Console.log(\"This prints every 2 seconds.\")\n}, 2000)\n```"
        ],
        "signature": "let setInterval: (unit => unit, int) => intervalId"
      },
      {
        "id": "Core.setIntervalFloat",
        "kind": "value",
        "name": "setIntervalFloat",
        "docstrings": [
          "`setIntervalFloat(callback, intervalInMilliseconds)` starts an interval that will execute `callback` every `durationInMilliseconds` milliseconds.\n\nThe same as `setInterval`, but allows you to pass a `float` instead of an `int` for the duration.\n\nSee [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) on MDN.\n\n## Examples\n```rescript\n// Log to the console ever 2 seconds (2000 milliseconds).\nlet intervalId = setIntervalFloat(() => {\n  Console.log(\"This prints every 2 seconds.\")\n}, 2000.)\n```"
        ],
        "signature": "let setIntervalFloat: (unit => unit, float) => intervalId"
      },
      {
        "id": "Core.clearInterval",
        "kind": "value",
        "name": "clearInterval",
        "docstrings": [
          "`clearInterval(intervalId)` clears a scheduled interval.\n\nSee [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval) on MDN.\n\n## Examples\n```rescript\nlet intervalId = setInterval(() => {\n  Console.log(\"This prints in 2 seconds.\")\n}, 2000)\n\n// Stop the interval after 10 seconds\nlet timeoutId = setTimeout(() => {\n  clearInterval(intervalId)\n}, 10000)\n```"
        ],
        "signature": "let clearInterval: intervalId => unit"
      },
      {
        "id": "Core.encodeURI",
        "kind": "value",
        "name": "encodeURI",
        "docstrings": [
          "Encodes a URI by replacing characters in the provided string that aren't valid in a URL.\n\nThis is intended to operate on full URIs, so it encodes fewer characters than what `encodeURIComponent` does.\nIf you're looking to encode just parts of a URI, like a query parameter, prefer `encodeURIComponent`.\n\nSee [`encodeURI`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) on MDN.\n\n## Examples\n```rescript\nConsole.log(encodeURI(\"https://rescript-lang.org?array=[someValue]\"))\n// Logs \"https://rescript-lang.org?array=%5BsomeValue%5D\" to the console.\n```"
        ],
        "signature": "let encodeURI: string => string"
      },
      {
        "id": "Core.decodeURI",
        "kind": "value",
        "name": "decodeURI",
        "docstrings": [
          "Decodes a previously encoded URI back to a regular string.\n\nThis is intended to operate on full URIs, so it decodes fewer characters than what `decodeURIComponent` does.\nIf you're looking to decode just parts of a URI, like a query parameter, prefer `decodeURIComponent`.\n\nSee [`decodeURI`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) on MDN.\n\n## Examples\n```rescript\nConsole.log(decodeURI(\"https://rescript-lang.org?array=%5BsomeValue%5D\"))\n// Logs \"https://rescript-lang.org?array=[someValue]\" to the console.\n```"
        ],
        "signature": "let decodeURI: string => string"
      },
      {
        "id": "Core.encodeURIComponent",
        "kind": "value",
        "name": "encodeURIComponent",
        "docstrings": [
          "Encodes a string so it can be used as part of a URI.\n\nSee [`encodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) on MDN.\n\n## Examples\n```rescript\nConsole.log(encodeURIComponent(\"array=[someValue]\"))\n// Logs \"array%3D%5BsomeValue%5D\" to the console.\n```"
        ],
        "signature": "let encodeURIComponent: string => string"
      },
      {
        "id": "Core.decodeURIComponent",
        "kind": "value",
        "name": "decodeURIComponent",
        "docstrings": [
          "Decodes a previously URI encoded string back to its original form.\n\nSee [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) on MDN.\n\n## Examples\n```rescript\nConsole.log(decodeURIComponent(\"array%3D%5BsomeValue%5D\"))\n// Logs \"array=[someValue]\" to the console.\n```"
        ],
        "signature": "let decodeURIComponent: string => string"
      },
      {
        "id": "Core.window",
        "kind": "value",
        "name": "window",
        "docstrings": [],
        "signature": "let window: Dom.window"
      },
      {
        "id": "Core.document",
        "kind": "value",
        "name": "document",
        "docstrings": [],
        "signature": "let document: Dom.document"
      },
      {
        "id": "Core.globalThis",
        "kind": "value",
        "name": "globalThis",
        "docstrings": [],
        "signature": "let globalThis: {..}"
      },
      {
        "id": "Core.null",
        "kind": "value",
        "name": "null",
        "docstrings": [],
        "signature": "let null: Core__Nullable.t<'a>"
      },
      {
        "id": "Core.undefined",
        "kind": "value",
        "name": "undefined",
        "docstrings": [],
        "signature": "let undefined: Core__Nullable.t<'a>"
      },
      {
        "id": "Core.typeof",
        "kind": "value",
        "name": "typeof",
        "docstrings": [],
        "signature": "let typeof: 'a => Core__Type.t"
      },
      {
        "id": "Core.import",
        "kind": "value",
        "name": "import",
        "docstrings": [
          "`import(value)` dynamically import a value or function from a ReScript\nmodule. The import call will return a `promise`, resolving to the dynamically loaded\nvalue.\n\n## Examples\n\n`Core__Array.res` file:\n\n```rescript\n@send external indexOf: (array<'a>, 'a) => int = \"indexOf\"\n\nlet indexOfOpt = (arr, item) =>\n  switch arr->indexOf(item) {\n  | -1 => None\n  | index => Some(index)\n  }\n```\nIn other file you can import the `indexOfOpt` value defined in `Core__Array.res`\n\n```rescript\nlet main = async () => {\n  let indexOfOpt = await import(Core__Array.indexOfOpt)\n  let index = indexOfOpt([1, 2], 2)\n  Console.log(index)\n}\n```\n\nCompiles to:\n\n```javascript\nasync function main() {\n  var add = await import(\"./Core__Array.mjs\").then(function(m) {\n    return m.indexOfOpt;\n  });\n  var index = indexOfOpt([1, 2], 2);\n  console.log(index);\n}\n```"
        ],
        "signature": "let import: 'a => promise<'a>"
      },
      {
        "id": "Core.null",
        "kind": "type",
        "name": "null",
        "docstrings": [],
        "signature": "type null<'a> = Js.null<'a>"
      },
      {
        "id": "Core.undefined",
        "kind": "type",
        "name": "undefined",
        "docstrings": [],
        "signature": "type undefined<'a> = Js.undefined<'a>"
      },
      {
        "id": "Core.nullable",
        "kind": "type",
        "name": "nullable",
        "docstrings": [],
        "signature": "type nullable<'a> = Js.nullable<'a>"
      },
      {
        "id": "Core.panic",
        "kind": "value",
        "name": "panic",
        "docstrings": [],
        "signature": "let panic: string => 'a"
      }
    ]
  },
  "core/intl/numberformat/grouping": {
    "id": "Core.Intl.NumberFormat.Grouping",
    "name": "Grouping",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.NumberFormat.Grouping.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.NumberFormat.Grouping.parsed",
        "kind": "type",
        "name": "parsed",
        "docstrings": [],
        "signature": "type parsed = [#always | #auto | #bool(bool) | #min2]"
      },
      {
        "id": "Core.Intl.NumberFormat.Grouping.fromBool",
        "kind": "value",
        "name": "fromBool",
        "docstrings": [],
        "signature": "let fromBool: bool => t"
      },
      {
        "id": "Core.Intl.NumberFormat.Grouping.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [],
        "signature": "let fromString: [#always | #auto | #min2] => t"
      },
      {
        "id": "Core.Intl.NumberFormat.Grouping.parseJsValue",
        "kind": "value",
        "name": "parseJsValue",
        "docstrings": [],
        "signature": "let parseJsValue: 'a => option<[> #always | #auto | #bool(bool) | #min2]>"
      }
    ]
  },
  "core/intl/segments": {
    "id": "Core.Intl.Segments",
    "name": "Segments",
    "docstrings": [
      "A Segments instance is an object that represents the segments of a specific string, subject to the locale and options of its constructing Intl.Segmenter instance.\nhttps://tc39.es/ecma402/#sec-segments-objects"
    ],
    "items": [
      {
        "id": "Core.Intl.Segments.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.Segments.segmentData",
        "kind": "type",
        "name": "segmentData",
        "docstrings": [],
        "signature": "type segmentData = {\n  segment: string,\n  index: int,\n  isWordLike: option<bool>,\n  input: string,\n}"
      },
      {
        "id": "Core.Intl.Segments.containing",
        "kind": "value",
        "name": "containing",
        "docstrings": [],
        "signature": "let containing: t => segmentData"
      },
      {
        "id": "Core.Intl.Segments.containingWithIndex",
        "kind": "value",
        "name": "containingWithIndex",
        "docstrings": [],
        "signature": "let containingWithIndex: (t, int) => segmentData"
      }
    ]
  },
  "core/intl/segmenter": {
    "id": "Core.Intl.Segmenter",
    "name": "Segmenter",
    "docstrings": [
      "Not supported in Firefox"
    ],
    "items": [
      {
        "id": "Core.Intl.Segmenter.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.Segmenter.granularity",
        "kind": "type",
        "name": "granularity",
        "docstrings": [],
        "signature": "type granularity = [#grapheme | #sentence | #word]"
      },
      {
        "id": "Core.Intl.Segmenter.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  localeMatcher?: Core__Intl__Common.localeMatcher,\n  granularity?: granularity,\n}"
      },
      {
        "id": "Core.Intl.Segmenter.pluralCategories",
        "kind": "type",
        "name": "pluralCategories",
        "docstrings": [],
        "signature": "type pluralCategories = [\n  | #few\n  | #many\n  | #one\n  | #other\n  | #two\n  | #zero\n]"
      },
      {
        "id": "Core.Intl.Segmenter.resolvedOptions",
        "kind": "type",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "type resolvedOptions = {\n  locale: string,\n  granularity: granularity,\n}"
      },
      {
        "id": "Core.Intl.Segmenter.supportedLocalesOptions",
        "kind": "type",
        "name": "supportedLocalesOptions",
        "docstrings": [],
        "signature": "type supportedLocalesOptions = {\n  localeMatcher: Core__Intl__Common.localeMatcher,\n}"
      },
      {
        "id": "Core.Intl.Segmenter.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~locales: array<string>=?, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.Segmenter.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "docstrings": [],
        "signature": "let supportedLocalesOf: (array<string>, ~options: supportedLocalesOptions=?) => t"
      },
      {
        "id": "Core.Intl.Segmenter.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "let resolvedOptions: t => resolvedOptions"
      },
      {
        "id": "Core.Intl.Segmenter.segment",
        "kind": "value",
        "name": "segment",
        "docstrings": [],
        "signature": "let segment: (t, string) => Core__Intl__Segments.t"
      }
    ]
  },
  "core/intl/relativetimeformat": {
    "id": "Core.Intl.RelativeTimeFormat",
    "name": "RelativeTimeFormat",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.RelativeTimeFormat.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.numeric",
        "kind": "type",
        "name": "numeric",
        "docstrings": [],
        "signature": "type numeric = [#always | #auto]"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.style",
        "kind": "type",
        "name": "style",
        "docstrings": [],
        "signature": "type style = [#long | #narrow | #short]"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.timeUnit",
        "kind": "type",
        "name": "timeUnit",
        "docstrings": [],
        "signature": "type timeUnit = [\n  | #day\n  | #hour\n  | #minute\n  | #month\n  | #quarter\n  | #second\n  | #week\n  | #year\n]"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  localeMatcher?: Core__Intl__Common.localeMatcher,\n  numeric?: numeric,\n  style?: style,\n}"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.supportedLocalesOptions",
        "kind": "type",
        "name": "supportedLocalesOptions",
        "docstrings": [],
        "signature": "type supportedLocalesOptions = {\n  localeMatcher: Core__Intl__Common.localeMatcher,\n}"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.resolvedOptions",
        "kind": "type",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "type resolvedOptions = {\n  locale: string,\n  numeric: numeric,\n  style: style,\n  numberingSystem: string,\n}"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.relativeTimePartComponent",
        "kind": "type",
        "name": "relativeTimePartComponent",
        "docstrings": [],
        "signature": "type relativeTimePartComponent = [#integer | #literal]"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.relativeTimePart",
        "kind": "type",
        "name": "relativeTimePart",
        "docstrings": [],
        "signature": "type relativeTimePart = {\n  \\\"type\": relativeTimePartComponent,\n  value: string,\n  unit?: timeUnit,\n}"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~locales: array<string>=?, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "docstrings": [],
        "signature": "let supportedLocalesOf: (array<string>, ~options: supportedLocalesOptions=?) => t"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "let resolvedOptions: t => resolvedOptions"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.format",
        "kind": "value",
        "name": "format",
        "docstrings": [],
        "signature": "let format: (t, int, timeUnit) => string"
      },
      {
        "id": "Core.Intl.RelativeTimeFormat.formatToParts",
        "kind": "value",
        "name": "formatToParts",
        "docstrings": [],
        "signature": "let formatToParts: (t, int, timeUnit) => array<relativeTimePart>"
      }
    ]
  },
  "core/intl/pluralrules": {
    "id": "Core.Intl.PluralRules",
    "name": "PluralRules",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.PluralRules.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.PluralRules.localeType",
        "kind": "type",
        "name": "localeType",
        "docstrings": [],
        "signature": "type localeType = [#cardinal | #ordinal]"
      },
      {
        "id": "Core.Intl.PluralRules.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  localeMatcher?: Core__Intl__Common.localeMatcher,\n  \\\"type\"?: localeType,\n  minimumIntegerDigits?: Core__Intl__Common.oneTo21,\n  minimumFractionDigits?: Core__Intl__Common.zeroTo20,\n  maximumFractionDigits?: Core__Intl__Common.zeroTo20,\n  minimumSignificantDigits?: Core__Intl__Common.oneTo21,\n  maximumSignificantDigits?: Core__Intl__Common.oneTo21,\n}"
      },
      {
        "id": "Core.Intl.PluralRules.pluralCategories",
        "kind": "type",
        "name": "pluralCategories",
        "docstrings": [],
        "signature": "type pluralCategories = [\n  | #few\n  | #many\n  | #one\n  | #other\n  | #two\n  | #zero\n]"
      },
      {
        "id": "Core.Intl.PluralRules.resolvedOptions",
        "kind": "type",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "type resolvedOptions = {\n  locale: string,\n  pluralCategories: array<pluralCategories>,\n  \\\"type\": localeType,\n  minimumIntegerDigits?: Core__Intl__Common.oneTo21,\n  minimumFractionDigits?: Core__Intl__Common.zeroTo20,\n  maximumFractionDigits?: Core__Intl__Common.zeroTo20,\n  minimumSignificantDigits?: Core__Intl__Common.oneTo21,\n  maximumSignificantDigits?: Core__Intl__Common.oneTo21,\n}"
      },
      {
        "id": "Core.Intl.PluralRules.supportedLocalesOptions",
        "kind": "type",
        "name": "supportedLocalesOptions",
        "docstrings": [],
        "signature": "type supportedLocalesOptions = {\n  localeMatcher: Core__Intl__Common.localeMatcher,\n}"
      },
      {
        "id": "Core.Intl.PluralRules.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~locales: array<string>=?, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.PluralRules.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "docstrings": [],
        "signature": "let supportedLocalesOf: (array<string>, ~options: supportedLocalesOptions=?) => t"
      },
      {
        "id": "Core.Intl.PluralRules.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "let resolvedOptions: t => resolvedOptions"
      },
      {
        "id": "Core.Intl.PluralRules.rule",
        "kind": "type",
        "name": "rule",
        "docstrings": [],
        "signature": "type rule = [#few | #many | #one | #other | #two | #zero]"
      },
      {
        "id": "Core.Intl.PluralRules.select",
        "kind": "value",
        "name": "select",
        "docstrings": [],
        "signature": "let select: (t, float) => rule"
      },
      {
        "id": "Core.Intl.PluralRules.selectInt",
        "kind": "value",
        "name": "selectInt",
        "docstrings": [],
        "signature": "let selectInt: (t, int) => rule"
      },
      {
        "id": "Core.Intl.PluralRules.selectBigInt",
        "kind": "value",
        "name": "selectBigInt",
        "docstrings": [],
        "signature": "let selectBigInt: (t, bigint) => rule"
      },
      {
        "id": "Core.Intl.PluralRules.selectRange",
        "kind": "value",
        "name": "selectRange",
        "docstrings": [],
        "signature": "let selectRange: (t, ~start: float, ~end: float) => rule"
      },
      {
        "id": "Core.Intl.PluralRules.selectRangeInt",
        "kind": "value",
        "name": "selectRangeInt",
        "docstrings": [],
        "signature": "let selectRangeInt: (t, ~start: int, ~end: int) => rule"
      },
      {
        "id": "Core.Intl.PluralRules.selectRangeBigInt",
        "kind": "value",
        "name": "selectRangeBigInt",
        "docstrings": [],
        "signature": "let selectRangeBigInt: (t, ~start: bigint, ~end: bigint) => rule"
      }
    ]
  },
  "core/intl/numberformat": {
    "id": "Core.Intl.NumberFormat",
    "name": "NumberFormat",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.NumberFormat.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.NumberFormat.currency",
        "kind": "type",
        "name": "currency",
        "docstrings": [
          "An ISO 4217 currency code. e.g. USD, EUR, CNY"
        ],
        "signature": "type currency = string"
      },
      {
        "id": "Core.Intl.NumberFormat.currencyDisplay",
        "kind": "type",
        "name": "currencyDisplay",
        "docstrings": [],
        "signature": "type currencyDisplay = [\n  | #code\n  | #name\n  | #narrowSymbol\n  | #symbol\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.currencySign",
        "kind": "type",
        "name": "currencySign",
        "docstrings": [],
        "signature": "type currencySign = [#accounting | #standard]"
      },
      {
        "id": "Core.Intl.NumberFormat.notation",
        "kind": "type",
        "name": "notation",
        "docstrings": [],
        "signature": "type notation = [\n  | #compact\n  | #engineering\n  | #scientific\n  | #standard\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.compactDisplay",
        "kind": "type",
        "name": "compactDisplay",
        "docstrings": [
          "Used only when notation is #compact"
        ],
        "signature": "type compactDisplay = [#long | #short]"
      },
      {
        "id": "Core.Intl.NumberFormat.signDisplay",
        "kind": "type",
        "name": "signDisplay",
        "docstrings": [],
        "signature": "type signDisplay = [\n  | #always\n  | #auto\n  | #exceptZero\n  | #negative\n  | #never\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.style",
        "kind": "type",
        "name": "style",
        "docstrings": [],
        "signature": "type style = [#currency | #decimal | #percent | #unit]"
      },
      {
        "id": "Core.Intl.NumberFormat.unitSystem",
        "kind": "type",
        "name": "unitSystem",
        "docstrings": [
          "Defined in https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-issanctionedsimpleunitidentifier\nOnly used when style is #unit"
        ],
        "signature": "type unitSystem = string"
      },
      {
        "id": "Core.Intl.NumberFormat.unitDisplay",
        "kind": "type",
        "name": "unitDisplay",
        "docstrings": [
          "Only used when style is #unit"
        ],
        "signature": "type unitDisplay = [#long | #narrow | #short]"
      },
      {
        "id": "Core.Intl.NumberFormat.rounding",
        "kind": "type",
        "name": "rounding",
        "docstrings": [],
        "signature": "type rounding = [\n  | #ceil\n  | #expand\n  | #floor\n  | #halfCeil\n  | #halfEven\n  | #halfExpand\n  | #halfFloor\n  | #halfTrunc\n  | #trunc\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.roundingPriority",
        "kind": "type",
        "name": "roundingPriority",
        "docstrings": [],
        "signature": "type roundingPriority = [\n  | #auto\n  | #lessPrecision\n  | #morePrecision\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.roundingIncrement",
        "kind": "type",
        "name": "roundingIncrement",
        "docstrings": [],
        "signature": "type roundingIncrement = [\n  | #1\n  | #10\n  | #100\n  | #1000\n  | #2\n  | #20\n  | #200\n  | #2000\n  | #25\n  | #250\n  | #2500\n  | #5\n  | #50\n  | #500\n  | #5000\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.trailingZeroDisplay",
        "kind": "type",
        "name": "trailingZeroDisplay",
        "docstrings": [],
        "signature": "type trailingZeroDisplay = [\n  | #auto\n  | #lessPrecision\n  | #stripIfInteger\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  compactDisplay?: compactDisplay,\n  numberingSystem?: Core__Intl__Common.numberingSystem,\n  currency?: currency,\n  currencyDisplay?: currencyDisplay,\n  currencySign?: currencySign,\n  localeMatcher?: Core__Intl__Common.localeMatcher,\n  notation?: notation,\n  signDisplay?: signDisplay,\n  style?: style,\n  unit?: unitSystem,\n  unitDisplay?: unitDisplay,\n  useGrouping?: Grouping.t,\n  roundingMode?: rounding,\n  roundingPriority?: roundingPriority,\n  roundingIncrement?: roundingIncrement,\n  trailingZeroDisplay?: trailingZeroDisplay,\n  minimumIntegerDigits?: Core__Intl__Common.oneTo21,\n  minimumFractionDigits?: Core__Intl__Common.zeroTo20,\n  maximumFractionDigits?: Core__Intl__Common.zeroTo20,\n  minimumSignificantDigits?: Core__Intl__Common.oneTo21,\n  maximumSignificantDigits?: Core__Intl__Common.oneTo21,\n}"
      },
      {
        "id": "Core.Intl.NumberFormat.resolvedOptions",
        "kind": "type",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "type resolvedOptions = {\n  currency?: currency,\n  currencyDisplay?: currencyDisplay,\n  currencySign?: currencySign,\n  compactDisplay?: compactDisplay,\n  unit: unitSystem,\n  unitDisplay: unitDisplay,\n  roundingMode?: rounding,\n  roundingPriority?: roundingPriority,\n  roundingIncrement?: roundingIncrement,\n  minimumIntegerDigits?: Core__Intl__Common.oneTo21,\n  minimumFractionDigits?: Core__Intl__Common.zeroTo20,\n  maximumFractionDigits?: Core__Intl__Common.zeroTo20,\n  minimumSignificantDigits?: Core__Intl__Common.oneTo21,\n  maximumSignificantDigits?: Core__Intl__Common.oneTo21,\n  locale: string,\n  notation: notation,\n  numberingSystem: Core__Intl__Common.numberingSystem,\n  signDisplay: signDisplay,\n  style: style,\n  useGrouping: Grouping.t,\n}"
      },
      {
        "id": "Core.Intl.NumberFormat.supportedLocalesOptions",
        "kind": "type",
        "name": "supportedLocalesOptions",
        "docstrings": [],
        "signature": "type supportedLocalesOptions = {\n  localeMatcher: Core__Intl__Common.localeMatcher,\n}"
      },
      {
        "id": "Core.Intl.NumberFormat.numberFormatPartType",
        "kind": "type",
        "name": "numberFormatPartType",
        "docstrings": [],
        "signature": "type numberFormatPartType = [\n  | #compact\n  | #currency\n  | #decimal\n  | #exponentInteger\n  | #exponentMinusSign\n  | #exponentSeparator\n  | #fraction\n  | #group\n  | #infinity\n  | #integer\n  | #literal\n  | #minusSign\n  | #nan\n  | #percentSign\n  | #plusSign\n  | #unit\n  | #unknown\n]"
      },
      {
        "id": "Core.Intl.NumberFormat.numberFormatPart",
        "kind": "type",
        "name": "numberFormatPart",
        "docstrings": [],
        "signature": "type numberFormatPart = {\n  \\\"type\": numberFormatPartType,\n  value: string,\n}"
      },
      {
        "id": "Core.Intl.NumberFormat.rangeSource",
        "kind": "type",
        "name": "rangeSource",
        "docstrings": [],
        "signature": "type rangeSource = [#endRange | #shared | #startRange]"
      },
      {
        "id": "Core.Intl.NumberFormat.numberFormatRangePart",
        "kind": "type",
        "name": "numberFormatRangePart",
        "docstrings": [],
        "signature": "type numberFormatRangePart = {\n  \\\"type\": numberFormatPartType,\n  value: string,\n  source: rangeSource,\n}"
      },
      {
        "id": "Core.Intl.NumberFormat.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~locales: array<string>=?, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.NumberFormat.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "docstrings": [],
        "signature": "let supportedLocalesOf: (array<string>, ~options: supportedLocalesOptions=?) => t"
      },
      {
        "id": "Core.Intl.NumberFormat.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "let resolvedOptions: t => resolvedOptions"
      },
      {
        "id": "Core.Intl.NumberFormat.format",
        "kind": "value",
        "name": "format",
        "docstrings": [],
        "signature": "let format: (t, float) => string"
      },
      {
        "id": "Core.Intl.NumberFormat.formatRange",
        "kind": "value",
        "name": "formatRange",
        "docstrings": [],
        "signature": "let formatRange: (t, ~start: float, ~end: float) => array<string>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatToParts",
        "kind": "value",
        "name": "formatToParts",
        "docstrings": [],
        "signature": "let formatToParts: (t, float) => array<numberFormatPart>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatRangeToParts",
        "kind": "value",
        "name": "formatRangeToParts",
        "docstrings": [],
        "signature": "let formatRangeToParts: (\n  t,\n  ~start: float,\n  ~end: float,\n) => array<numberFormatRangePart>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatInt",
        "kind": "value",
        "name": "formatInt",
        "docstrings": [],
        "signature": "let formatInt: (t, int) => string"
      },
      {
        "id": "Core.Intl.NumberFormat.formatIntRange",
        "kind": "value",
        "name": "formatIntRange",
        "docstrings": [],
        "signature": "let formatIntRange: (t, ~start: int, ~end: int) => array<string>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatIntToParts",
        "kind": "value",
        "name": "formatIntToParts",
        "docstrings": [],
        "signature": "let formatIntToParts: (t, int) => array<numberFormatPart>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatIntRangeToParts",
        "kind": "value",
        "name": "formatIntRangeToParts",
        "docstrings": [],
        "signature": "let formatIntRangeToParts: (t, ~start: int, ~end: int) => array<numberFormatRangePart>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatBigInt",
        "kind": "value",
        "name": "formatBigInt",
        "docstrings": [],
        "signature": "let formatBigInt: (t, bigint) => string"
      },
      {
        "id": "Core.Intl.NumberFormat.formatBigIntRange",
        "kind": "value",
        "name": "formatBigIntRange",
        "docstrings": [],
        "signature": "let formatBigIntRange: (t, ~start: bigint, ~end: bigint) => array<string>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatBigIntToParts",
        "kind": "value",
        "name": "formatBigIntToParts",
        "docstrings": [],
        "signature": "let formatBigIntToParts: (t, bigint) => array<numberFormatPart>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatBigIntRangeToParts",
        "kind": "value",
        "name": "formatBigIntRangeToParts",
        "docstrings": [],
        "signature": "let formatBigIntRangeToParts: (t, ~start: bigint, ~end: bigint) => array<numberFormatPart>"
      },
      {
        "id": "Core.Intl.NumberFormat.formatString",
        "kind": "value",
        "name": "formatString",
        "docstrings": [],
        "signature": "let formatString: (t, string) => string"
      },
      {
        "id": "Core.Intl.NumberFormat.formatStringToParts",
        "kind": "value",
        "name": "formatStringToParts",
        "docstrings": [],
        "signature": "let formatStringToParts: (t, string) => array<numberFormatRangePart>"
      }
    ]
  },
  "core/intl/locale": {
    "id": "Core.Intl.Locale",
    "name": "Locale",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.Locale.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.Locale.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  baseName?: string,\n  calendar?: Core__Intl__Common.calendar,\n  collation?: Core__Intl__Common.collation,\n  hourCycle?: [#h11 | #h12 | #h23 | #h24],\n  caseFirst?: [#\"false\" | #lower | #upper],\n  numberingSystem?: Core__Intl__Common.numberingSystem,\n  numeric?: bool,\n  language?: string,\n  script?: string,\n  region?: string,\n}"
      },
      {
        "id": "Core.Intl.Locale.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (string, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.Locale.baseName",
        "kind": "value",
        "name": "baseName",
        "docstrings": [],
        "signature": "let baseName: t => string"
      },
      {
        "id": "Core.Intl.Locale.calendar",
        "kind": "value",
        "name": "calendar",
        "docstrings": [],
        "signature": "let calendar: t => option<string>"
      },
      {
        "id": "Core.Intl.Locale.caseFirst",
        "kind": "value",
        "name": "caseFirst",
        "docstrings": [],
        "signature": "let caseFirst: t => option<string>"
      },
      {
        "id": "Core.Intl.Locale.collation",
        "kind": "value",
        "name": "collation",
        "docstrings": [],
        "signature": "let collation: t => option<string>"
      },
      {
        "id": "Core.Intl.Locale.hourCycle",
        "kind": "value",
        "name": "hourCycle",
        "docstrings": [],
        "signature": "let hourCycle: t => option<string>"
      },
      {
        "id": "Core.Intl.Locale.language",
        "kind": "value",
        "name": "language",
        "docstrings": [],
        "signature": "let language: t => string"
      },
      {
        "id": "Core.Intl.Locale.numberingSystem",
        "kind": "value",
        "name": "numberingSystem",
        "docstrings": [],
        "signature": "let numberingSystem: t => option<string>"
      },
      {
        "id": "Core.Intl.Locale.numeric",
        "kind": "value",
        "name": "numeric",
        "docstrings": [],
        "signature": "let numeric: t => bool"
      },
      {
        "id": "Core.Intl.Locale.region",
        "kind": "value",
        "name": "region",
        "docstrings": [],
        "signature": "let region: t => option<string>"
      },
      {
        "id": "Core.Intl.Locale.script",
        "kind": "value",
        "name": "script",
        "docstrings": [],
        "signature": "let script: t => option<string>"
      },
      {
        "id": "Core.Intl.Locale.maximize",
        "kind": "value",
        "name": "maximize",
        "docstrings": [],
        "signature": "let maximize: t => t"
      },
      {
        "id": "Core.Intl.Locale.minimize",
        "kind": "value",
        "name": "minimize",
        "docstrings": [],
        "signature": "let minimize: t => t"
      }
    ]
  },
  "core/intl/listformat": {
    "id": "Core.Intl.ListFormat",
    "name": "ListFormat",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.ListFormat.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.ListFormat.listType",
        "kind": "type",
        "name": "listType",
        "docstrings": [],
        "signature": "type listType = [#conjunction | #disjunction | #unit]"
      },
      {
        "id": "Core.Intl.ListFormat.style",
        "kind": "type",
        "name": "style",
        "docstrings": [],
        "signature": "type style = [#long | #narrow | #short]"
      },
      {
        "id": "Core.Intl.ListFormat.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  localeMatcher?: Core__Intl__Common.localeMatcher,\n  \\\"type\"?: listType,\n  style?: style,\n}"
      },
      {
        "id": "Core.Intl.ListFormat.listPartComponentType",
        "kind": "type",
        "name": "listPartComponentType",
        "docstrings": [],
        "signature": "type listPartComponentType = [#element | #literal]"
      },
      {
        "id": "Core.Intl.ListFormat.listPart",
        "kind": "type",
        "name": "listPart",
        "docstrings": [],
        "signature": "type listPart = {\n  \\\"type\": listPartComponentType,\n  value: string,\n}"
      },
      {
        "id": "Core.Intl.ListFormat.resolvedOptions",
        "kind": "type",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "type resolvedOptions = {\n  locale: string,\n  style: style,\n  \\\"type\": listType,\n}"
      },
      {
        "id": "Core.Intl.ListFormat.supportedLocalesOptions",
        "kind": "type",
        "name": "supportedLocalesOptions",
        "docstrings": [],
        "signature": "type supportedLocalesOptions = {\n  localeMatcher: Core__Intl__Common.localeMatcher,\n}"
      },
      {
        "id": "Core.Intl.ListFormat.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~locales: array<string>=?, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.ListFormat.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "docstrings": [],
        "signature": "let supportedLocalesOf: (array<string>, ~options: supportedLocalesOptions=?) => t"
      },
      {
        "id": "Core.Intl.ListFormat.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "let resolvedOptions: t => resolvedOptions"
      },
      {
        "id": "Core.Intl.ListFormat.format",
        "kind": "value",
        "name": "format",
        "docstrings": [],
        "signature": "let format: (t, array<string>) => string"
      },
      {
        "id": "Core.Intl.ListFormat.formatToParts",
        "kind": "value",
        "name": "formatToParts",
        "docstrings": [],
        "signature": "let formatToParts: (t, array<string>) => array<listPart>"
      }
    ]
  },
  "core/intl/datetimeformat": {
    "id": "Core.Intl.DateTimeFormat",
    "name": "DateTimeFormat",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.DateTimeFormat.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.DateTimeFormat.dateStyle",
        "kind": "type",
        "name": "dateStyle",
        "docstrings": [],
        "signature": "type dateStyle = [#full | #long | #medium | #short]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.timeStyle",
        "kind": "type",
        "name": "timeStyle",
        "docstrings": [],
        "signature": "type timeStyle = [#full | #long | #medium | #short]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.dayPeriod",
        "kind": "type",
        "name": "dayPeriod",
        "docstrings": [],
        "signature": "type dayPeriod = [#long | #narrow | #short]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.weekday",
        "kind": "type",
        "name": "weekday",
        "docstrings": [],
        "signature": "type weekday = [#long | #narrow | #short]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.era",
        "kind": "type",
        "name": "era",
        "docstrings": [],
        "signature": "type era = [#long | #narrow | #short]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.year",
        "kind": "type",
        "name": "year",
        "docstrings": [],
        "signature": "type year = [#\"2-digit\" | #numeric]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.month",
        "kind": "type",
        "name": "month",
        "docstrings": [],
        "signature": "type month = [\n  | #\"2-digit\"\n  | #long\n  | #narrow\n  | #numeric\n  | #short\n]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.day",
        "kind": "type",
        "name": "day",
        "docstrings": [],
        "signature": "type day = [#\"2-digit\" | #numeric]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.hour",
        "kind": "type",
        "name": "hour",
        "docstrings": [],
        "signature": "type hour = [#\"2-digit\" | #numeric]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.minute",
        "kind": "type",
        "name": "minute",
        "docstrings": [],
        "signature": "type minute = [#\"2-digit\" | #numeric]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.second",
        "kind": "type",
        "name": "second",
        "docstrings": [],
        "signature": "type second = [#\"2-digit\" | #numeric]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.timeZoneName",
        "kind": "type",
        "name": "timeZoneName",
        "docstrings": [
          "Firefox also supports IANA time zone names here\nNode v19+ supports \"shortOffset\", \"shortGeneric\", \"longOffset\", and \"longGeneric\"."
        ],
        "signature": "type timeZoneName = [\n  | #long\n  | #longGeneric\n  | #longOffset\n  | #short\n  | #shortGeneric\n  | #shortOffset\n]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.hourCycle",
        "kind": "type",
        "name": "hourCycle",
        "docstrings": [],
        "signature": "type hourCycle = [#h11 | #h12 | #h23 | #h24]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.formatMatcher",
        "kind": "type",
        "name": "formatMatcher",
        "docstrings": [],
        "signature": "type formatMatcher = [#basic | #\"best fit\"]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.fractionalSecondDigits",
        "kind": "type",
        "name": "fractionalSecondDigits",
        "docstrings": [],
        "signature": "type fractionalSecondDigits = [#0 | #1 | #2 | #3]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  dateStyle?: dateStyle,\n  timeStyle?: timeStyle,\n  calendar?: Core__Intl__Common.calendar,\n  dayPeriod?: dayPeriod,\n  numberingSystem?: Core__Intl__Common.numberingSystem,\n  localeMatcher?: Core__Intl__Common.localeMatcher,\n  timeZone?: string,\n  hour12?: bool,\n  hourCycle?: hourCycle,\n  formatMatcher?: formatMatcher,\n  weekday?: weekday,\n  era?: era,\n  year?: year,\n  month?: month,\n  day?: day,\n  hour?: hour,\n  minute?: minute,\n  second?: second,\n  fractionalSecondDigits?: fractionalSecondDigits,\n  timeZoneName?: timeZoneName,\n}"
      },
      {
        "id": "Core.Intl.DateTimeFormat.resolvedOptions",
        "kind": "type",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "type resolvedOptions = {\n  dateStyle?: dateStyle,\n  timeStyle?: timeStyle,\n  weekday?: weekday,\n  era?: era,\n  year?: year,\n  month?: month,\n  day?: day,\n  hour?: hour,\n  minute?: minute,\n  second?: second,\n  fractionalSecondDigits?: fractionalSecondDigits,\n  timeZoneName?: timeZoneName,\n  calendar: Core__Intl__Common.calendar,\n  hour12: bool,\n  hourCycle: hourCycle,\n  locale: string,\n  numberingSystem: Core__Intl__Common.numberingSystem,\n  timeZone: string,\n}"
      },
      {
        "id": "Core.Intl.DateTimeFormat.supportedLocalesOptions",
        "kind": "type",
        "name": "supportedLocalesOptions",
        "docstrings": [],
        "signature": "type supportedLocalesOptions = {\n  localeMatcher: Core__Intl__Common.localeMatcher,\n}"
      },
      {
        "id": "Core.Intl.DateTimeFormat.dateTimeComponent",
        "kind": "type",
        "name": "dateTimeComponent",
        "docstrings": [],
        "signature": "type dateTimeComponent = [\n  | #day\n  | #dayPeriod\n  | #era\n  | #fractionalSecond\n  | #hour\n  | #literal\n  | #minute\n  | #month\n  | #relatedYear\n  | #second\n  | #timeZone\n  | #weekday\n  | #year\n  | #yearName\n]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.dateTimePart",
        "kind": "type",
        "name": "dateTimePart",
        "docstrings": [],
        "signature": "type dateTimePart = {\n  \\\"type\": dateTimeComponent,\n  value: string,\n}"
      },
      {
        "id": "Core.Intl.DateTimeFormat.dateTimeRangeSource",
        "kind": "type",
        "name": "dateTimeRangeSource",
        "docstrings": [],
        "signature": "type dateTimeRangeSource = [\n  | #endRange\n  | #shared\n  | #startRange\n]"
      },
      {
        "id": "Core.Intl.DateTimeFormat.dateTimeRangePart",
        "kind": "type",
        "name": "dateTimeRangePart",
        "docstrings": [],
        "signature": "type dateTimeRangePart = {\n  \\\"type\": dateTimeComponent,\n  value: string,\n  source: dateTimeRangeSource,\n}"
      },
      {
        "id": "Core.Intl.DateTimeFormat.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~locales: array<string>=?, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.DateTimeFormat.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "docstrings": [],
        "signature": "let supportedLocalesOf: (array<string>, ~options: supportedLocalesOptions=?) => t"
      },
      {
        "id": "Core.Intl.DateTimeFormat.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "let resolvedOptions: t => resolvedOptions"
      },
      {
        "id": "Core.Intl.DateTimeFormat.format",
        "kind": "value",
        "name": "format",
        "docstrings": [],
        "signature": "let format: (t, Core__Date.t) => string"
      },
      {
        "id": "Core.Intl.DateTimeFormat.formatToParts",
        "kind": "value",
        "name": "formatToParts",
        "docstrings": [],
        "signature": "let formatToParts: (t, Core__Date.t) => array<dateTimePart>"
      },
      {
        "id": "Core.Intl.DateTimeFormat.formatRange",
        "kind": "value",
        "name": "formatRange",
        "docstrings": [],
        "signature": "let formatRange: (\n  t,\n  ~startDate: Core__Date.t,\n  ~endDate: Core__Date.t,\n) => string"
      },
      {
        "id": "Core.Intl.DateTimeFormat.formatRangeToParts",
        "kind": "value",
        "name": "formatRangeToParts",
        "docstrings": [],
        "signature": "let formatRangeToParts: (\n  t,\n  ~startDate: Core__Date.t,\n  ~endDate: Core__Date.t,\n) => array<dateTimeRangePart>"
      }
    ]
  },
  "core/intl/collator": {
    "id": "Core.Intl.Collator",
    "name": "Collator",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.Collator.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.Intl.Collator.usage",
        "kind": "type",
        "name": "usage",
        "docstrings": [],
        "signature": "type usage = [#search | #sort]"
      },
      {
        "id": "Core.Intl.Collator.sensitivity",
        "kind": "type",
        "name": "sensitivity",
        "docstrings": [],
        "signature": "type sensitivity = [#accent | #base | #case | #variant]"
      },
      {
        "id": "Core.Intl.Collator.caseFirst",
        "kind": "type",
        "name": "caseFirst",
        "docstrings": [],
        "signature": "type caseFirst = [#\"false\" | #lower | #upper]"
      },
      {
        "id": "Core.Intl.Collator.options",
        "kind": "type",
        "name": "options",
        "docstrings": [],
        "signature": "type options = {\n  localeMatcher?: Core__Intl__Common.localeMatcher,\n  usage?: usage,\n  sensitivity?: sensitivity,\n  ignorePunctuation?: bool,\n  numeric?: bool,\n  caseFirst?: caseFirst,\n}"
      },
      {
        "id": "Core.Intl.Collator.resolvedOptions",
        "kind": "type",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "type resolvedOptions = {\n  locale: string,\n  usage: usage,\n  sensitivity: sensitivity,\n  ignorePunctuation: bool,\n  collation: [\n    | #compat\n    | #default\n    | #dict\n    | #emoji\n    | #eor\n    | #phonebk\n    | #phonetic\n    | #pinyin\n    | #stroke\n    | #trad\n    | #unihan\n    | #zhuyin\n  ],\n  numeric?: bool,\n  caseFirst?: caseFirst,\n}"
      },
      {
        "id": "Core.Intl.Collator.supportedLocalesOptions",
        "kind": "type",
        "name": "supportedLocalesOptions",
        "docstrings": [],
        "signature": "type supportedLocalesOptions = {\n  localeMatcher: Core__Intl__Common.localeMatcher,\n}"
      },
      {
        "id": "Core.Intl.Collator.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~locales: array<string>=?, ~options: options=?) => t"
      },
      {
        "id": "Core.Intl.Collator.supportedLocalesOf",
        "kind": "value",
        "name": "supportedLocalesOf",
        "docstrings": [],
        "signature": "let supportedLocalesOf: (array<string>, ~options: supportedLocalesOptions=?) => t"
      },
      {
        "id": "Core.Intl.Collator.resolvedOptions",
        "kind": "value",
        "name": "resolvedOptions",
        "docstrings": [],
        "signature": "let resolvedOptions: t => resolvedOptions"
      },
      {
        "id": "Core.Intl.Collator.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (t, string, string) => int"
      }
    ]
  },
  "core/intl/common": {
    "id": "Core.Intl.Common",
    "name": "Common",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.Common.localeMatcher",
        "kind": "type",
        "name": "localeMatcher",
        "docstrings": [],
        "signature": "type localeMatcher = [#\"best fit\" | #lookup]"
      },
      {
        "id": "Core.Intl.Common.calendar",
        "kind": "type",
        "name": "calendar",
        "docstrings": [],
        "signature": "type calendar = [\n  | #buddhist\n  | #chinese\n  | #coptic\n  | #dangi\n  | #ethioaa\n  | #ethiopic\n  | #gregory\n  | #hebrew\n  | #indian\n  | #islamic\n  | #\"islamic-civil\"\n  | #\"islamic-rgsa\"\n  | #\"islamic-tbla\"\n  | #\"islamic-umalqura\"\n  | #iso8601\n  | #japanese\n  | #persian\n  | #roc\n]"
      },
      {
        "id": "Core.Intl.Common.collation",
        "kind": "type",
        "name": "collation",
        "docstrings": [],
        "signature": "type collation = [\n  | #compat\n  | #dict\n  | #emoji\n  | #eor\n  | #phonebk\n  | #phonetic\n  | #pinyin\n  | #stroke\n  | #trad\n  | #unihan\n  | #zhuyin\n]"
      },
      {
        "id": "Core.Intl.Common.numberingSystem",
        "kind": "type",
        "name": "numberingSystem",
        "docstrings": [],
        "signature": "type numberingSystem = [\n  | #adlm\n  | #ahom\n  | #arab\n  | #arabext\n  | #bali\n  | #beng\n  | #bhks\n  | #brah\n  | #cakm\n  | #cham\n  | #deva\n  | #diak\n  | #fullwide\n  | #gong\n  | #gonm\n  | #gujr\n  | #guru\n  | #hanidec\n  | #hmng\n  | #hmnp\n  | #java\n  | #kali\n  | #kawi\n  | #khmr\n  | #knda\n  | #lana\n  | #lanatham\n  | #laoo\n  | #latn\n  | #lepc\n  | #limb\n  | #mathbold\n  | #mathdbl\n  | #mathmono\n  | #mathsanb\n  | #mathsans\n  | #mlym\n  | #modi\n  | #mong\n  | #mroo\n  | #mtei\n  | #mymr\n  | #mymrshan\n  | #mymrtlng\n  | #nagm\n  | #newa\n  | #nkoo\n  | #olck\n  | #orya\n  | #osma\n  | #rohg\n  | #saur\n  | #segment\n  | #shrd\n  | #sind\n  | #sinh\n  | #sora\n  | #sund\n  | #takr\n  | #talu\n  | #tamldec\n  | #telu\n  | #thai\n  | #tibt\n  | #tirh\n  | #tnsa\n  | #vaii\n  | #wara\n  | #wcho\n]"
      },
      {
        "id": "Core.Intl.Common.oneTo21",
        "kind": "type",
        "name": "oneTo21",
        "docstrings": [],
        "signature": "type oneTo21 = [\n  | #1\n  | #10\n  | #11\n  | #12\n  | #13\n  | #14\n  | #15\n  | #16\n  | #17\n  | #18\n  | #19\n  | #2\n  | #20\n  | #21\n  | #3\n  | #4\n  | #5\n  | #6\n  | #7\n  | #8\n  | #9\n]"
      },
      {
        "id": "Core.Intl.Common.zeroTo20",
        "kind": "type",
        "name": "zeroTo20",
        "docstrings": [],
        "signature": "type zeroTo20 = [\n  | #0\n  | #1\n  | #10\n  | #11\n  | #12\n  | #13\n  | #14\n  | #15\n  | #16\n  | #17\n  | #18\n  | #19\n  | #2\n  | #20\n  | #3\n  | #4\n  | #5\n  | #6\n  | #7\n  | #8\n  | #9\n]"
      }
    ]
  },
  "core/biguint64array/constants": {
    "id": "Core.BigUint64Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.BigUint64Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/bigint64array/constants": {
    "id": "Core.BigInt64Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.BigInt64Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/uint8clampedarray/constants": {
    "id": "Core.Uint8ClampedArray.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint8ClampedArray.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/uint32array/constants": {
    "id": "Core.Uint32Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint32Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/uint16array/constants": {
    "id": "Core.Uint16Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint16Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/uint8array/constants": {
    "id": "Core.Uint8Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint8Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/int32array/constants": {
    "id": "Core.Int32Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Int32Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/int16array/constants": {
    "id": "Core.Int16Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Int16Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/int8array/constants": {
    "id": "Core.Int8Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Int8Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/float64array/constants": {
    "id": "Core.Float64Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Float64Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/float32array/constants": {
    "id": "Core.Float32Array.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Float32Array.Constants.bytesPerElement",
        "kind": "value",
        "name": "bytesPerElement",
        "docstrings": [
          "`bytesPerElement` returns the element size. See [BYTES_PER_ELEMENT on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT)"
        ],
        "signature": "let bytesPerElement: int"
      }
    ]
  },
  "core/json/decode": {
    "id": "Core.JSON.Decode",
    "name": "Decode",
    "docstrings": [],
    "items": [
      {
        "id": "Core.JSON.Decode.bool",
        "kind": "value",
        "name": "bool",
        "docstrings": [
          "Decodes a single JSON value. If the value is a bool, it will return `Some(bool)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`true`)->JSON.Decode.bool\n  // Some(true)\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.bool\n  // None\n  ```"
        ],
        "signature": "let bool: t => option<bool>"
      },
      {
        "id": "Core.JSON.Decode.null",
        "kind": "value",
        "name": "null",
        "docstrings": [
          "Decodes a single JSON value. If the value is null, it will return `Some(Null.t)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`null`)->JSON.Decode.null\n  // Some(null)\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.null\n  // None\n  ```"
        ],
        "signature": "let null: t => option<Core__Null.t<'a>>"
      },
      {
        "id": "Core.JSON.Decode.string",
        "kind": "value",
        "name": "string",
        "docstrings": [
          "Decodes a single JSON value. If the value is a string, it will return `Some(string)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.string\n  // Some(\"hello world\")\n\n  JSON.parseExn(`42`)->JSON.Decode.string\n  // None \n  ```"
        ],
        "signature": "let string: t => option<string>"
      },
      {
        "id": "Core.JSON.Decode.float",
        "kind": "value",
        "name": "float",
        "docstrings": [
          "Decodes a single JSON value. If the value is a float, it will return `Some(float)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`42.0`)->JSON.Decode.float\n  // Some(42.0)\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.float\n  // None\n  ```"
        ],
        "signature": "let float: t => option<float>"
      },
      {
        "id": "Core.JSON.Decode.object",
        "kind": "value",
        "name": "object",
        "docstrings": [
          "Decodes a single JSON value. If the value is an object, it will return `Some(Dict.t)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`{\"foo\":\"bar\"}`)->JSON.Decode.object\n  // Some({ foo: 'bar' })\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.object\n  // None\n  ```"
        ],
        "signature": "let object: t => option<Core__Dict.t<t>>"
      },
      {
        "id": "Core.JSON.Decode.array",
        "kind": "value",
        "name": "array",
        "docstrings": [
          "Decodes a single JSON value. If the value is an array, it will return `Some(array)` - otherwise it will return `None`.\n\n  ## Examples\n  ```rescript\n  JSON.parseExn(`[\"foo\", \"bar\"]`)->JSON.Decode.array\n  // Some([ 'foo', 'bar' ])\n\n  JSON.parseExn(`\"hello world\"`)->JSON.Decode.array\n  // None\n  ```"
        ],
        "signature": "let array: t => option<array<t>>"
      }
    ]
  },
  "core/json/encode": {
    "id": "Core.JSON.Encode",
    "name": "Encode",
    "docstrings": [],
    "items": [
      {
        "id": "Core.JSON.Encode.bool",
        "kind": "value",
        "name": "bool",
        "docstrings": [
          "Returns a boolean as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.bool(true)\n  ```"
        ],
        "signature": "let bool: bool => t"
      },
      {
        "id": "Core.JSON.Encode.null",
        "kind": "value",
        "name": "null",
        "docstrings": [
          "Returns null as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.null\n  ```"
        ],
        "signature": "let null: t"
      },
      {
        "id": "Core.JSON.Encode.string",
        "kind": "value",
        "name": "string",
        "docstrings": [
          "Returns a string as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.string(\"hello world\")\n  ```"
        ],
        "signature": "let string: string => t"
      },
      {
        "id": "Core.JSON.Encode.int",
        "kind": "value",
        "name": "int",
        "docstrings": [
          "Returns an int as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.int(42)\n  ```"
        ],
        "signature": "let int: int => t"
      },
      {
        "id": "Core.JSON.Encode.float",
        "kind": "value",
        "name": "float",
        "docstrings": [
          "Returns a float as a JSON object.\n\n  ## Examples\n  ```rescript\n  JSON.Encode.float(42.0)\n  ```"
        ],
        "signature": "let float: float => t"
      },
      {
        "id": "Core.JSON.Encode.object",
        "kind": "value",
        "name": "object",
        "docstrings": [
          "Returns a dict as a JSON object.\n\n  ## Examples\n  ```rescript\n  let dict = Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n  ])\n\n  JSON.Encode.object(dict)\n  ```"
        ],
        "signature": "let object: Core__Dict.t<t> => t"
      },
      {
        "id": "Core.JSON.Encode.array",
        "kind": "value",
        "name": "array",
        "docstrings": [
          "Returns an array as a JSON object.\n\n  ## Examples\n  ```rescript\n  let array = [JSON.Encode.string(\"hello world\"), JSON.Encode.int(42)]\n\n  JSON.Encode.array(array)\n  ```"
        ],
        "signature": "let array: array<t> => t"
      }
    ]
  },
  "core/json/classify": {
    "id": "Core.JSON.Classify",
    "name": "Classify",
    "docstrings": [],
    "items": [
      {
        "id": "Core.JSON.Classify.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "A type representing a JavaScript type."
        ],
        "signature": "type t =\n  | Bool(bool)\n  | Null\n  | String(string)\n  | Number(float)\n  | Object(Core__Dict.t<t>)\n  | Array(array<t>)"
      },
      {
        "id": "Core.JSON.Classify.classify",
        "kind": "value",
        "name": "classify",
        "docstrings": [
          "Returns the JSON type of any value.\n\n  ## Examples\n  ```rescript\n  JSON.Classify.classify(\"hello world\")\n  // String(\"hello world\")\n\n  JSON.Classify.classify(42)\n  // Number(42)\n  ```"
        ],
        "signature": "let classify: 'a => t"
      }
    ]
  },
  "core/type/classify": {
    "id": "Core.Type.Classify",
    "name": "Classify",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Type.Classify.function",
        "kind": "type",
        "name": "function",
        "docstrings": [
          "An abstract type representing a JavaScript function.\n\n  See [`function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) on MDN."
        ],
        "signature": "type function"
      },
      {
        "id": "Core.Type.Classify.object",
        "kind": "type",
        "name": "object",
        "docstrings": [
          "An abstract type representing a JavaScript object.\n\n  See [`object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) on MDN."
        ],
        "signature": "type object"
      },
      {
        "id": "Core.Type.Classify.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type representing a classified JavaScript value."
        ],
        "signature": "type t =\n  | Bool(bool)\n  | Null\n  | Undefined\n  | String(string)\n  | Number(float)\n  | Object(object)\n  | Function(function)\n  | Symbol(Core__Symbol.t)\n  | BigInt(bigint)"
      },
      {
        "id": "Core.Type.Classify.classify",
        "kind": "value",
        "name": "classify",
        "docstrings": [
          "`classify(anyValue)`\nClassifies a JavaScript value.\n\n## Examples\n```rescript\nswitch %raw(`null`)->Type.Classify.classify {\n| Null => Console.log(\"Yup, that's null.\")\n| _ => Console.log(\"This doesn't actually appear to be null...\")\n}\n```"
        ],
        "signature": "let classify: 'a => t"
      }
    ]
  },
  "core/regexp/result": {
    "id": "Core.RegExp.Result",
    "name": "Result",
    "docstrings": [],
    "items": [
      {
        "id": "Core.RegExp.Result.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Type representing the result of a `RegExp` execution."
        ],
        "signature": "type t = array<option<string>>"
      },
      {
        "id": "Core.RegExp.Result.fullMatch",
        "kind": "value",
        "name": "fullMatch",
        "docstrings": [
          "`fullMatch(regExpResult)` returns the full string that matched in this result.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints the full string that matched, \"ReScript is\"\n  }\n  ```"
        ],
        "signature": "let fullMatch: t => string"
      },
      {
        "id": "Core.RegExp.Result.matches",
        "kind": "value",
        "name": "matches",
        "docstrings": [
          "`matches(regExpResult)` returns all matches for `regExpResult`.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  // This below will log \"ReScript\" and \"is\" to the console.\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => switch result->RegExp.Result.matches {\n    | [firstWord, secondWord] => Console.log2(firstWord, secondWord)\n    | _ => Console.log(\"Didn't find exactly two words...\")\n    }\n  }\n  ```"
        ],
        "signature": "let matches: t => array<string>"
      },
      {
        "id": "Core.RegExp.Result.index",
        "kind": "value",
        "name": "index",
        "docstrings": [],
        "signature": "let index: t => int"
      },
      {
        "id": "Core.RegExp.Result.input",
        "kind": "value",
        "name": "input",
        "docstrings": [
          "`input(regExpResult)` returns the full input string that was passed to what produced the `RegExp.Result.t`.\n\n  ## Examples\n  ```rescript\n  // Match the first two words separated by a space\n  let regexp = RegExp.fromString(\"(\\\\w+) (\\\\w+)\")\n\n  // This below will log the full input string \"ReScript is pretty cool, right?\" to the console.\n  switch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n  | None => Console.log(\"Nope, no match...\")\n  | Some(result) => Console.log(result->RegExp.Result.input)\n  }\n  ```"
        ],
        "signature": "let input: t => string"
      }
    ]
  },
  "core/math/int": {
    "id": "Core.Math.Int",
    "name": "Int",
    "docstrings": [
      "Provide Math utilities for `int`"
    ],
    "items": [
      {
        "id": "Core.Math.Int.abs",
        "kind": "value",
        "name": "abs",
        "docstrings": [
          "`abs(v)` returns absolute value of `v`.\n  See [`Math.abs`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.abs(-2) // 2\n  Math.Int.abs(3) // 3\n  ```"
        ],
        "signature": "let abs: int => int"
      },
      {
        "id": "Core.Math.Int.clz32",
        "kind": "value",
        "name": "clz32",
        "docstrings": [
          "`clz32(v)` returns the number of leading zero bits of the argument's 32 bit\n  int representation.\n  See [`Math.clz32`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32) on MDN.\n\n  ## Examples\n\n  ```rescript\n  // 00000000000000000000000000000001\n  Math.Int.clz32(1) // 31\n  // 00000000000000000000000000000100\n  Math.Int.clz32(4) // 29\n  ```"
        ],
        "signature": "let clz32: int => int"
      },
      {
        "id": "Core.Math.Int.imul",
        "kind": "value",
        "name": "imul",
        "docstrings": [
          "`imul(a, b)` returns 32-bit integer multiplication. Use this only when you\n  need to optimize performance of multiplication of numbers stored as 32-bit\n  integers.\n  See [`Math.imul`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.imul(3, 4) // 12\n  Math.Int.imul(-5, 12) // 60\n  ```"
        ],
        "signature": "let imul: (int, int) => int"
      },
      {
        "id": "Core.Math.Int.min",
        "kind": "value",
        "name": "min",
        "docstrings": [
          "`min(a, b)` returns the minimum of its two integer arguments.\n  See [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.min(1, 2) // 1\n  Math.Int.min(-1, -2) // -2\n  ```"
        ],
        "signature": "let min: (int, int) => int"
      },
      {
        "id": "Core.Math.Int.minMany",
        "kind": "value",
        "name": "minMany",
        "docstrings": [
          "`minMany(arr)` returns the minimum of the integers in the given array `arr`.\n  Returns `Infinity` if `arr` is empty.\n  See [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.minMany([1, 2]) // 1\n  Math.Int.minMany([-1, -2]) // -2\n  Math.Int.minMany([])->Int.toFloat->Float.isFinite // false\n  ```"
        ],
        "signature": "let minMany: array<int> => int"
      },
      {
        "id": "Core.Math.Int.max",
        "kind": "value",
        "name": "max",
        "docstrings": [
          "`max(a, b)` returns the maximum of its two integer arguments.\n  See [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.max(1, 2) // 2\n  Math.Int.max(-1, -2) // -1\n  ```"
        ],
        "signature": "let max: (int, int) => int"
      },
      {
        "id": "Core.Math.Int.maxMany",
        "kind": "value",
        "name": "maxMany",
        "docstrings": [
          "`maxMany(arr)` returns the maximum of the integers in the given array `arr`.\n  Returns `Infinity` if `arr` is empty.\n  See [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.maxMany([1, 2]) // 2\n  Math.Int.maxMany([-1, -2]) // -1\n  Math.Int.maxMany([])->Int.toFloat->Float.isFinite // false\n  ```"
        ],
        "signature": "let maxMany: array<int> => int"
      },
      {
        "id": "Core.Math.Int.pow",
        "kind": "value",
        "name": "pow",
        "docstrings": [
          "`pow(a, ~exp)` raises the given base `a` to the given exponent `exp`.\n  See [`Math.pow`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.pow(2, ~exp=4) // 16\n  Math.Int.pow(3, ~exp=4) // 81\n  ```"
        ],
        "signature": "let pow: (int, ~exp: int) => int"
      },
      {
        "id": "Core.Math.Int.sign",
        "kind": "value",
        "name": "sign",
        "docstrings": [
          "`sign(v)` returns the sign of its integer argument: `-1` if negative, `0` if\n  zero, `1` if positive.\n  See [`Math.sign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.sign(3) // 1\n  Math.Int.sign(-3) // 1\n  Math.Int.sign(0) // 0\n  ```"
        ],
        "signature": "let sign: int => int"
      },
      {
        "id": "Core.Math.Int.floor",
        "kind": "value",
        "name": "floor",
        "docstrings": [
          "floor(v) returns the largest `int` less than or equal to the argument; \n  See [`Math.floor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)\n  on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.floor(3.7) == 3\n  Math.Int.floor(3.0) == 3\n  Math.Int.floor(-3.1) == -4\n  ```"
        ],
        "signature": "let floor: float => int"
      },
      {
        "id": "Core.Math.Int.ceil",
        "kind": "value",
        "name": "ceil",
        "docstrings": [
          "ceil(v) returns the smallest `int` greater than or equal to the argument;\n  See [`Math.floor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)\n  on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.ceil(3.7) == 4\n  Math.Int.ceil(3.0) == 3\n  Math.Int.ceil(-3.1) == -3\n  ```"
        ],
        "signature": "let ceil: float => int"
      },
      {
        "id": "Core.Math.Int.random",
        "kind": "value",
        "name": "random",
        "docstrings": [
          "`random(minVal, maxVal)` returns a random integer number in the half-closed interval [minVal, maxVal).\n   See [`Math.random`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)\n  on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Int.random(2, 5) == 4\n  Math.Int.random(505, 2000) == 1276\n  Math.Int.random(-7, -2) == -4\n  ```"
        ],
        "signature": "let random: (int, int) => int"
      }
    ]
  },
  "core/math/constants": {
    "id": "Core.Math.Constants",
    "name": "Constants",
    "docstrings": [
      "Mathematical Constants"
    ],
    "items": [
      {
        "id": "Core.Math.Constants.e",
        "kind": "value",
        "name": "e",
        "docstrings": [
          "`Math.Constants.e` returns Euler's number,  2.718281828459045.\n  See [`Math.E`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/E) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.e\n  ```"
        ],
        "signature": "let e: float"
      },
      {
        "id": "Core.Math.Constants.ln2",
        "kind": "value",
        "name": "ln2",
        "docstrings": [
          "`Math.Constants.ln2` returns Natural logarithm of 2,  0.6931471805599453.\n  See [`Math.LN2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LN2) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.ln2\n  ```"
        ],
        "signature": "let ln2: float"
      },
      {
        "id": "Core.Math.Constants.ln10",
        "kind": "value",
        "name": "ln10",
        "docstrings": [
          "`Math.Constants.ln10` returns Natural logarithm of 10,  2.302585092994046.\n  See [`Math.LN10`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LN10) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.ln10\n  ```"
        ],
        "signature": "let ln10: float"
      },
      {
        "id": "Core.Math.Constants.log2e",
        "kind": "value",
        "name": "log2e",
        "docstrings": [
          "`Math.Constants.log2e` returns Base 2 logarithm of E,  1.4426950408889634.\n  See [`Math.LOG2E`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG2E) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.log2e\n  ```"
        ],
        "signature": "let log2e: float"
      },
      {
        "id": "Core.Math.Constants.log10e",
        "kind": "value",
        "name": "log10e",
        "docstrings": [
          "`Math.Constants.log10e` returns Base 10 logarithm of E,  0.4342944819032518.\n  See [`Math.LOG10E`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG10E) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.log10e\n  ```"
        ],
        "signature": "let log10e: float"
      },
      {
        "id": "Core.Math.Constants.pi",
        "kind": "value",
        "name": "pi",
        "docstrings": [
          "`Math.Constants.pi` returns Pi - ratio of the circumference to the diameter\n  of a circle,  3.141592653589793.\n  See [`Math.PI`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/PI) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.pi\n  ```"
        ],
        "signature": "let pi: float"
      },
      {
        "id": "Core.Math.Constants.sqrt1_2",
        "kind": "value",
        "name": "sqrt1_2",
        "docstrings": [
          "`Math.Constants.sqrt1_2` returns Square root of 1/2,  0.7071067811865476.\n  See [`Math.SQRT1_2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT1_2) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.sqrt1_2\n  ```"
        ],
        "signature": "let sqrt1_2: float"
      },
      {
        "id": "Core.Math.Constants.sqrt2",
        "kind": "value",
        "name": "sqrt2",
        "docstrings": [
          "`Math.Constants.e` returns Absolute value for integer argument.\n  See [`Math.abs`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Math.Constants.sqrt2\n  ```"
        ],
        "signature": "let sqrt2: float"
      }
    ]
  },
  "core/int/constants": {
    "id": "Core.Int.Constants",
    "name": "Constants",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Int.Constants.minValue",
        "kind": "value",
        "name": "minValue",
        "docstrings": [
          "The smallest positive number represented in JavaScript.\n  See [`Number.MIN_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE)\n  on MDN.\n\n  ## Examples\n\n  ```rescript\n  Console.log(Int.Constants.minValue)\n  ```"
        ],
        "signature": "let minValue: int"
      },
      {
        "id": "Core.Int.Constants.maxValue",
        "kind": "value",
        "name": "maxValue",
        "docstrings": [
          "The largest positive number represented in JavaScript.\n  See [`Number.MAX_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE)\n  on MDN.\n\n  ## Examples\n\n  ```rescript\n  Console.log(Int.Constants.maxValue)\n  ```"
        ],
        "signature": "let maxValue: int"
      }
    ]
  },
  "core/float/constants": {
    "id": "Core.Float.Constants",
    "name": "Constants",
    "docstrings": [
      "Float constants."
    ],
    "items": [
      {
        "id": "Core.Float.Constants.nan",
        "kind": "value",
        "name": "nan",
        "docstrings": [
          "The special value \"Not a Number\"\n  See [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.nan\n  ```"
        ],
        "signature": "let nan: float"
      },
      {
        "id": "Core.Float.Constants.epsilon",
        "kind": "value",
        "name": "epsilon",
        "docstrings": [
          "Represents the difference between 1 and the smallest floating point number greater than 1.\n  See [`Number.EPSILON`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.epsilon\n  ```"
        ],
        "signature": "let epsilon: float"
      },
      {
        "id": "Core.Float.Constants.positiveInfinity",
        "kind": "value",
        "name": "positiveInfinity",
        "docstrings": [
          "The positive Infinity value\n  See [`Number.POSITIVE_INFINITY`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.positiveInfinity\n  ```"
        ],
        "signature": "let positiveInfinity: float"
      },
      {
        "id": "Core.Float.Constants.negativeInfinity",
        "kind": "value",
        "name": "negativeInfinity",
        "docstrings": [
          "The negative Infinity value\n  See [`Number.NEGATIVE_INFINITY`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.negativeInfinity\n  ```"
        ],
        "signature": "let negativeInfinity: float"
      },
      {
        "id": "Core.Float.Constants.minValue",
        "kind": "value",
        "name": "minValue",
        "docstrings": [
          "The smallest positive numeric value representable in JavaScript.\n  See [`Number.MIN_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.minValue\n  ```"
        ],
        "signature": "let minValue: float"
      },
      {
        "id": "Core.Float.Constants.maxValue",
        "kind": "value",
        "name": "maxValue",
        "docstrings": [
          "The maximum positive numeric value representable in JavaScript.\n  See [`Number.MAX_VALUE`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE) on MDN.\n\n  ## Examples\n\n  ```rescript\n  Float.Constants.minValue\n  ```"
        ],
        "signature": "let maxValue: float"
      }
    ]
  },
  "core/error/urierror": {
    "id": "Core.Error.URIError",
    "name": "URIError",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Error.URIError.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new `URIError` with the provided `message`.\n\n  See [`URIError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError) on MDN."
        ],
        "signature": "let make: string => t"
      }
    ]
  },
  "core/error/typeerror": {
    "id": "Core.Error.TypeError",
    "name": "TypeError",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Error.TypeError.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new `TypeError` with the provided `message`.\n\n  See [`TypeError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError) on MDN."
        ],
        "signature": "let make: string => t"
      }
    ]
  },
  "core/error/syntaxerror": {
    "id": "Core.Error.SyntaxError",
    "name": "SyntaxError",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Error.SyntaxError.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new `SyntaxError` with the provided `message`.\n\n  See [`SyntaxError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError) on MDN."
        ],
        "signature": "let make: string => t"
      }
    ]
  },
  "core/error/referenceerror": {
    "id": "Core.Error.ReferenceError",
    "name": "ReferenceError",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Error.ReferenceError.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new `ReferenceError` with the provided `message`.\n\n  See [`ReferenceError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError) on MDN."
        ],
        "signature": "let make: string => t"
      }
    ]
  },
  "core/error/rangeerror": {
    "id": "Core.Error.RangeError",
    "name": "RangeError",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Error.RangeError.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new `RangeError` with the provided `message`.\n\n  See [`RangeError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError) on MDN."
        ],
        "signature": "let make: string => t"
      }
    ]
  },
  "core/error/evalerror": {
    "id": "Core.Error.EvalError",
    "name": "EvalError",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Error.EvalError.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new `EvalError` with the provided `message`.\n\n  See [`EvalError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError) on MDN."
        ],
        "signature": "let make: string => t"
      }
    ]
  },
  "core/date/utc": {
    "id": "Core.Date.UTC",
    "name": "UTC",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Date.UTC.makeWithYM",
        "kind": "value",
        "name": "makeWithYM",
        "docstrings": [
          "Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYM(~year=2023, ~month=0)\n  // 1672531200000\n\n  Date.UTC.makeWithYM(~year=2023, ~month=11)\n  // 1701388800000\n\n  Date.UTC.makeWithYM(~year=2023, ~month=12)\n  // 1704067200000\n\n  Date.UTC.makeWithYM(~year=2023, ~month=-1)\n  // 1669852800000\n  ```"
        ],
        "signature": "let makeWithYM: (~year: int, ~month: int) => msSinceEpoch"
      },
      {
        "id": "Core.Date.UTC.makeWithYMD",
        "kind": "value",
        "name": "makeWithYMD",
        "docstrings": [
          "Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMD(~year=2023, ~month=1, ~date=20)\n  // 1676851200000\n\n  Date.UTC.makeWithYMD(~year=2023, ~month=1, ~date=-1)\n  // 1675036800000\n\n  Date.UTC.makeWithYMD(~year=2023, ~month=1, ~date=29)\n  // 1677628800000\n  ```"
        ],
        "signature": "let makeWithYMD: (~year: int, ~month: int, ~date: int) => msSinceEpoch"
      },
      {
        "id": "Core.Date.UTC.makeWithYMDH",
        "kind": "value",
        "name": "makeWithYMDH",
        "docstrings": [
          "Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=16)\n  // 1676908800000\n\n  Date.UTC.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=24)\n  // 1676937600000\n\n  Date.UTC.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=-1)\n  // 1676847600000\n  ```"
        ],
        "signature": "let makeWithYMDH: (\n  ~year: int,\n  ~month: int,\n  ~date: int,\n  ~hours: int,\n) => msSinceEpoch"
      },
      {
        "id": "Core.Date.UTC.makeWithYMDHM",
        "kind": "value",
        "name": "makeWithYMDHM",
        "docstrings": [
          "Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40)\n  // 1676911200000\n\n  Date.UTC.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=60)\n  // 1676912400000\n\n  Date.UTC.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=-1)\n  // 1676908740000\n  ```"
        ],
        "signature": "let makeWithYMDHM: (\n  ~year: int,\n  ~month: int,\n  ~date: int,\n  ~hours: int,\n  ~minutes: int,\n) => msSinceEpoch"
      },
      {
        "id": "Core.Date.UTC.makeWithYMDHMS",
        "kind": "value",
        "name": "makeWithYMDHMS",
        "docstrings": [
          "Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0)\n  // 1676911200000\n\n  Date.UTC.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=60)\n  // 1676911260000\n\n  Date.UTC.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=-1)\n  // 1676911199000\n  ```"
        ],
        "signature": "let makeWithYMDHMS: (\n  ~year: int,\n  ~month: int,\n  ~date: int,\n  ~hours: int,\n  ~minutes: int,\n  ~seconds: int,\n) => msSinceEpoch"
      },
      {
        "id": "Core.Date.UTC.makeWithYMDHMSM",
        "kind": "value",
        "name": "makeWithYMDHMSM",
        "docstrings": [
          "Returns the time, in milliseconds, since UNIX epoch (January 1, 1970 00:00:00 UTC).\n  Be aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\n  Months are 0-indexed (0 = January, 11 = December).\n  Values, which are out of range, will be carried over to the next bigger unit (s. example).\n\n  ## Examples\n  ```rescript\n  Date.UTC.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=0)->Console.log\n  // 1676911200000\n\n  Date.UTC.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=1000)->Console.log\n  // 1676911201000\n\n  Date.UTC.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=-1)->Console.log\n  // 1676911199999\n  ```"
        ],
        "signature": "let makeWithYMDHMSM: (\n  ~year: int,\n  ~month: int,\n  ~date: int,\n  ~hours: int,\n  ~minutes: int,\n  ~seconds: int,\n  ~milliseconds: int,\n) => msSinceEpoch"
      }
    ]
  },
  "core/result": {
    "id": "Core.Result",
    "name": "Result",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Result.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Result types are really useful to describe the result of a certain operation\n  without relying on exceptions or `option` types.\n\n  This module gives you useful utilities to create and combine `Result` data."
        ],
        "signature": "let getExn: result<'a, 'b> => 'a"
      },
      {
        "id": "Core.Result.mapOr",
        "kind": "value",
        "name": "mapOr",
        "docstrings": [
          "`mapOr(res, default, f)`: When res is `Ok(n)`, returns `f(n)`, otherwise `default`.\n\n## Examples\n\n```rescript\nlet ok = Ok(42)\nResult.mapOr(ok, 0, (x) => x / 2) == 21\n\nlet error = Error(\"Invalid data\")\nResult.mapOr(error, 0, (x) => x / 2) == 0\n```"
        ],
        "signature": "let mapOr: (result<'a, 'c>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Core.Result.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [],
        "signature": "let mapWithDefault: (result<'a, 'c>, 'b, 'a => 'b) => 'b",
        "deprecated": "Use mapOr instead"
      },
      {
        "id": "Core.Result.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(res, f)`: When res is `Ok(n)`, returns `Ok(f(n))`. Otherwise returns res\nunchanged. Function `f` takes a value of the same type as `n` and returns an\nordinary value.\n\n## Examples\n\n```rescript\nlet f = (x) => sqrt(Int.toFloat(x))\n\nResult.map(Ok(64), f) == Ok(8.0)\n\nResult.map(Error(\"Invalid data\"), f) == Error(\"Invalid data\")\n```"
        ],
        "signature": "let map: (result<'a, 'c>, 'a => 'b) => result<'b, 'c>"
      },
      {
        "id": "Core.Result.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(res, f)`: When res is `Ok(n)`, returns `f(n)`. Otherwise, returns res\nunchanged. Function `f` takes a value of the same type as `n` and returns a\n`Result`.\n\n## Examples\n\n```rescript\nlet recip = (x) =>\n  if (x !== 0.0) {\n    Ok(1.0 /. x)\n  } else {\n    Error(\"Divide by zero\")\n  }\n\nResult.flatMap(Ok(2.0), recip) == Ok(0.5)\n\nResult.flatMap(Ok(0.0), recip) == Error(\"Divide by zero\")\n\nResult.flatMap(Error(\"Already bad\"), recip) == Error(\"Already bad\")\n```"
        ],
        "signature": "let flatMap: (result<'a, 'c>, 'a => result<'b, 'c>) => result<'b, 'c>"
      },
      {
        "id": "Core.Result.getOr",
        "kind": "value",
        "name": "getOr",
        "docstrings": [
          "`getOr(res, defaultValue)`: If `res` is `Ok(n)`, returns `n`, otherwise `default`\n\n## Examples\n\n```rescript\nResult.getOr(Ok(42), 0) == 42\n\nResult.getOr(Error(\"Invalid Data\"), 0) == 0\n```"
        ],
        "signature": "let getOr: (result<'a, 'b>, 'a) => 'a"
      },
      {
        "id": "Core.Result.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (result<'a, 'b>, 'a) => 'a",
        "deprecated": "Use getOr instead"
      },
      {
        "id": "Core.Result.isOk",
        "kind": "value",
        "name": "isOk",
        "docstrings": [
          "`isOk(res)`: Returns `true` if `res` is of the form `Ok(n)`, `false` if it is the `Error(e)` variant."
        ],
        "signature": "let isOk: result<'a, 'b> => bool"
      },
      {
        "id": "Core.Result.isError",
        "kind": "value",
        "name": "isError",
        "docstrings": [
          "`isError(res)`: Returns `true` if `res` is of the form `Error(e)`, `false` if it is the `Ok(n)` variant."
        ],
        "signature": "let isError: result<'a, 'b> => bool"
      },
      {
        "id": "Core.Result.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [
          "`equal(res1, res2, f)`: Determine if two `Result` variables are equal with\nrespect to an equality function. If `res1` and `res2` are of the form `Ok(n)`\nand `Ok(m)`, return the result of `f(n, m)`. If one of `res1` and `res2` are of\nthe form `Error(e)`, return false If both `res1` and `res2` are of the form\n`Error(e)`, return true\n\n## Examples\n\n```rescript\nlet good1 = Ok(42)\n\nlet good2 = Ok(32)\n\nlet bad1 = Error(\"invalid\")\n\nlet bad2 = Error(\"really invalid\")\n\nlet mod10equal = (a, b) => mod(a, 10) === mod(b, 10)\n\nResult.equal(good1, good2, mod10equal) == true\n\nResult.equal(good1, bad1, mod10equal) == false\n\nResult.equal(bad2, good2, mod10equal) == false\n\nResult.equal(bad1, bad2, mod10equal) == true\n```"
        ],
        "signature": "let equal: (result<'a, 'c>, result<'b, 'd>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.Result.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [
          "`compare(res1, res2, f)`: Compare two `Result` variables with respect to a\ncomparison function. The comparison function returns -1. if the first variable\nis \"less than\" the second, 0. if the two variables are equal, and 1. if the first\nis \"greater than\" the second.\n\nIf `res1` and `res2` are of the form `Ok(n)` and `Ok(m)`, return the result of\n`f(n, m)`. If `res1` is of the form `Error(e)` and `res2` of the form `Ok(n)`,\nreturn -1. (nothing is less than something) If `res1` is of the form `Ok(n)` and\n`res2` of the form `Error(e)`, return 1. (something is greater than nothing) If\nboth `res1` and `res2` are of the form `Error(e)`, return 0. (equal)\n\n## Examples\n\n```rescript\nlet good1 = Ok(59)\n\nlet good2 = Ok(37)\n\nlet bad1 = Error(\"invalid\")\n\nlet bad2 = Error(\"really invalid\")\n\nlet mod10cmp = (a, b) => Int.compare(mod(a, 10), mod(b, 10))\n\nResult.compare(Ok(39), Ok(57), mod10cmp) == 1.\n\nResult.compare(Ok(57), Ok(39), mod10cmp) == (-1.)\n\nResult.compare(Ok(39), Error(\"y\"), mod10cmp) == 1.\n\nResult.compare(Error(\"x\"), Ok(57), mod10cmp) == (-1.)\n\nResult.compare(Error(\"x\"), Error(\"y\"), mod10cmp) == 0.\n```"
        ],
        "signature": "let compare: (\n  result<'a, 'c>,\n  result<'b, 'd>,\n  ('a, 'b) => Core__Ordering.t,\n) => Core__Ordering.t"
      },
      {
        "id": "Core.Result.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(res, f)` runs the provided function `f` on the `Ok` value. If `res` is `Error`, nothing happens.\n\n## Examples\n\n```rescript\nResult.forEach(Ok(3), Console.log) // Logs \"3\", returns ()\nResult.forEach(Error(\"x\"), Console.log) // Does nothing, returns ()\n```"
        ],
        "signature": "let forEach: (result<'a, 'b>, 'a => unit) => unit"
      },
      {
        "id": "Core.Result.mapError",
        "kind": "value",
        "name": "mapError",
        "docstrings": [
          "`mapError(r, f)` generates a new `result` by applying the function `f` to the `Error` value. If the source is `Ok`, return it as-is.\n\n## Examples\n\n```rescript\nlet format = n => `Error code: ${n->Int.toString}`\nResult.mapError(Error(14), format) // Error(\"Error code: 14\")\nResult.mapError(Ok(\"abc\"), format) // Ok(\"abc\")\n```"
        ],
        "signature": "let mapError: (result<'a, 'b>, 'b => 'c) => result<'a, 'c>"
      }
    ]
  },
  "core/list": {
    "id": "Core.List",
    "name": "List",
    "docstrings": [],
    "items": [
      {
        "id": "Core.List.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Collection functions for manipulating the `list` data structures, a singly-linked list.\n\n**Prefer Array** if you need any of the following:\n\n- Random access of element\n- Better interop with JavaScript\n- Better memory usage & performance."
        ],
        "signature": "type t<'a> = list<'a>"
      },
      {
        "id": "Core.List.length",
        "kind": "value",
        "name": "length",
        "docstrings": [
          "`length(list)` returns the length of `list`.\n\n## Examples\n\n```rescript\nList.length(list{1, 2, 3}) // 3\n```"
        ],
        "signature": "let length: t<'a> => int"
      },
      {
        "id": "Core.List.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "`size(list)`. See [`length`](#length)\n\n## Examples\n\n```rescript\nList.size(list{1, 2, 3}) // 3\n```"
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Core.List.head",
        "kind": "value",
        "name": "head",
        "docstrings": [
          "`head(list)` returns `Some(value)` where `value` is the first element in the\nlist, or `None` if `list` is an empty list.\n\n## Examples\n\n```rescript\nList.head(list{}) // None\nList.head(list{1, 2, 3}) // Some(1)\n```"
        ],
        "signature": "let head: t<'a> => option<'a>"
      },
      {
        "id": "Core.List.headExn",
        "kind": "value",
        "name": "headExn",
        "docstrings": [
          "`headExn(list)` same as [`head`](#head).\n\n## Examples\n\n```rescript\nList.headExn(list{1, 2, 3}) // 1\n\nList.headExn(list{}) // Raises an Error\n```\n\n## Exceptions\n\n- Raises an Error if list is empty."
        ],
        "signature": "let headExn: t<'a> => 'a"
      },
      {
        "id": "Core.List.tail",
        "kind": "value",
        "name": "tail",
        "docstrings": [
          "`tail(list)` returns `None` if `list` is empty, otherwise it returns `Some(tail)`\nwhere `tail` is everything except the first element of `list`.\n\n## Examples\n\n```rescript\nList.tail(list{1, 2, 3}) // Some(list{2, 3})\n\nList.tail(list{}) // None\n```"
        ],
        "signature": "let tail: t<'a> => option<t<'a>>"
      },
      {
        "id": "Core.List.tailExn",
        "kind": "value",
        "name": "tailExn",
        "docstrings": [
          "`tailExn(list)` same as [`tail`](#tail).\n\n## Examples\n\n```rescript\nList.tailExn(list{1, 2, 3}) // list{2, 3}\n\nList.tailExn(list{}) // Raises an Error\n```\n\n## Exceptions\n\n- Raises an Error if list is empty."
        ],
        "signature": "let tailExn: t<'a> => t<'a>"
      },
      {
        "id": "Core.List.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "`add(list, value)` adds a `value` to the beginning of list `list`.\n\n## Examples\n\n```rescript\nList.add(list{2, 3}, 1) // list{1, 2, 3}\n\nList.add(list{\"World\", \"!\"}, \"Hello\") // list{\"Hello\", \"World\", \"!\"}\n```"
        ],
        "signature": "let add: (t<'a>, 'a) => t<'a>"
      },
      {
        "id": "Core.List.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "`get(list, index)` return the `index` element in `list`, or `None` if `index`\nis larger than the length of list `list`.\n\n## Examples\n\n```rescript\nlet abc = list{\"A\", \"B\", \"C\"}\n\nabc->List.get(1) // Some(\"B\")\n\nabc->List.get(4) // None\n```"
        ],
        "signature": "let get: (t<'a>, int) => option<'a>"
      },
      {
        "id": "Core.List.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(list, index)` same as [`get`](#get).\n\n## Examples\n\n```rescript\nlet abc = list{\"A\", \"B\", \"C\"}\n\nabc->List.getExn(1) // \"B\"\n\nabc->List.getExn(4) // Raises an Error\n```\n\n## Exceptions\n\n- Raises an Error if `index` is larger than the length of list."
        ],
        "signature": "let getExn: (t<'a>, int) => 'a"
      },
      {
        "id": "Core.List.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(length, value)` returns a list of length `length` with each element filled\nwith `value`. Returns an empty list if `value` is negative.\n\n## Examples\n\n```rescript\nList.make(~length=3, 1) // list{1, 1, 1}\n```"
        ],
        "signature": "let make: (~length: int, 'a) => t<'a>"
      },
      {
        "id": "Core.List.fromInitializer",
        "kind": "value",
        "name": "fromInitializer",
        "docstrings": [
          "`makeBy(length, f)` return a list of length `length` with element initialized\nwith `f`. Returns an empty list if `length` is negative.\n\n## Examples\n\n```rescript\nList.fromInitializer(~length=5, i => i) // list{0, 1, 2, 3, 4}\n\nList.fromInitializer(~length=5, i => i * i) // list{0, 1, 4, 9, 16}\n```"
        ],
        "signature": "let fromInitializer: (~length: int, int => 'a) => t<'a>"
      },
      {
        "id": "Core.List.toShuffled",
        "kind": "value",
        "name": "toShuffled",
        "docstrings": [
          "`toShuffled(list)` returns a new list in random order.\n\n## Examples\n\n```rescript\nList.toShuffled(list{1, 2, 3}) // list{2, 1, 3}\n```"
        ],
        "signature": "let toShuffled: t<'a> => t<'a>"
      },
      {
        "id": "Core.List.drop",
        "kind": "value",
        "name": "drop",
        "docstrings": [
          "`drop(list, value)` return a new list, dropping the first `value` element.\nReturns `None` if `list` has fewer than `value` elements.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.drop(2) // Some(list{3})\n\nlist{1, 2, 3}->List.drop(3) // Some(list{})\n\nlist{1, 2, 3}->List.drop(4) // None\n```"
        ],
        "signature": "let drop: (t<'a>, int) => option<t<'a>>"
      },
      {
        "id": "Core.List.take",
        "kind": "value",
        "name": "take",
        "docstrings": [
          "`take(list, value)` returns a list with the first `value` elements from `list`,\nor `None` if `list` has fewer than `value` elements.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.take(1) // Some(list{1})\n\nlist{1, 2, 3}->List.take(2) // Some(list{1, 2})\n\nlist{1, 2, 3}->List.take(4) // None\n```"
        ],
        "signature": "let take: (t<'a>, int) => option<t<'a>>"
      },
      {
        "id": "Core.List.splitAt",
        "kind": "value",
        "name": "splitAt",
        "docstrings": [
          "`splitAt(list, n)` split the list `list` at `n`. Returns `None` when the length\nof `list` is less than `n`.\n\n## Examples\n\n```rescript\nlist{\"Hello\", \"World\"}->List.splitAt(1) // Some((list{\"Hello\"}, list{\"World\"}))\n\nlist{0, 1, 2, 3, 4}->List.splitAt(2) // Some((list{0, 1}, list{2, 3, 4}))\n```"
        ],
        "signature": "let splitAt: (t<'a>, int) => option<(list<'a>, list<'a>)>"
      },
      {
        "id": "Core.List.concat",
        "kind": "value",
        "name": "concat",
        "docstrings": [
          "`concat(list1, list2)` returns the list obtained by adding `list1` after `list2`.\n\n## Examples\n\n```rescript\nList.concat(list{1, 2, 3}, list{4, 5}) // list{1, 2, 3, 4, 5}\n```"
        ],
        "signature": "let concat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Core.List.concatMany",
        "kind": "value",
        "name": "concatMany",
        "docstrings": [
          "`concatMany(arr)` returns the list obtained by concatenating all the lists in\narray `arr`, in order.\n\n## Examples\n\n```rescript\nList.concatMany([list{1, 2, 3}, list{}, list{3}]) // list{1, 2, 3, 3}\n```"
        ],
        "signature": "let concatMany: array<t<'a>> => t<'a>"
      },
      {
        "id": "Core.List.reverseConcat",
        "kind": "value",
        "name": "reverseConcat",
        "docstrings": [
          "`reverseConcat(list1, list2)` is equivalent to writing: `concat(reverse(list1, list2)`\n\n## Examples\n\n```rescript\nList.reverseConcat(list{1, 2}, list{3, 4}) // list{2, 1, 3, 4}\n```"
        ],
        "signature": "let reverseConcat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Core.List.flat",
        "kind": "value",
        "name": "flat",
        "docstrings": [
          "`flat(list)` return the list obtained by concatenating all the lists in\n`list`, in order.\n\n## Examples\n\n```rescript\nList.flat(list{list{1, 2, 3}, list{}, list{3}}) // list{1, 2, 3, 3}\n```"
        ],
        "signature": "let flat: t<t<'a>> => t<'a>"
      },
      {
        "id": "Core.List.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(list, f)` returns a new list with `f` applied to each element of `list`.\n\n## Examples\n\n```rescript\nlist{1, 2}->List.map(x => x + 1) // list{3, 4}\n```"
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Core.List.zip",
        "kind": "value",
        "name": "zip",
        "docstrings": [
          "`zip(list1, list2)` returns a list of pairs from the two lists with the length\nof the shorter list.\n\n## Examples\n\n```rescript\nList.zip(list{1, 2}, list{3, 4, 5}) // list{(1, 3), (2, 4)}\n```"
        ],
        "signature": "let zip: (t<'a>, t<'b>) => t<('a, 'b)>"
      },
      {
        "id": "Core.List.zipBy",
        "kind": "value",
        "name": "zipBy",
        "docstrings": [
          "`zipBy(list1, list2, f)`. See [`zip`](#zip)\n\n## Examples\n\n```rescript\nList.zipBy(list{1, 2, 3}, list{4, 5}, (a, b) => 2 * a + b) // list{6, 9}\n```"
        ],
        "signature": "let zipBy: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Core.List.mapWithIndex",
        "kind": "value",
        "name": "mapWithIndex",
        "docstrings": [
          "`mapWithIndex(list, f)` applies `f` to each element of `list`. Function `f`\ntakes two arguments: the index starting from 0 and the element from `list`, in\nthat order.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.mapWithIndex((x, index) => index + x) // list{1, 3, 5}\n```"
        ],
        "signature": "let mapWithIndex: (t<'a>, ('a, int) => 'b) => t<'b>"
      },
      {
        "id": "Core.List.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray(arr)` converts the given array `arr` to a list.\n\n## Examples\n\n```rescript\nList.fromArray([1, 2, 3]) // list{1, 2, 3}\n```"
        ],
        "signature": "let fromArray: array<'a> => t<'a>"
      },
      {
        "id": "Core.List.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "`toArray(list)` converts the given list `list` to an array.\n\n## Examples\n\n```rescript\nList.toArray(list{1, 2, 3}) // [1, 2, 3]\n```"
        ],
        "signature": "let toArray: t<'a> => array<'a>"
      },
      {
        "id": "Core.List.reverse",
        "kind": "value",
        "name": "reverse",
        "docstrings": [
          "`reverse(list)` returns a new list whose elements are those of `list` in\nreversed order.\n\n## Examples\n\n```rescript\nList.reverse(list{1, 2, 3}) // list{3, 2, 1}\n```"
        ],
        "signature": "let reverse: t<'a> => t<'a>"
      },
      {
        "id": "Core.List.mapReverse",
        "kind": "value",
        "name": "mapReverse",
        "docstrings": [
          "`mapReverse(list, f)` is equivalent to `map` function.\n\n## Examples\n\n```rescript\nlet f = x => x * x\nlet l = list{3, 4, 5}\n\nlet withMap = List.map(l, f)->List.reverse\nlet withMapReverse = l->List.mapReverse(f)\n\nConsole.log(withMap == withMapReverse) // true\n```"
        ],
        "signature": "let mapReverse: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Core.List.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(list, f)` call `f` on each element of `list` from the beginning to end.\n`f` returns `unit`, so no new array is created. Use `forEach` when you are primarily\nconcerned with repetitively creating side effects.\n\n## Examples\n\n```rescript\nList.forEach(list{\"a\", \"b\", \"c\"}, x => Console.log(\"Item: \" ++ x))\n/*\n  prints:\n  Item: a\n  Item: b\n  Item: c\n*/\n```"
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.List.forEachWithIndex",
        "kind": "value",
        "name": "forEachWithIndex",
        "docstrings": [
          "`forEachWithIndex(list, f, index)` call `f` on each element of `list` from beginning\nto end. Function `f` takes two arguments: the `index` starting from 0 and the\nelement from `list`. `f` returns `unit`.\n\n## Examples\n\n```rescript\nList.forEachWithIndex(list{\"a\", \"b\", \"c\"}, (x, index) => {\n  Console.log(\"Item \" ++ Int.toString(index) ++ \" is \" ++ x)\n})\n/*\n  prints:\n  Item 0 is a\n  Item 1 is b\n  Item 2 is cc\n*/\n```"
        ],
        "signature": "let forEachWithIndex: (t<'a>, ('a, int) => unit) => unit"
      },
      {
        "id": "Core.List.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(list, initialValue, f)` applies `f` to each element of `list` from\nbeginning to end. Function `f` has two parameters: the item from the list and\nan \"accumulator\", which starts with a value of `initialValue`. `reduce` returns\nthe final value of the accumulator.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->List.reduce(0, (a, b) => a + b) // 10\n\n// same as\n\nlist{1, 2, 3, 4}->List.reduce(0, (acc, item) => acc + item) // 10\n```"
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Core.List.reduceWithIndex",
        "kind": "value",
        "name": "reduceWithIndex",
        "docstrings": [
          "`reduceWithIndex(list, initialValue, f)` applies `f` to each element of `list`\nfrom beginning to end. Function `f` has three parameters: the item from the list\nand an \"accumulator\", which starts with a value of `initialValue` and the index\nof each element. `reduceWithIndex` returns the final value of the accumulator.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->List.reduceWithIndex(0, (acc, item, index) => acc + item + index) // 16\n```"
        ],
        "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Core.List.reduceReverse",
        "kind": "value",
        "name": "reduceReverse",
        "docstrings": [
          "`reduceReverse(list, initialValue, f)` works like `reduce`, except that\nfunction `f` is applied to each item of `list` from the last back to the first.\n\n## Examples\n\n```rescript\nlist{1, 2, 3, 4}->List.reduceReverse(0, (a, b) => a + b) // 10\n\nlist{1, 2, 3, 4}->List.reduceReverse(10, (a, b) => a - b) // 0\n\nlist{1, 2, 3, 4}->List.reduceReverse(list{}, List.add) // list{1, 2, 3, 4}\n```"
        ],
        "signature": "let reduceReverse: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Core.List.mapReverse2",
        "kind": "value",
        "name": "mapReverse2",
        "docstrings": [
          "`mapReverse2(list1, list2, f)` is equivalent to `List.zipBy(list1, list2, f)->List.reverse`.\n\n## Examples\n\n```rescript\nList.mapReverse2(list{1, 2, 3}, list{1, 2}, (a, b) => a + b) // list{4, 2}\n```"
        ],
        "signature": "let mapReverse2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Core.List.forEach2",
        "kind": "value",
        "name": "forEach2",
        "docstrings": [
          "`forEach2(list1, list2, f)` is similar to `forEach`, but accepts two lists and\nstops at the length of the shorter list.\n\n## Examples\n\n```rescript\nList.forEach2(list{\"Z\", \"Y\"}, list{\"A\", \"B\", \"C\"}, (x, y) => Console.log2(x, y))\n\n/*\n  prints:\n  \"Z\" \"A\"\n  \"Y\" \"B\"\n*/\n```"
        ],
        "signature": "let forEach2: (t<'a>, t<'b>, ('a, 'b) => 'c) => unit"
      },
      {
        "id": "Core.List.reduce2",
        "kind": "value",
        "name": "reduce2",
        "docstrings": [
          "`reduce2(list1, list2, initialValue, f)` applies `f` to each element of `list1`\nand `list2` from beginning to end. Stops with the shorter list. Function `f` has\nthree parameters: an accumulator which starts with a value of `initialValue`, an\nitem from `l1`, and an item from `l2`. `reduce2` returns the final value of the\naccumulator.\n\n## Examples\n\n```rescript\nList.reduce2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) // 0 + (1 * 1 + 4) + (2 * 2 + 5)\n```"
        ],
        "signature": "let reduce2: (t<'b>, t<'c>, 'a, ('a, 'b, 'c) => 'a) => 'a"
      },
      {
        "id": "Core.List.reduceReverse2",
        "kind": "value",
        "name": "reduceReverse2",
        "docstrings": [
          "`reduceReverse2(list1, list2, initialValue, f)` applies `f` to each element of\n`list1` and `list2`from end to beginning. Stops with the shorter list. Function\n`f` has three parameters: an accumulator which starts with a value of\n`initialValue`, an item from `l1`, and an item from `l2`. `reduce2` returns the\nfinal value of the accumulator.\n\n## Examples\n\n```rescript\nList.reduceReverse2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) //  + (1 * 1 + 4) + (2 * 2 + 5)\n```"
        ],
        "signature": "let reduceReverse2: (t<'a>, t<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Core.List.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(list, f)` returns `true` if all elements in `list` satisfy `f`, where `f`\nis a predicate: a function taking an element and returning a bool.\n\n## Examples\n\n```rescript\nlet isBelow10 = value => value < 10\n\nlist{1, 9, 8, 2}->List.every(isBelow10) // true\n\nlist{1, 99, 8, 2}->List.every(isBelow10) // false\n```"
        ],
        "signature": "let every: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Core.List.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(list, f)` returns `true` if at least _one_ of the elements in `list`\nsatisfies `f`, where `f` is a predicate: a function taking an element and\nreturning a bool.\n\n## Examples\n\n```rescript\nlet isAbove100 = value => value > 100\n\nlist{101, 1, 2, 3}->List.some(isAbove100) // true\n\nlist{1, 2, 3, 4}->List.some(isAbove100) // false\n```"
        ],
        "signature": "let some: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Core.List.every2",
        "kind": "value",
        "name": "every2",
        "docstrings": [
          "`every2(list1, list2, f)` returns `true` if predicate `f` is `true` for all\npairs of elements up to the shorter length (i.e. `min(length(list1), length(list2))`)\n\n## Examples\n\n```rescript\nList.every2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) // true\n\nList.every2(list{}, list{1}, (a, b) => a > b) // true\n\nList.every2(list{2, 3}, list{1}, (a, b) => a > b) // true\n\nList.every2(list{0, 1}, list{5, 0}, (a, b) => a > b) // false\n```"
        ],
        "signature": "let every2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.List.some2",
        "kind": "value",
        "name": "some2",
        "docstrings": [
          "`some2(list1, list2, f)` returns `true` if predicate `f` is `true` for any pair\nof elements up to the shorter length (i.e. `min(length(list1), length(list2))`)\n\n## Examples\n\n```rescript\nList.some2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) // true\n\nList.some2(list{}, list{1}, (a, b) => a > b) // false\n\nList.some2(list{2, 3}, list{1}, (a, b) => a > b) // true\n\nList.some2(list{0, 1}, list{5, 0}, (a, b) => a > b) // true\n```"
        ],
        "signature": "let some2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.List.compareLength",
        "kind": "value",
        "name": "compareLength",
        "docstrings": [
          "`compareLength(list1, list2)` compare two lists solely by length. Returns `-1.` if\n`length(list1)` is less than `length(list2)`, `0.` if `length(list1)` equals\n`length(list2)`, and `1.` if `length(list1)` is greater than `length(list2)`.\n\n## Examples\n\n```rescript\nList.compareLength(list{1, 2}, list{3, 4, 5, 6}) // -1.\n\nList.compareLength(list{1, 2, 3}, list{4, 5, 6}) // 0.\n\nList.compareLength(list{1, 2, 3, 4}, list{5, 6}) // 1.\n```"
        ],
        "signature": "let compareLength: (t<'a>, t<'a>) => Core__Ordering.t"
      },
      {
        "id": "Core.List.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [
          "`compare(list1, list2, f)` compare elements one by one `f`. `f` returns a negative\nnumber if `list1` is \"less than\" `list2`, zero if `list1` is \"equal to\" `list2`,\na positive number if `list1` is \"greater than\" `list2`.\n\nThe comparison returns the first non-zero result of `f`, or zero if `f` returns\nzero for all `list1` and `list2`.\n\n- If all items have compared equal, but `list1` is exhausted first, return `-1.`. (`list1` is shorter).\n- If all items have compared equal, but `list2` is exhausted first, return `1.` (`list1` is longer).\n\n## Examples\n\n```rescript\nList.compare(list{3}, list{3, 7}, (a, b) => Int.compare(a, b)) // -1.\nList.compare(list{5, 3}, list{5}, (a, b) => Int.compare(a, b)) // 1.\nList.compare(list{1, 3, 5}, list{1, 4, 2}, (a, b) => Int.compare(a, b)) // -1.\nList.compare(list{1, 3, 5}, list{1, 2, 3}, (a, b) => Int.compare(a, b)) // 1.\nList.compare(list{1, 3, 5}, list{1, 3, 5}, (a, b) => Int.compare(a, b)) // 0.\n```\n\n**Please note:** The total ordering of List is different from Array,\nfor Array, we compare the length first and, only if the lengths are equal, elements one by one.\nFor lists, we just compare elements one by one."
        ],
        "signature": "let compare: (\n  t<'a>,\n  t<'a>,\n  ('a, 'a) => Core__Ordering.t,\n) => Core__Ordering.t"
      },
      {
        "id": "Core.List.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [
          "`equal(list1, list2, f)` check equality of `list2` and `list2` using `f` for\nequality on elements, where `f` is a function that returns `true` if items `x` and\n`y` meet some criterion for equality, `false` otherwise. equal `false` if length\nof `list1` and `list2` are not the same.\n\n## Examples\n\n```rescript\nList.equal(list{1, 2, 3}, list{1, 2}, (a, b) => a == b) // false\n\nList.equal(list{1, 2}, list{1, 2}, (a, b) => a == b) // true\n\nList.equal(list{1, 2, 3}, list{(-1), (-2), (-3)}, (a, b) => abs(a) == abs(b)) // true\n```"
        ],
        "signature": "let equal: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Core.List.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "`has(list, element, f)` returns `true` if the list contains at least one\n`element` for which `f` returns `true'.\n\n## Examples\n\n```rescript\nlist{1, 2, 3}->List.has(2, (a, b) => a == b) // true\n\nlist{1, 2, 3}->List.has(4, (a, b) => a == b) // false\n\nlist{(-1), (-2), (-3)}->List.has(2, (a, b) => abs(a) == abs(b)) // true\n```"
        ],
        "signature": "let has: (t<'a>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.List.find",
        "kind": "value",
        "name": "find",
        "docstrings": [
          "`find(list, f)` returns `Some(value)` for the first value in `list` that\nsatisfies the predicate function `f`. Returns `None` if no element satisfies\nthe function.\n\n## Examples\n\n```rescript\nList.find(list{1, 4, 3, 2}, x => x > 3) // Some(4)\n\nList.find(list{1, 4, 3, 2}, x => x > 4) // None\n```"
        ],
        "signature": "let find: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Core.List.filter",
        "kind": "value",
        "name": "filter",
        "docstrings": [
          "`filter(list, f)` returns a list of all elements in `list` which satisfy the\npredicate function `f`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nList.filter(list{1, 2, 3, 4}, isEven) // list{2, 4}\n\nList.filter(list{None, Some(2), Some(3), None}, Option.isSome) // list{Some(2), Some(3)}\n```"
        ],
        "signature": "let filter: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Core.List.filterWithIndex",
        "kind": "value",
        "name": "filterWithIndex",
        "docstrings": [
          "`filterWithIndex(list, f)` returns a list of all elements in `list` which\nsatisfy the predicate function `f`.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nList.filterWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) // list{1, 3}\n```"
        ],
        "signature": "let filterWithIndex: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Core.List.filterMap",
        "kind": "value",
        "name": "filterMap",
        "docstrings": [
          "`filterMap(list, f)` applies `f` to each element of `list`. If `f` returns\n`Some(value)`, then `value` is _kept_ in the resulting list. If `f` returns\n`None`, the element is _not_ retained in the result.\n\n## Examples\n\n```rescript\nlet isEven = x => mod(x, 2) == 0\n\nlist{1, 2, 3, 4}\n->List.filterMap(x =>\n    if (isEven(x)) {\n      Some(x)\n    } else {\n      None\n    }\n  ) // list{2, 4}\n\nlist{Some(1), Some(2), None}->List.filterMap(x => x) // list{1, 2}\n```"
        ],
        "signature": "let filterMap: (t<'a>, 'a => option<'b>) => t<'b>"
      },
      {
        "id": "Core.List.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(list, f)` creates a pair of lists; the first list consists of all\nelements of `list` that satisfy the predicate function `f`, the second list\nconsists of all elements of `list` that _do not_ satisfy `f`.\n\n## Examples\n\n```rescript\n// (elementsThatSatisfies, elementsThatDoesNotSatisfy)\n\nList.partition(list{1, 2, 3, 4}, x => x > 2) // (list{3, 4}, list{1, 2})\n```"
        ],
        "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Core.List.unzip",
        "kind": "value",
        "name": "unzip",
        "docstrings": [
          "`unzip(list)` takes a list of pairs and creates a pair of lists. The first list\ncontains all the first items of the pairs, the second list contains all the\nsecond items.\n\n## Examples\n\n```rescript\nList.unzip(list{(1, 2), (3, 4)}) // (list{1, 3}, list{2, 4})\n\nList.unzip(list{(\"H\", \"W\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"l\", \"l\"), (\"o\", \"d\"), (\" \", \"!\")})\n// (list{\"H\", \"e\", \"l\", \"l\", \"o\", \" \"}, list{\"W\", \"o\", \"r\", \"l\", \"d\", \"!\"})\n```"
        ],
        "signature": "let unzip: t<('a, 'b)> => (t<'a>, t<'b>)"
      },
      {
        "id": "Core.List.getAssoc",
        "kind": "value",
        "name": "getAssoc",
        "docstrings": [
          "`getAssoc(list, k, f)` return the second element of a pair in `list` where\nthe first element equals `k` as per the predicate function `f`, or `None` if\nnot found.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.getAssoc(3, (a, b) => a == b) // Some(\"c\")\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->List.getAssoc(15, (k, item) => k /* 15 */ == item /* 9, 5, 22 */)\n// Some(\"afternoon\")\n```"
        ],
        "signature": "let getAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => option<'c>"
      },
      {
        "id": "Core.List.hasAssoc",
        "kind": "value",
        "name": "hasAssoc",
        "docstrings": [
          "`hasAssoc(list, k, f)` returns `true` if there is a pair in `list` where the\nfirst element equals `k` as per the predicate function `f`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.hasAssoc(1, (a, b) => a == b) // true\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->List.hasAssoc(25, (k, item) => k /* 25 */ == item /* 9, 5, 22 */) // false\n```"
        ],
        "signature": "let hasAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.List.removeAssoc",
        "kind": "value",
        "name": "removeAssoc",
        "docstrings": [
          "`removeAssoc(list, k, f)` return a list after removing the first pair whose\nfirst value is `k` per the equality predicate `f`, if not found, return a new\nlist identical to `list`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.removeAssoc(1, (a, b) => a == b) // list{(2, \"b\"), (3, \"c\")}\n\nlist{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n->List.removeAssoc(9, (k, item) => k /* 9 */ == item /* 9, 5, 22 */)\n// list{(15, \"afternoon\"), (22, \"night\")}\n```"
        ],
        "signature": "let removeAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Core.List.setAssoc",
        "kind": "value",
        "name": "setAssoc",
        "docstrings": [
          "`setAssoc(list, k, v, f)`. If `k` exists in `list` by satisfying the `f`\npredicate, return a new list with the key and value replaced by the new `k` and\n`v`, otherwise, return a new list with the pair `k`, `v` added to the head of\n`list`.\n\n## Examples\n\n```rescript\nlist{(1, \"a\"), (2, \"b\"), (3, \"c\")}->List.setAssoc(2, \"x\", (a, b) => a == b) // list{(1, \"a\"), (2, \"x\"), (3, \"c\")}\n\nlist{(1, \"a\"), (3, \"c\")}->List.setAssoc(2, \"b\", (a, b) => a == b) // list{(2, \"b\"), (1, \"a\"), (3, \"c\")}\n\nlist{(9, \"morning\"), (3, \"morning?!\"), (22, \"night\")}\n->List.setAssoc(15, \"afternoon\", (a, b) => mod(a, 12) == mod(b, 12))\n// list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n```\n\n**Please note**: In the last example, since: `15 mod 12` equals `3 mod 12`. Both\nthe key _and_ the value are replaced in the list."
        ],
        "signature": "let setAssoc: (t<('a, 'c)>, 'a, 'c, ('a, 'a) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Core.List.sort",
        "kind": "value",
        "name": "sort",
        "docstrings": [
          "`sort(list, f)` returns a sorted list.\n\n## Examples\n\n```rescript\nList.sort(list{5, 4, 9, 3, 7}, Int.compare) // list{3, 4, 5, 7, 9}\n```"
        ],
        "signature": "let sort: (t<'a>, ('a, 'a) => Core__Ordering.t) => t<'a>"
      }
    ]
  },
  "core/option": {
    "id": "Core.Option",
    "name": "Option",
    "docstrings": [
      "We represent the existence and nonexistence of a value by wrapping it with\nthe `option` type. In order to make it a bit more convenient to work with\noption-types, we provide utility-functions for it.\n\nThe `option` type is a part of the ReScript standard library which is defined\nlike this:\n\n```rescript\ntype option<'a> = None | Some('a)\n```\n\n```rescript\nlet someString: option<string> = Some(\"hello\")\n```"
    ],
    "items": [
      {
        "id": "Core.Option.filter",
        "kind": "value",
        "name": "filter",
        "docstrings": [
          "`filter(opt, f)` applies `f` to `opt`, if `f` returns `true`, then it returns `Some(value)`, otherwise returns `None`.\n\n## Examples\n\n```rescript\nOption.filter(Some(10), x => x > 5) // Some(10)\nOption.filter(Some(4), x => x > 5) // None\nOption.filter(None, x => x > 5) // None\n```"
        ],
        "signature": "let filter: (option<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Core.Option.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(opt, f)` call `f` on `opt`. if `opt` is `Some(value)`, then if calls\n`f`, otherwise returns `unit`.\n\n## Examples\n\n```rescript\nOption.forEach(Some(\"thing\"), x => Console.log(x)) // logs \"thing\"\nOption.forEach(None, x => Console.log(x)) // returns ()\n```"
        ],
        "signature": "let forEach: (option<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.Option.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(opt, ~message=?)` returns `value` if `opt` is `Some(value)`, otherwise raises an exception with the message provided, or a generic message if no message was provided.\n\n```rescript\nOption.getExn(Some(3)) // 3\nOption.getExn(None) /* Raises an Error */\nOption.getExn(None, ~message=\"was None!\") /* Raises an Error with the message \"was None!\" */\n```\n\n## Exceptions\n\n- Raises an error if `opt` is `None`"
        ],
        "signature": "let getExn: (option<'a>, ~message: string=?) => 'a"
      },
      {
        "id": "Core.Option.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(opt)` returns `value` if `opt` is `Some(value)`, otherwise `undefined`.\n\n## Examples\n\n```rescript\nOption.getUnsafe(Some(3)) == 3\nOption.getUnsafe(None: option<int>) // Returns `undefined`, which is not a valid `int`\n```\n\n## Notes\n\n- This is an unsafe operation. It assumes `value` is not `None`, and may cause undefined behaviour if it is."
        ],
        "signature": "let getUnsafe: option<'a> => 'a"
      },
      {
        "id": "Core.Option.mapOr",
        "kind": "value",
        "name": "mapOr",
        "docstrings": [
          "`mapOr(opt, default, f)` returns `f(value)` if `opt` is `Some(value)`, otherwise `default`.\n\n## Examples\n\n```rescript\nlet someValue = Some(3)\nsomeValue->Option.mapOr(0, x => x + 5) // 8\n\nlet noneValue = None\nnoneValue->Option.mapOr(0, x => x + 5) // 0\n```"
        ],
        "signature": "let mapOr: (option<'a>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Core.Option.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [],
        "signature": "let mapWithDefault: (option<'a>, 'b, 'a => 'b) => 'b",
        "deprecated": "Use mapOr instead"
      },
      {
        "id": "Core.Option.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(opt, f)` returns `Some(f(value))` if `opt` is `Some(value)`, otherwise `None`.\n\n## Examples\n\n```rescript\nOption.map(Some(3), x => x * x) // Some(9)\nOption.map(None, x => x * x) // None\n```"
        ],
        "signature": "let map: (option<'a>, 'a => 'b) => option<'b>"
      },
      {
        "id": "Core.Option.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(opt, f)` returns `f(value)` if `opt` is `Some(value)`, otherwise `None`.\n\n## Examples\n\n```rescript\nlet addIfAboveOne = value =>\n  if (value > 1) {\n    Some(value + 1)\n  } else {\n    None\n  }\n\nOption.flatMap(Some(2), addIfAboveOne) // Some(3)\nOption.flatMap(Some(-4), addIfAboveOne) // None\nOption.flatMap(None, addIfAboveOne) // None\n```"
        ],
        "signature": "let flatMap: (option<'a>, 'a => option<'b>) => option<'b>"
      },
      {
        "id": "Core.Option.getOr",
        "kind": "value",
        "name": "getOr",
        "docstrings": [
          "`getOr(opt, default)` returns `value` if `opt` is `Some(value)`, otherwise `default`.\n\n## Examples\n\n```rescript\nOption.getOr(None, \"Banana\") // Banana\nOption.getOr(Some(\"Apple\"), \"Banana\") // Apple\n\nlet greet = (firstName: option<string>) =>\n  \"Greetings \" ++ firstName->Option.getOr(\"Anonymous\")\n\nSome(\"Jane\")->greet // \"Greetings Jane\"\nNone->greet // \"Greetings Anonymous\"\n```"
        ],
        "signature": "let getOr: (option<'a>, 'a) => 'a"
      },
      {
        "id": "Core.Option.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (option<'a>, 'a) => 'a",
        "deprecated": "Use getOr instead"
      },
      {
        "id": "Core.Option.orElse",
        "kind": "value",
        "name": "orElse",
        "docstrings": [
          "`orElse(opt1, opt2)` returns `opt2` if `opt1` is `None`, otherwise `opt1`.\n\n## Examples\n\n```rescript\nOption.orElse(Some(1812), Some(1066)) == Some(1812)\nOption.orElse(None, Some(1066)) == Some(1066)\nOption.orElse(None, None) == None\n```"
        ],
        "signature": "let orElse: (option<'a>, option<'a>) => option<'a>"
      },
      {
        "id": "Core.Option.isSome",
        "kind": "value",
        "name": "isSome",
        "docstrings": [
          "`isSome(opt)` returns `true` if `opt` is `Some(value)`, otherwise returns `false`.\n\n## Examples\n\n```rescript\nOption.isSome(None) // false\nOption.isSome(Some(1)) // true\n```"
        ],
        "signature": "let isSome: option<'a> => bool"
      },
      {
        "id": "Core.Option.isNone",
        "kind": "value",
        "name": "isNone",
        "docstrings": [
          "`isNone(opt)` returns `true` if `opt` is `None`, false otherwise.\n\n## Examples\n\n```rescript\nOption.isNone(None) // true\nOption.isNone(Some(1)) // false\n```"
        ],
        "signature": "let isNone: option<'a> => bool"
      },
      {
        "id": "Core.Option.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [
          "`equal(opt1, opt2, f)` evaluates two optional values for equality with respect to a predicate function `f`. If both `opt1` and `opt2` are `None`, returns `true`.\nIf one of the arguments is `Some(value)` and the other is `None`, returns\n`false`.\nIf arguments are `Some(value1)` and `Some(value2)`, returns the result of\n`f(value1, value2)`, the predicate function `f` must return a bool.\n\n## Examples\n\n```rescript\nlet clockEqual = (a, b) => mod(a, 12) == mod(b, 12)\n\nopen Option\n\nequal(Some(3), Some(15), clockEqual) // true\nequal(Some(3), None, clockEqual) // false\nequal(None, Some(3), clockEqual) // false\nequal(None, None, clockEqual) // true\n```"
        ],
        "signature": "let equal: (option<'a>, option<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.Option.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [
          "`compare(opt1, opt2, f)` compares two optional values with respect to given `f`.\n\nIf both `opt1` and `opt2` are `None`, it returns `0.`. If the first argument is `Some(value1)` and the second is `None`, returns `1.` (something is greater than nothing).\n\nIf the first argument is `None` and the second is `Some(value2)`, returns `-1.`\n(nothing is less than something).\n\nIf the arguments are `Some(value1)` and `Some(value2)`, returns the result of\n`f(value1, value2)`, `f` takes two arguments and returns `-1.` if the first\nargument is less than the second, `0.` if the arguments are equal, and `1.` if\nthe first argument is greater than the second.\n\n## Examples\n\n```rescript\nlet clockCompare = (a, b) => Int.compare(mod(a, 12), mod(b, 12))\n\nOption.compare(Some(3), Some(15), clockCompare) // 0.\nOption.compare(Some(3), Some(14), clockCompare) // 1.\nOption.compare(Some(2), Some(15), clockCompare) // (-1.)\nOption.compare(None, Some(15), clockCompare) // (-1.)\nOption.compare(Some(14), None, clockCompare) // 1.\nOption.compare(None, None, clockCompare) // 0.\n```"
        ],
        "signature": "let compare: (\n  option<'a>,\n  option<'b>,\n  ('a, 'b) => Core__Ordering.t,\n) => Core__Ordering.t"
      }
    ]
  },
  "core/exn": {
    "id": "Core.Exn",
    "name": "Exn",
    "docstrings": [],
    "items": []
  },
  "core/intl": {
    "id": "Core.Intl",
    "name": "Intl",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Intl.getCanonicalLocalesExn",
        "kind": "value",
        "name": "getCanonicalLocalesExn",
        "docstrings": [
          "@throws RangeError"
        ],
        "signature": "let getCanonicalLocalesExn: string => array<string>"
      },
      {
        "id": "Core.Intl.getCanonicalLocalesManyExn",
        "kind": "value",
        "name": "getCanonicalLocalesManyExn",
        "docstrings": [
          "@throws RangeError"
        ],
        "signature": "let getCanonicalLocalesManyExn: array<string> => array<string>"
      },
      {
        "id": "Core.Intl.supportedValuesOfExn",
        "kind": "value",
        "name": "supportedValuesOfExn",
        "docstrings": [
          "@throws RangeError"
        ],
        "signature": "let supportedValuesOfExn: string => array<string>"
      }
    ]
  },
  "core/biguint64array": {
    "id": "Core.BigUint64Array",
    "name": "BigUint64Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.BigUint64Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `BigUint64Array` typed array represents an array of 64-bit unsigned integers in platform byte order. See [BigUint64Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array)"
        ],
        "signature": "type t = Core__TypedArray.t<bigint>"
      },
      {
        "id": "Core.BigUint64Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `BigUint64Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)"
        ],
        "signature": "let fromArray: array<bigint> => t"
      },
      {
        "id": "Core.BigUint64Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `BigUint64Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.BigUint64Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `BigUint64Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.BigUint64Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `BigUint64Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.BigUint64Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `BigUint64Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array/BigUint64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.BigUint64Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `BigUint64Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.BigUint64Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `BigUint64Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => bigint) => t"
      }
    ]
  },
  "core/bigint64array": {
    "id": "Core.BigInt64Array",
    "name": "BigInt64Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.BigInt64Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `BigInt64Array` typed array represents an array of 64-bit signed integers in platform byte order. See [BigInt64Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array)"
        ],
        "signature": "type t = Core__TypedArray.t<bigint>"
      },
      {
        "id": "Core.BigInt64Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `BigInt64Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)"
        ],
        "signature": "let fromArray: array<bigint> => t"
      },
      {
        "id": "Core.BigInt64Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `BigInt64Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.BigInt64Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `BigInt64Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.BigInt64Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `BigInt64Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.BigInt64Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `BigInt64Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array/BigInt64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.BigInt64Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `BigInt64Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.BigInt64Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `BigInt64Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => bigint) => t"
      }
    ]
  },
  "core/uint8clampedarray": {
    "id": "Core.Uint8ClampedArray",
    "name": "Uint8ClampedArray",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint8ClampedArray.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Uint8ClampedArray` typed array represents an array of 8-bit unsigned integers clamped to 0-255. See [Uint8ClampedArray on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray)"
        ],
        "signature": "type t = Core__TypedArray.t<int>"
      },
      {
        "id": "Core.Uint8ClampedArray.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Uint8ClampedArray` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)"
        ],
        "signature": "let fromArray: array<int> => t"
      },
      {
        "id": "Core.Uint8ClampedArray.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Uint8ClampedArray` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Uint8ClampedArray.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Uint8ClampedArray` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Uint8ClampedArray.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Uint8ClampedArray` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Uint8ClampedArray.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Uint8ClampedArray` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray/Uint8ClampedArray)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Uint8ClampedArray.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Uint8ClampedArray` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Uint8ClampedArray.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Uint8ClampedArray` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t"
      }
    ]
  },
  "core/uint32array": {
    "id": "Core.Uint32Array",
    "name": "Uint32Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint32Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Uint32Array` typed array represents an array of 32-bit unsigned integers in platform byte order. See [Uint32Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array)"
        ],
        "signature": "type t = Core__TypedArray.t<int>"
      },
      {
        "id": "Core.Uint32Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Uint32Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)"
        ],
        "signature": "let fromArray: array<int> => t"
      },
      {
        "id": "Core.Uint32Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Uint32Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Uint32Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Uint32Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Uint32Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Uint32Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Uint32Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Uint32Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array/Uint32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Uint32Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Uint32Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Uint32Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Uint32Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t"
      }
    ]
  },
  "core/uint16array": {
    "id": "Core.Uint16Array",
    "name": "Uint16Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint16Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Uint16Array` typed array represents an array of 16-bit unsigned integers in platform byte order. See [Uint16Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array)"
        ],
        "signature": "type t = Core__TypedArray.t<int>"
      },
      {
        "id": "Core.Uint16Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Uint16Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)"
        ],
        "signature": "let fromArray: array<int> => t"
      },
      {
        "id": "Core.Uint16Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Uint16Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Uint16Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Uint16Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Uint16Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Uint16Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Uint16Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Uint16Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array/Uint16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Uint16Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Uint16Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Uint16Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Uint16Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t"
      }
    ]
  },
  "core/uint8array": {
    "id": "Core.Uint8Array",
    "name": "Uint8Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Uint8Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Uint8Array` typed array represents an array of 8-bit unsigned integers. See [Uint8Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)"
        ],
        "signature": "type t = Core__TypedArray.t<int>"
      },
      {
        "id": "Core.Uint8Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Uint8Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)"
        ],
        "signature": "let fromArray: array<int> => t"
      },
      {
        "id": "Core.Uint8Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Uint8Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Uint8Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Uint8Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Uint8Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Uint8Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Uint8Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Uint8Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/Uint8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Uint8Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Uint8Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Uint8Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Uint8Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t"
      }
    ]
  },
  "core/int32array": {
    "id": "Core.Int32Array",
    "name": "Int32Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Int32Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Int32Array` typed array represents an array of twos-complemenet 32-bit signed integers in platform byte order. See [Int32Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array)"
        ],
        "signature": "type t = Core__TypedArray.t<int>"
      },
      {
        "id": "Core.Int32Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Int32Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)"
        ],
        "signature": "let fromArray: array<int> => t"
      },
      {
        "id": "Core.Int32Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Int32Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Int32Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Int32Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Int32Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Int32Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Int32Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Int32Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array/Int32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Int32Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Int32Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Int32Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Int32Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t"
      }
    ]
  },
  "core/int16array": {
    "id": "Core.Int16Array",
    "name": "Int16Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Int16Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Int16Array` typed array represents an array of twos-complement 16-bit signed integers in platform byte order. See [Int16Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array)"
        ],
        "signature": "type t = Core__TypedArray.t<int>"
      },
      {
        "id": "Core.Int16Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Int16Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)"
        ],
        "signature": "let fromArray: array<int> => t"
      },
      {
        "id": "Core.Int16Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Int16Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Int16Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Int16Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Int16Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Int16Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Int16Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Int16Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array/Int16Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Int16Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Int16Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Int16Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Int16Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t"
      }
    ]
  },
  "core/int8array": {
    "id": "Core.Int8Array",
    "name": "Int8Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Int8Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Int8Array` typed array represents an array of twos-complement 8-bit signed integers. See [Int8Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array)"
        ],
        "signature": "type t = Core__TypedArray.t<int>"
      },
      {
        "id": "Core.Int8Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Int8Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)"
        ],
        "signature": "let fromArray: array<int> => t"
      },
      {
        "id": "Core.Int8Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Int8Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Int8Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Int8Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Int8Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Int8Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Int8Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Int8Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array/Int8Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Int8Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Int8Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Int8Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Int8Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => int) => t"
      }
    ]
  },
  "core/float64array": {
    "id": "Core.Float64Array",
    "name": "Float64Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Float64Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Float64Array` typed array represents an array of 64-bit floating point numbers in platform byte order. See [Float64Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array)"
        ],
        "signature": "type t = Core__TypedArray.t<float>"
      },
      {
        "id": "Core.Float64Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Float64Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)"
        ],
        "signature": "let fromArray: array<float> => t"
      },
      {
        "id": "Core.Float64Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Float64Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Float64Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Float64Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Float64Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Float64Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Float64Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Float64Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array/Float64Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Float64Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Float64Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Float64Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Float64Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => float) => t"
      }
    ]
  },
  "core/float32array": {
    "id": "Core.Float32Array",
    "name": "Float32Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Float32Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The `Float32Array` typed array represents an array of 32-bit floating point numbers in platform byte order. See [Float32Array on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array)"
        ],
        "signature": "type t = Core__TypedArray.t<float>"
      },
      {
        "id": "Core.Float32Array.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` creates a `Float32Array` from an array of values. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)"
        ],
        "signature": "let fromArray: array<float> => t"
      },
      {
        "id": "Core.Float32Array.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [
          "`fromBuffer` creates a `Float32Array` from an `ArrayBuffer.t`. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.Float32Array.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [
          "`fromBufferToEnd` creates a `Float32Array` from an `ArrayBuffer.t`, starting at a particular offset and continuing through to the end. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.Float32Array.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [
          "`fromBufferWithRange` creates a `Float32Array` from an `ArrayBuffer.t`, starting at a particular offset and consuming `length` **bytes**. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.Float32Array.fromLength",
        "kind": "value",
        "name": "fromLength",
        "docstrings": [
          "`fromLength` creates a zero-initialized `Float32Array` to hold the specified count of numbers; this is **not** a byte length. See [TypedArray constructor on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array/Float32Array)\n\n**Note:** This is a potentially unsafe operation. Ensure the buffer is large enough and only accessed within its bounds."
        ],
        "signature": "let fromLength: int => t"
      },
      {
        "id": "Core.Float32Array.fromArrayLikeOrIterable",
        "kind": "value",
        "name": "fromArrayLikeOrIterable",
        "docstrings": [
          "`fromArrayLikeOrIterable` creates a `Float32Array` from an array-like or iterable object. See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterable: 'a => t"
      },
      {
        "id": "Core.Float32Array.fromArrayLikeOrIterableWithMap",
        "kind": "value",
        "name": "fromArrayLikeOrIterableWithMap",
        "docstrings": [
          "`fromArrayLikeOrIterableWithMap` creates a `Float32Array` from an array-like or iterable object and applies the mapping function to each item. The mapping function expects (value, index). See [TypedArray.from on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)"
        ],
        "signature": "let fromArrayLikeOrIterableWithMap: ('a, ('b, int) => float) => t"
      }
    ]
  },
  "core/typedarray": {
    "id": "Core.TypedArray",
    "name": "TypedArray",
    "docstrings": [],
    "items": [
      {
        "id": "Core.TypedArray.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a>"
      },
      {
        "id": "Core.TypedArray.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, int) => option<'a>"
      },
      {
        "id": "Core.TypedArray.set",
        "kind": "value",
        "name": "set",
        "docstrings": [],
        "signature": "let set: (t<'a>, int, 'a) => unit"
      },
      {
        "id": "Core.TypedArray.buffer",
        "kind": "value",
        "name": "buffer",
        "docstrings": [],
        "signature": "let buffer: t<'a> => Core__ArrayBuffer.t"
      },
      {
        "id": "Core.TypedArray.byteLength",
        "kind": "value",
        "name": "byteLength",
        "docstrings": [],
        "signature": "let byteLength: t<'a> => int"
      },
      {
        "id": "Core.TypedArray.byteOffset",
        "kind": "value",
        "name": "byteOffset",
        "docstrings": [],
        "signature": "let byteOffset: t<'a> => int"
      },
      {
        "id": "Core.TypedArray.setArray",
        "kind": "value",
        "name": "setArray",
        "docstrings": [],
        "signature": "let setArray: (t<'a>, array<'a>) => unit"
      },
      {
        "id": "Core.TypedArray.setArrayFrom",
        "kind": "value",
        "name": "setArrayFrom",
        "docstrings": [],
        "signature": "let setArrayFrom: (t<'a>, array<'a>, int) => unit"
      },
      {
        "id": "Core.TypedArray.length",
        "kind": "value",
        "name": "length",
        "docstrings": [],
        "signature": "let length: t<'a> => int"
      },
      {
        "id": "Core.TypedArray.copyAllWithin",
        "kind": "value",
        "name": "copyAllWithin",
        "docstrings": [],
        "signature": "let copyAllWithin: (t<'a>, ~target: int) => array<'a>"
      },
      {
        "id": "Core.TypedArray.copyWithinToEnd",
        "kind": "value",
        "name": "copyWithinToEnd",
        "docstrings": [],
        "signature": "let copyWithinToEnd: (t<'a>, ~target: int, ~start: int) => array<'a>"
      },
      {
        "id": "Core.TypedArray.copyWithin",
        "kind": "value",
        "name": "copyWithin",
        "docstrings": [],
        "signature": "let copyWithin: (t<'a>, ~target: int, ~start: int, ~end: int) => array<'a>"
      },
      {
        "id": "Core.TypedArray.fillAll",
        "kind": "value",
        "name": "fillAll",
        "docstrings": [],
        "signature": "let fillAll: (t<'a>, 'a) => t<'a>"
      },
      {
        "id": "Core.TypedArray.fillToEnd",
        "kind": "value",
        "name": "fillToEnd",
        "docstrings": [],
        "signature": "let fillToEnd: (t<'a>, 'a, ~start: int) => t<'a>"
      },
      {
        "id": "Core.TypedArray.fill",
        "kind": "value",
        "name": "fill",
        "docstrings": [],
        "signature": "let fill: (t<'a>, 'a, ~start: int, ~end: int) => t<'a>"
      },
      {
        "id": "Core.TypedArray.reverse",
        "kind": "value",
        "name": "reverse",
        "docstrings": [],
        "signature": "let reverse: t<'a> => unit"
      },
      {
        "id": "Core.TypedArray.toReversed",
        "kind": "value",
        "name": "toReversed",
        "docstrings": [],
        "signature": "let toReversed: t<'a> => t<'a>"
      },
      {
        "id": "Core.TypedArray.sort",
        "kind": "value",
        "name": "sort",
        "docstrings": [],
        "signature": "let sort: (t<'a>, ('a, 'a) => Core__Ordering.t) => unit"
      },
      {
        "id": "Core.TypedArray.toSorted",
        "kind": "value",
        "name": "toSorted",
        "docstrings": [],
        "signature": "let toSorted: (t<'a>, ('a, 'a) => Core__Ordering.t) => t<'a>"
      },
      {
        "id": "Core.TypedArray.with",
        "kind": "value",
        "name": "with",
        "docstrings": [],
        "signature": "let with: (t<'a>, int, 'a) => t<'a>"
      },
      {
        "id": "Core.TypedArray.includes",
        "kind": "value",
        "name": "includes",
        "docstrings": [],
        "signature": "let includes: (t<'a>, 'a) => bool"
      },
      {
        "id": "Core.TypedArray.indexOf",
        "kind": "value",
        "name": "indexOf",
        "docstrings": [],
        "signature": "let indexOf: (t<'a>, 'a) => int"
      },
      {
        "id": "Core.TypedArray.indexOfFrom",
        "kind": "value",
        "name": "indexOfFrom",
        "docstrings": [],
        "signature": "let indexOfFrom: (t<'a>, 'a, int) => int"
      },
      {
        "id": "Core.TypedArray.joinWith",
        "kind": "value",
        "name": "joinWith",
        "docstrings": [],
        "signature": "let joinWith: (t<'a>, string) => string"
      },
      {
        "id": "Core.TypedArray.lastIndexOf",
        "kind": "value",
        "name": "lastIndexOf",
        "docstrings": [],
        "signature": "let lastIndexOf: (t<'a>, 'a) => int"
      },
      {
        "id": "Core.TypedArray.lastIndexOfFrom",
        "kind": "value",
        "name": "lastIndexOfFrom",
        "docstrings": [],
        "signature": "let lastIndexOfFrom: (t<'a>, 'a, int) => int"
      },
      {
        "id": "Core.TypedArray.slice",
        "kind": "value",
        "name": "slice",
        "docstrings": [],
        "signature": "let slice: (t<'a>, ~start: int, ~end: int) => t<'a>"
      },
      {
        "id": "Core.TypedArray.sliceToEnd",
        "kind": "value",
        "name": "sliceToEnd",
        "docstrings": [],
        "signature": "let sliceToEnd: (t<'a>, ~start: int) => t<'a>"
      },
      {
        "id": "Core.TypedArray.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Core.TypedArray.subarray",
        "kind": "value",
        "name": "subarray",
        "docstrings": [],
        "signature": "let subarray: (t<'a>, ~start: int, ~end: int) => t<'a>"
      },
      {
        "id": "Core.TypedArray.subarrayToEnd",
        "kind": "value",
        "name": "subarrayToEnd",
        "docstrings": [],
        "signature": "let subarrayToEnd: (t<'a>, ~start: int) => t<'a>"
      },
      {
        "id": "Core.TypedArray.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [],
        "signature": "let toString: t<'a> => string"
      },
      {
        "id": "Core.TypedArray.toLocaleString",
        "kind": "value",
        "name": "toLocaleString",
        "docstrings": [],
        "signature": "let toLocaleString: t<'a> => string"
      },
      {
        "id": "Core.TypedArray.every",
        "kind": "value",
        "name": "every",
        "docstrings": [],
        "signature": "let every: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Core.TypedArray.everyWithIndex",
        "kind": "value",
        "name": "everyWithIndex",
        "docstrings": [],
        "signature": "let everyWithIndex: (t<'a>, ('a, int) => bool) => bool"
      },
      {
        "id": "Core.TypedArray.filter",
        "kind": "value",
        "name": "filter",
        "docstrings": [],
        "signature": "let filter: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Core.TypedArray.filterWithIndex",
        "kind": "value",
        "name": "filterWithIndex",
        "docstrings": [],
        "signature": "let filterWithIndex: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Core.TypedArray.find",
        "kind": "value",
        "name": "find",
        "docstrings": [],
        "signature": "let find: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Core.TypedArray.findWithIndex",
        "kind": "value",
        "name": "findWithIndex",
        "docstrings": [],
        "signature": "let findWithIndex: (t<'a>, ('a, int) => bool) => option<'a>"
      },
      {
        "id": "Core.TypedArray.findIndex",
        "kind": "value",
        "name": "findIndex",
        "docstrings": [],
        "signature": "let findIndex: (t<'a>, 'a => bool) => int"
      },
      {
        "id": "Core.TypedArray.findIndexWithIndex",
        "kind": "value",
        "name": "findIndexWithIndex",
        "docstrings": [],
        "signature": "let findIndexWithIndex: (t<'a>, ('a, int) => bool) => int"
      },
      {
        "id": "Core.TypedArray.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.TypedArray.forEachWithIndex",
        "kind": "value",
        "name": "forEachWithIndex",
        "docstrings": [],
        "signature": "let forEachWithIndex: (t<'a>, ('a, int) => unit) => unit"
      },
      {
        "id": "Core.TypedArray.map",
        "kind": "value",
        "name": "map",
        "docstrings": [],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Core.TypedArray.mapWithIndex",
        "kind": "value",
        "name": "mapWithIndex",
        "docstrings": [],
        "signature": "let mapWithIndex: (t<'a>, ('a, int) => 'b) => t<'b>"
      },
      {
        "id": "Core.TypedArray.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t<'a>, ('b, 'a) => 'b, 'b) => 'b"
      },
      {
        "id": "Core.TypedArray.reduceWithIndex",
        "kind": "value",
        "name": "reduceWithIndex",
        "docstrings": [],
        "signature": "let reduceWithIndex: (t<'a>, ('b, 'a, int) => 'b, 'b) => 'b"
      },
      {
        "id": "Core.TypedArray.reduceRight",
        "kind": "value",
        "name": "reduceRight",
        "docstrings": [],
        "signature": "let reduceRight: (t<'a>, ('b, 'a) => 'b, 'b) => 'b"
      },
      {
        "id": "Core.TypedArray.reduceRightWithIndex",
        "kind": "value",
        "name": "reduceRightWithIndex",
        "docstrings": [],
        "signature": "let reduceRightWithIndex: (t<'a>, ('b, 'a, int) => 'b, 'b) => 'b"
      },
      {
        "id": "Core.TypedArray.some",
        "kind": "value",
        "name": "some",
        "docstrings": [],
        "signature": "let some: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Core.TypedArray.someWithIndex",
        "kind": "value",
        "name": "someWithIndex",
        "docstrings": [],
        "signature": "let someWithIndex: (t<'a>, ('a, int) => bool) => bool"
      }
    ]
  },
  "core/arraybuffer": {
    "id": "Core.ArrayBuffer",
    "name": "ArrayBuffer",
    "docstrings": [],
    "items": [
      {
        "id": "Core.ArrayBuffer.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = Js.TypedArray2.ArrayBuffer.t"
      },
      {
        "id": "Core.ArrayBuffer.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: int => t"
      },
      {
        "id": "Core.ArrayBuffer.byteLength",
        "kind": "value",
        "name": "byteLength",
        "docstrings": [],
        "signature": "let byteLength: t => int"
      },
      {
        "id": "Core.ArrayBuffer.slice",
        "kind": "value",
        "name": "slice",
        "docstrings": [],
        "signature": "let slice: (t, ~start: int, ~end: int) => t"
      },
      {
        "id": "Core.ArrayBuffer.sliceToEnd",
        "kind": "value",
        "name": "sliceToEnd",
        "docstrings": [],
        "signature": "let sliceToEnd: (t, ~start: int) => t"
      }
    ]
  },
  "core/weakset": {
    "id": "Core.WeakSet",
    "name": "WeakSet",
    "docstrings": [],
    "items": [
      {
        "id": "Core.WeakSet.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a> = Js.WeakSet.t<'a>"
      },
      {
        "id": "Core.WeakSet.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Core.WeakSet.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t<'a>, 'a) => t<'a>"
      },
      {
        "id": "Core.WeakSet.delete",
        "kind": "value",
        "name": "delete",
        "docstrings": [],
        "signature": "let delete: (t<'a>, 'a) => bool"
      },
      {
        "id": "Core.WeakSet.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'a>, 'a) => bool"
      }
    ]
  },
  "core/set": {
    "id": "Core.Set",
    "name": "Set",
    "docstrings": [
      "Bindings to the mutable JavaScript `Set`.\n\nSee [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) on MDN."
    ],
    "items": [
      {
        "id": "Core.Set.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Type representing an instance of `Set`."
        ],
        "signature": "type t<'a> = Js.Set.t<'a>"
      },
      {
        "id": "Core.Set.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new, mutable JavaScript `Set`. A `Set` is a collection of unique values.\n\nSee [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) on MDN.\n\n\n\n## Examples\n```rescript\n// You can annotate the type of your set if you want to\nlet mySet: Set.t<string> = Set.make()\n\n// Or you can let ReScript infer what's in your Set\nlet set = Set.make()\nset->Set.add(\"Fine name\") // Inferred as Set.t<string>\n```\n\n## Alternatives\nA JavaScript `Set` is mutable. If you're looking for an immutable alternative, check out `Belt.Set`."
        ],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Core.Set.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Turns an array of values into a Set. Meaning only unique values are preserved.\n\n## Examples\n```rescript\ntype languages = ReScript | JavaScript | TypeScript\nlet languageRank = [ReScript, JavaScript, TypeScript]\n\nlet set = Set.fromArray(languageRank) // Set.t<languages>\n\nswitch set->Set.has(ReScript) {\n| true => Console.log(\"Yay, ReScript is in there!\")\n| false => Console.log(\"Uh-oh, something is _terribly_ wrong with this program... abort.\")\n}\n```"
        ],
        "signature": "let fromArray: array<'a> => t<'a>"
      },
      {
        "id": "Core.Set.fromIterator",
        "kind": "value",
        "name": "fromIterator",
        "docstrings": [
          "Turns an iterator into a `Set`.\n\n## Examples\n```rescript\n// Let's pretend we have an interator\n@val external someIterator: Iterator.t<int> = \"someIterator\"\n\nlet set = Set.fromIterator(someIterator) // Set.t<int>\n```"
        ],
        "signature": "let fromIterator: Core__Iterator.t<'a> => t<'a>"
      },
      {
        "id": "Core.Set.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns the size, the number of unique values, of the set.\n\n## Examples\n```rescript\nlet set = Set.make()\n\nset->Set.add(\"someValue\")\nset->Set.add(\"someValue\")\nset->Set.add(\"someValue2\")\n\nlet size = set->Set.size // 2\n```"
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Core.Set.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Clears all entries in the set.\n\n## Examples\n```rescript\nlet set = Set.make()\n\nset->Set.add(\"someKey\")\nset->Set.size // 1\n\nset->Set.clear\nset->Set.size // 0\n```"
        ],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Core.Set.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds a new value to the set.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\n```"
        ],
        "signature": "let add: (t<'a>, 'a) => unit"
      },
      {
        "id": "Core.Set.delete",
        "kind": "value",
        "name": "delete",
        "docstrings": [
          "Deletes the provided `value` from the set. Returns a `bool` for whether the value existed, and was deleted.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\nlet didDeleteValue = set->Set.delete(\"someValue\")\nConsole.log(didDeleteValue) // Logs `true` to the console, becuase the set had the value, so it was successfully deleted\n\nlet didDeleteValue = set->Set.delete(\"someNonExistantKey\")\nConsole.log(didDeleteValue) // Logs `false` to the console, becuase the value did not exist in the set\n```"
        ],
        "signature": "let delete: (t<'a>, 'a) => bool"
      },
      {
        "id": "Core.Set.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks whether the set has a specific value.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\n\nswitch set->Set.has(\"someValue\") {\n| false => Console.log(\"Nope, didn't have it.\")\n| true => Console.log(\"Yay, we have the value!\")\n}\n```"
        ],
        "signature": "let has: (t<'a>, 'a) => bool"
      },
      {
        "id": "Core.Set.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Iterates through all values of the set.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\nset->Set.add(\"someValue2\")\n\nset->Set.forEach(value => {\n  Console.log(value)\n})\n```"
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.Set.values",
        "kind": "value",
        "name": "values",
        "docstrings": [
          "Returns an iterator that holds all values of the set.\n\n## Examples\n```rescript\nlet set = Set.make()\nset->Set.add(\"someValue\")\nset->Set.add(\"anotherValue\")\n\nlet values = set->Set.values\n\n// Logs the first value\nConsole.log(Iterator.next(values).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes values. We'll need a fresh values iterator to get an array of all values, since we consumed a value via `next` above already.\nConsole.log(set->Set.values->Iterator.toArray)\n```"
        ],
        "signature": "let values: t<'a> => Core__Iterator.t<'a>"
      }
    ]
  },
  "core/weakmap": {
    "id": "Core.WeakMap",
    "name": "WeakMap",
    "docstrings": [],
    "items": [
      {
        "id": "Core.WeakMap.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'k, 'v> = Js.WeakMap.t<'k, 'v>"
      },
      {
        "id": "Core.WeakMap.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t<'k, 'v>"
      },
      {
        "id": "Core.WeakMap.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'k, 'v>, 'k) => option<'v>"
      },
      {
        "id": "Core.WeakMap.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'k, 'v>, 'k) => bool"
      },
      {
        "id": "Core.WeakMap.set",
        "kind": "value",
        "name": "set",
        "docstrings": [],
        "signature": "let set: (t<'k, 'v>, 'k, 'v) => t<'k, 'v>"
      },
      {
        "id": "Core.WeakMap.delete",
        "kind": "value",
        "name": "delete",
        "docstrings": [],
        "signature": "let delete: (t<'k, 'v>, 'k) => bool"
      }
    ]
  },
  "core/map": {
    "id": "Core.Map",
    "name": "Map",
    "docstrings": [
      "Bindings to the mutable JavaScript `Map`.\n\nSee [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) on MDN."
    ],
    "items": [
      {
        "id": "Core.Map.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Type representing an instance of `Map`."
        ],
        "signature": "type t<'k, 'v> = Js.Map.t<'k, 'v>"
      },
      {
        "id": "Core.Map.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new, mutable JavaScript `Map`. A `Map` can have any values as both keys and values.\n\nSee [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) on MDN.\n\n\n\n## Examples\n```rescript\n`make()`\n// You can annotate the type of your map if you want to\nlet myMap: Map.t<string, int> = Map.make()\n\n// Or you can let ReScript infer what's in your map\nlet map = Map.make()\nmap->Map.set(\"lang\", \"ReScript\") // Inferred as Map.t<string, string>\n```\n\n## Alternatives\nA JavaScript `Map` is mutable. If you're looking for an immutable alternative, check out`Belt.Map`."
        ],
        "signature": "let make: unit => t<'k, 'v>"
      },
      {
        "id": "Core.Map.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Turns an array of key/value pairs into a Map.\n\n## Examples\n```rescript\ntype languages = ReScript | JavaScript | TypeScript\nlet languageRank = [(ReScript, 1), (JavaScript, 2), (TypeScript, 3)]\n\nlet map = Map.fromArray(languageRank) // Map.t<languages, int>\n\nswitch map->Map.get(ReScript) {\n| Some(1) => Console.log(\"Yay, ReScript is #1!\")\n| _ => Console.log(\"Uh-oh, something is _terribly_ wrong with this program... abort.\")\n}\n```"
        ],
        "signature": "let fromArray: array<('k, 'v)> => t<'k, 'v>"
      },
      {
        "id": "Core.Map.fromIterator",
        "kind": "value",
        "name": "fromIterator",
        "docstrings": [
          "Turns an iterator in the shape of `('key, 'value)` into a `Map`.\n\n## Examples\n```rescript\n// Let's pretend we have an interator in the correct shape\n@val external someIterator: Iterator.t<(string, int)> = \"someIterator\"\n\nlet map = Map.fromIterator(someIterator) // Map.t<string, int>\n```"
        ],
        "signature": "let fromIterator: Core__Iterator.t<('k, 'v)> => t<'k, 'v>"
      },
      {
        "id": "Core.Map.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns the size, the number of key/value pairs, of the map.\n\n## Examples\n```rescript\nlet map = Map.make()\n\nmap->Map.set(\"someKey\", \"someValue\")\n\nlet size = map->Map.size // 1\n```"
        ],
        "signature": "let size: t<'k, 'v> => int"
      },
      {
        "id": "Core.Map.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Clears all entries in the map.\n\n## Examples\n```rescript\nlet map = Map.make()\n\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.size // 1\n\nmap->Map.clear\nmap->Map.size // 0\n```"
        ],
        "signature": "let clear: t<'k, 'v> => unit"
      },
      {
        "id": "Core.Map.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Iterates through all values of the map.\n\n> Please note that this is *without the keys*, just the values. If you need the key as well, use `Map.forEachWithKey`.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\nmap->Map.forEach(value => {\n  Console.log(value)\n})\n```"
        ],
        "signature": "let forEach: (t<'k, 'v>, 'v => unit) => unit"
      },
      {
        "id": "Core.Map.forEachWithKey",
        "kind": "value",
        "name": "forEachWithKey",
        "docstrings": [
          "Iterates through all values of the map, including the key for each value.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\nmap->Map.forEachWithKey((value, key) => {\n  Console.log2(value, key)\n})\n```"
        ],
        "signature": "let forEachWithKey: (t<'k, 'v>, ('v, 'k) => unit) => unit"
      },
      {
        "id": "Core.Map.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the value for a key, if a value exists at that key.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\n\nswitch map->Map.get(\"someKey\") {\n| None => Console.log(\"Nope, didn't have it.\")\n| Some(value) => Console.log2(\"Yay, had the value, and it's:\", value)\n}\n```"
        ],
        "signature": "let get: (t<'k, 'v>, 'k) => option<'v>"
      },
      {
        "id": "Core.Map.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks whether the map has a specific key.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\n\nswitch map->Map.has(\"someKey\") {\n| false => Console.log(\"Nope, didn't have it.\")\n| true => Console.log(\"Yay, we have the value!\")\n}\n```"
        ],
        "signature": "let has: (t<'k, 'v>, 'k) => bool"
      },
      {
        "id": "Core.Map.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "Sets the provided `value` to the provided `key`.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\n```"
        ],
        "signature": "let set: (t<'k, 'v>, 'k, 'v) => unit"
      },
      {
        "id": "Core.Map.delete",
        "kind": "value",
        "name": "delete",
        "docstrings": [
          "Deletes the provided `key` and its value from the map. Returns a `bool` for whether the key existed, and was deleted.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nlet didDeleteKey = map->Map.delete(\"someKey\")\nConsole.log(didDeleteKey) // Logs `true` to the console, becuase the map had the key, so it was successfully deleted\n\nlet didDeleteKey = map->Map.delete(\"someNonExistantKey\")\nConsole.log(didDeleteKey) // Logs `false` to the console, becuase the key did not exist\n```"
        ],
        "signature": "let delete: (t<'k, 'v>, 'k) => bool"
      },
      {
        "id": "Core.Map.keys",
        "kind": "value",
        "name": "keys",
        "docstrings": [
          "Returns an iterator that holds all keys of the map.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"anotherKey\", \"anotherValue\")\n\nlet keys = map->Map.keys\n\n// Logs the first key\nConsole.log(Iterator.next(keys).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes values. We'll need a fresh keys iterator to get an array of all keys, since we consumed a value via `next` above already.\nConsole.log(map->Map.keys->Iterator.toArray)\n```"
        ],
        "signature": "let keys: t<'k, 'v> => Core__Iterator.t<'k>"
      },
      {
        "id": "Core.Map.values",
        "kind": "value",
        "name": "values",
        "docstrings": [
          "Returns an iterator that holds all values of the map.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"anotherKey\", \"anotherValue\")\n\nlet values = map->Map.values\n\n// Logs the first value\nConsole.log(Iterator.next(values).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes values. We'll need a fresh values iterator to get an array of all values, since we consumed a value via `next` above already.\nConsole.log(map->Map.values->Iterator.toArray)\n```"
        ],
        "signature": "let values: t<'k, 'v> => Core__Iterator.t<'v>"
      },
      {
        "id": "Core.Map.entries",
        "kind": "value",
        "name": "entries",
        "docstrings": [
          "Returns an iterator that holds all entries of the map.\nAn entry is represented as a tuple of `('key, 'value)`,\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"anotherKey\", \"anotherValue\")\n\nlet entries = map->Map.entries\n\n// Logs the first value\nConsole.log(Iterator.next(entries).value)\n\n// You can also turn the iterator into an array.\n// Remember that an iterator consumes entries. We'll need a fresh entries iterator to get an array of all entries, since we consumed a value via `next` above already.\nConsole.log(map->Map.entries->Iterator.toArray)\n```"
        ],
        "signature": "let entries: t<'k, 'v> => Core__Iterator.t<('k, 'v)>"
      }
    ]
  },
  "core/asynciterator": {
    "id": "Core.AsyncIterator",
    "name": "AsyncIterator",
    "docstrings": [
      "Bindings to async iterators, a way to do async iteration in JavaScript.\n\nSee [async iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols) on MDN."
    ],
    "items": [
      {
        "id": "Core.AsyncIterator.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type representing an async iterator."
        ],
        "signature": "type t<'a>"
      },
      {
        "id": "Core.AsyncIterator.value",
        "kind": "type",
        "name": "value",
        "docstrings": [],
        "signature": "type value<'a> = {done: bool, value: option<'a>}"
      },
      {
        "id": "Core.AsyncIterator.next",
        "kind": "value",
        "name": "next",
        "docstrings": [
          "`next(asyncIterator)`\n\nReturns the next value of the iterator, if any.\n\nSee [async iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols) on MDN.\n\n## Examples\n- A simple example, getting the next value:\n```rescript\n@val external asyncIterator: AsyncIterator.t<int> = \"someAsyncIterator\"\nlet {AsyncIterator.done, value} = await asyncIterator->AsyncIterator.next\n```\n\n- Complete example, including looping over all values:\n```rescript\n// Let's pretend we get an async iterator returning ints from somewhere.\n@val external asyncIterator: AsyncIterator.t<int> = \"someAsyncIterator\"\n\n\nlet processMyAsyncIterator = async () => {\n  // ReScript doesn't have `for ... of` loops, but it's easy to mimic using a while loop.\n  let break = ref(false)\n\n  while !break.contents {\n    // Await the next iterator value\n    let {value, done} = await asyncIterator->AsyncIterator.next\n\n    // Exit the while loop if the iterator says it's done\n    break := done\n\n    // This will log the (int) value of the current async iteration, if a value was returned.\n    Console.log(value)\n  }\n}\n```"
        ],
        "signature": "let next: t<'a> => promise<value<'a>>"
      },
      {
        "id": "Core.AsyncIterator.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(iterator, fn)` consumes all values in the async iterator and runs the callback `fn` for each value.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\n// Let's pretend we get an async iterator returning ints from somewhere.\n@val external asyncIterator: AsyncIterator.t<int> = \"someAsyncIterator\"\n\nawait asyncIterator->AsyncIterator.forEach(value =>\n  switch value {\n  | Some(value) if value > 10 => Console.log(\"More than 10!\")\n  | _ => ()\n  }\n)\n```"
        ],
        "signature": "let forEach: (t<'a>, option<'a> => unit) => promise<unit>"
      }
    ]
  },
  "core/iterator": {
    "id": "Core.Iterator",
    "name": "Iterator",
    "docstrings": [
      "Bindings to JavaScript iterators.\n\nSee [`iterator protocols`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN."
    ],
    "items": [
      {
        "id": "Core.Iterator.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type representing an iterator."
        ],
        "signature": "type t<'a>"
      },
      {
        "id": "Core.Iterator.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The current value of an iterator."
        ],
        "signature": "type value<'a> = {done: bool, value: option<'a>}"
      },
      {
        "id": "Core.Iterator.next",
        "kind": "value",
        "name": "next",
        "docstrings": [
          "Returns the next value of the iterator, if any.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\n@val external someIterator: Iterator.t<int> = \"someIterator\"\n\n// Pulls out the next value of the iterator\nlet {Iterator.done, value} = someIterator->Iterator.next\n```"
        ],
        "signature": "let next: t<'a> => value<'a>"
      },
      {
        "id": "Core.Iterator.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Turns an iterator into an array of the remaining values.\nRemember that each invocation of `next` of an iterator consumes a value. `Iterator.toArray` will consume all remaining values of the iterator and return them in an array to you.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\n// `Map.keys` returns all keys of the map as an iterator.\nlet mapKeysAsArray = map->Map.keys->Iterator.toArray\n\nConsole.log(mapKeysAsArray) // Logs [\"someKey\", \"someKey2\"] to the console.\n```"
        ],
        "signature": "let toArray: t<'a> => array<'a>"
      },
      {
        "id": "Core.Iterator.toArrayWithMapper",
        "kind": "value",
        "name": "toArrayWithMapper",
        "docstrings": [
          "`toArray(iterator)` turns `iterator` into an array of its remaining values, applying the provided mapper function on each item.\nRemember that each invocation of `next` of an iterator consumes a value. `Iterator.toArrayWithMapper` will consume all remaining values of the iterator and return them in an array to you.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\nlet map = Map.make()\nmap->Map.set(\"someKey\", \"someValue\")\nmap->Map.set(\"someKey2\", \"someValue2\")\n\n// `Map.keys` returns all keys of the map as an iterator.\nlet mapKeysAsArray = map\n  ->Map.keys\n  ->Iterator.toArrayWithMapper(key => key->String.length)\n\nConsole.log(mapKeysAsArray) // Logs [7, 8] to the console.\n```"
        ],
        "signature": "let toArrayWithMapper: (t<'a>, 'a => 'b) => array<'b>"
      },
      {
        "id": "Core.Iterator.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(iterator, fn)` consumes all values in the iterator and runs the callback `fn` for each value.\n\nSee [iterator protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) on MDN.\n\n## Examples\n```rescript\n@val external someIterator: Iterator.t<int> = \"someIterator\"\n\nsomeIterator->Iterator.forEach(value =>\n  switch value {\n  | Some(value) if value > 10 => Console.log(\"More than 10!\")\n  | _ => ()\n  }\n)\n```"
        ],
        "signature": "let forEach: (t<'a>, option<'a> => unit) => unit"
      }
    ]
  },
  "core/json": {
    "id": "Core.JSON",
    "name": "JSON",
    "docstrings": [
      "Functions for interacting with JSON."
    ],
    "items": [
      {
        "id": "Core.JSON.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "A type representing a JSON object."
        ],
        "signature": "type t = Js.Json.t =\n  | Boolean(bool)\n  | Null\n  | String(string)\n  | Number(float)\n  | Object(Core__Dict.t<t>)\n  | Array(array<t>)"
      },
      {
        "id": "Core.JSON.replacer",
        "kind": "type",
        "name": "replacer",
        "docstrings": [],
        "signature": "type replacer =\n  | Keys(array<string>)\n  | Replacer((string, t) => t)"
      },
      {
        "id": "Core.JSON.parseExn",
        "kind": "value",
        "name": "parseExn",
        "docstrings": [
          "`parseExn(string, ~reviver=?)` \n\nParses a JSON string or throws a JavaScript exception (SyntaxError), if the string isn't valid.\nThe reviver describes how the value should be transformed. It is a function which receives a key and a value.\nIt returns a JSON type.\n\n## Examples\n```rescript\ntry {\n  let _ = JSON.parseExn(`{\"foo\":\"bar\",\"hello\":\"world\"}`)\n  // { foo: 'bar', hello: 'world' }\n\n  let _ = JSON.parseExn(\"\")\n  // error\n} catch {\n| Exn.Error(_) => Console.log(\"error\")\n}\n\nlet reviver = (_, value: JSON.t) =>\n  switch value {\n  | String(string) => string->String.toUpperCase->JSON.Encode.string\n  | Number(number) => (number *. 2.0)->JSON.Encode.float\n  | _ => value\n  }\n\nlet jsonString = `{\"hello\":\"world\",\"someNumber\":21}`\n\ntry {\n  JSON.parseExn(jsonString, ~reviver)->Console.log\n  // { hello: 'WORLD', someNumber: 42 }\n\n  JSON.parseExn(\"\", ~reviver)->Console.log\n  // error\n} catch {\n| Exn.Error(_) => Console.log(\"error\")\n}\n```\n\n## Exceptions \n\n- Raises a SyntaxError (Exn.t) if the string isn't valid JSON."
        ],
        "signature": "let parseExn: (string, ~reviver: (string, t) => t=?) => t"
      },
      {
        "id": "Core.JSON.parseExnWithReviver",
        "kind": "value",
        "name": "parseExnWithReviver",
        "docstrings": [
          "`parseExnWithReviver(string, reviver)` \n\nParses a JSON string or throws a JavaScript exception (SyntaxError), if the string isn't valid.\nThe reviver describes how the value should be transformed. It is a function which receives a key and a value.\nIt returns a JSON type.\n\n## Examples\n```rescript\nlet reviver = (_, value: JSON.t) =>\n  switch value {\n  | String(string) => string->String.toUpperCase->JSON.Encode.string\n  | Number(number) => (number *. 2.0)->JSON.Encode.float\n  | _ => value\n  }\n\nlet jsonString = `{\"hello\":\"world\",\"someNumber\":21}`\n\ntry {\n  JSON.parseExnWithReviver(jsonString, reviver)->Console.log\n  // { hello: 'WORLD', someNumber: 42 }\n\n  JSON.parseExnWithReviver(\"\", reviver)->Console.log\n  // error\n} catch {\n| Exn.Error(_) => Console.log(\"error\")\n}\n```\n\n## Exceptions \n\n- Raises a SyntaxError if the string isn't valid JSON."
        ],
        "signature": "let parseExnWithReviver: (string, (string, t) => t) => t",
        "deprecated": "Use `parseExn` with optional parameter instead"
      },
      {
        "id": "Core.JSON.stringify",
        "kind": "value",
        "name": "stringify",
        "docstrings": [
          "`stringify(json, ~replacer=?, ~space=?)` \n\nConverts a JSON object to a JSON string.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value,\nor an array of keys which should be included in the output.\nIf you want to stringify any type, use `JSON.stringifyAny` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringify(json)\n// {\"foo\":\"bar\",\"hello\":\"world\",\"someNumber\":42}\n\nJSON.stringify(json, ~space=2)\n// {\n//   \"foo\": \"bar\",\n//   \"hello\": \"world\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringify(json, ~replacer=Keys([\"foo\", \"someNumber\"]))\n// {\"foo\":\"bar\",\"someNumber\":42}\n\nlet replacer = JSON.Replacer((_, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n})\n\nJSON.stringify(json, ~replacer)\n// {\"foo\":\"BAR\",\"hello\":\"WORLD\",\"someNumber\":42}\n```"
        ],
        "signature": "let stringify: (t, ~replacer: replacer=?, ~space: int=?) => string"
      },
      {
        "id": "Core.JSON.stringifyWithIndent",
        "kind": "value",
        "name": "stringifyWithIndent",
        "docstrings": [
          "`stringifyWithIndent(json, indentation)` \n\nConverts a JSON object to a JSON string. The output will be indented.\nIf you want to stringify any type, use `JSON.stringifyAnyWithIndent` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringifyWithIndent(json, 2)\n// {\n//   \"foo\": \"bar\",\n//   \"hello\": \"world\",\n//   \"someNumber\": 42\n// }\n```"
        ],
        "signature": "let stringifyWithIndent: (t, int) => string",
        "deprecated": "Use `stringify` with optional parameter instead"
      },
      {
        "id": "Core.JSON.stringifyWithReplacer",
        "kind": "value",
        "name": "stringifyWithReplacer",
        "docstrings": [
          "`stringifyWithReplacer(json, replacer)` \n\nConverts a JSON object to a JSON string.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nIf you want to stringify any type, use `JSON.stringifyAnyWithReplacer` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nlet replacer = (_, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyWithReplacer(json, replacer)\n// {\"foo\":\"BAR\",\"hello\":\"WORLD\",\"someNumber\":42}\n```"
        ],
        "signature": "let stringifyWithReplacer: (t, (string, t) => t) => string",
        "deprecated": "Use `stringify` with optional parameter instead"
      },
      {
        "id": "Core.JSON.stringifyWithReplacerAndIndent",
        "kind": "value",
        "name": "stringifyWithReplacerAndIndent",
        "docstrings": [
          "`stringifyWithReplacerAndIndent(json, replacer, indentation)`\n\nConverts a JSON object to a JSON string. The output will be indented.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nIf you want to stringify any type, use `JSON.stringifyAnyWithReplacerAndIndent` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nlet replacer = (_, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyWithReplacerAndIndent(json, replacer, 2)\n// {\n//   \"foo\": \"BAR\",\n//   \"hello\": \"WORLD\",\n//   \"someNumber\": 42\n// }\n```"
        ],
        "signature": "let stringifyWithReplacerAndIndent: (t, (string, t) => t, int) => string",
        "deprecated": "Use `stringify` with optional parameters instead"
      },
      {
        "id": "Core.JSON.stringifyWithFilter",
        "kind": "value",
        "name": "stringifyWithFilter",
        "docstrings": [
          "`stringifyWithFilter(json, filter)` \n\nConverts a JSON object to a JSON string.\nThe filter is an array of keys, which should be included in the output.\nIf you want to stringify any type, use `JSON.stringifyAnyWithFilter` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringifyWithFilter(json, [\"foo\", \"someNumber\"])\n// {\"foo\":\"bar\",\"someNumber\":42}\n```"
        ],
        "signature": "let stringifyWithFilter: (t, array<string>) => string",
        "deprecated": "Use `stringify` with optional parameter instead"
      },
      {
        "id": "Core.JSON.stringifyWithFilterAndIndent",
        "kind": "value",
        "name": "stringifyWithFilterAndIndent",
        "docstrings": [
          "`stringifyWithFilterAndIndent(json, filter, indentation)` \n\nConverts a JSON object to a JSON string. The output will be indented.\nThe filter is an array of keys, which should be included in the output.\nIf you want to stringify any type, use `JSON.stringifyAnyWithFilterAndIndent` instead.\n\n## Examples\n```rescript\nlet json =\n  Dict.fromArray([\n    (\"foo\", JSON.Encode.string(\"bar\")),\n    (\"hello\", JSON.Encode.string(\"world\")),\n    (\"someNumber\", JSON.Encode.int(42)),\n  ])->JSON.Encode.object\n\nJSON.stringifyWithFilterAndIndent(json, [\"foo\", \"someNumber\"], 2)\n// {\n//   \"foo\": \"bar\",\n//   \"someNumber\": 42\n// }\n```"
        ],
        "signature": "let stringifyWithFilterAndIndent: (t, array<string>, int) => string",
        "deprecated": "Use `stringify` with optional parameters instead"
      },
      {
        "id": "Core.JSON.stringifyAny",
        "kind": "value",
        "name": "stringifyAny",
        "docstrings": [
          "`stringifyAny(any, ~replacer=?, ~space=?)` \n\nConverts any type to a JSON string.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringify` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAny(dict)\n// {\"foo\":\"bar\",\"hello\":\"world\",\"someNumber\":42}\n\nJSON.stringifyAny(dict, ~space=2)\n// {\n//   \"foo\": \"bar\",\n//   \"hello\": \"world\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringifyAny(dict, ~replacer=Keys([\"foo\", \"someNumber\"]))\n// {\"foo\":\"bar\",\"someNumber\":42}\n\nlet replacer = JSON.Replacer((_, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n})\n\nJSON.stringifyAny(dict, ~replacer)\n// {\"foo\":\"BAR\",\"hello\":\"WORLD\",\"someNumber\":42}\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."
        ],
        "signature": "let stringifyAny: ('a, ~replacer: replacer=?, ~space: int=?) => option<string>"
      },
      {
        "id": "Core.JSON.stringifyAnyWithIndent",
        "kind": "value",
        "name": "stringifyAnyWithIndent",
        "docstrings": [
          "`stringifyAnyWithIndent(any, indentation)` \n\nConverts any type to a JSON string. The output will be indented.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithIndent` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAnyWithIndent(dict, 2)\n// {\n//   \"foo\": \"bar\",\n//   \"hello\": \"world\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."
        ],
        "signature": "let stringifyAnyWithIndent: ('a, int) => option<string>",
        "deprecated": "Use `stringifyAny` with optional parameter instead"
      },
      {
        "id": "Core.JSON.stringifyAnyWithReplacer",
        "kind": "value",
        "name": "stringifyAnyWithReplacer",
        "docstrings": [
          "`stringifyAnyWithReplacer(json, replacer)`\n\nConverts any type to a JSON string.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithReplacer` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nlet replacer = (_, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyAnyWithReplacer(dict, replacer)\n// {\"foo\":\"BAR\",\"hello\":\"WORLD\",\"someNumber\":42}\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."
        ],
        "signature": "let stringifyAnyWithReplacer: ('a, (string, t) => t) => option<string>",
        "deprecated": "Use `stringifyAny` with optional parameter instead"
      },
      {
        "id": "Core.JSON.stringifyAnyWithReplacerAndIndent",
        "kind": "value",
        "name": "stringifyAnyWithReplacerAndIndent",
        "docstrings": [
          "`stringifyAnyWithReplacerAndIndent(json, replacer, indentation)` \n\nConverts any type to a JSON string. The output will be indented.\nThe replacer describes how the value should be transformed. It is a function which receives a key and a value.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithReplacerAndIndent` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nlet replacer = (_, value) => {\n  let decodedValue = value->JSON.Decode.string\n\n  switch decodedValue {\n  | Some(string) => string->String.toUpperCase->JSON.Encode.string\n  | None => value\n  }\n}\n\nJSON.stringifyAnyWithReplacerAndIndent(dict, replacer, 2)\n// {\n//   \"foo\": \"BAR\",\n//   \"hello\": \"WORLD\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."
        ],
        "signature": "let stringifyAnyWithReplacerAndIndent: ('a, (string, t) => t, int) => option<string>",
        "deprecated": "Use `stringifyAny` with optional parameters instead"
      },
      {
        "id": "Core.JSON.stringifyAnyWithFilter",
        "kind": "value",
        "name": "stringifyAnyWithFilter",
        "docstrings": [
          "`stringifyAnyWithFilter(json, filter)` \n\nConverts any type to a JSON string.\nThe filter is an array of keys, which should be included in the output.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithFilter` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAnyWithFilter(dict, [\"foo\", \"someNumber\"])\n// {\"foo\": \"bar\",\"someNumber\": 42}\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."
        ],
        "signature": "let stringifyAnyWithFilter: ('a, array<string>) => string",
        "deprecated": "Use `stringifyAny` with optional parameter instead"
      },
      {
        "id": "Core.JSON.stringifyAnyWithFilterAndIndent",
        "kind": "value",
        "name": "stringifyAnyWithFilterAndIndent",
        "docstrings": [
          "`stringifyAnyWithFilterAndIndent(json, filter, indentation)` \n\nConverts any type to a JSON string. The output will be indented.\nThe filter is an array of keys, which should be included in the output.\nStringifying a function or `undefined` will return `None`.\nIf the value contains circular references or `BigInt`s, the function will throw a JavaScript exception (TypeError).\nIf you want to stringify a JSON object, use `JSON.stringifyWithFilterAndIndent` instead.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([\n  (\"foo\", JSON.Encode.string(\"bar\")),\n  (\"hello\", JSON.Encode.string(\"world\")),\n  (\"someNumber\", JSON.Encode.int(42)),\n])\n\nJSON.stringifyAnyWithFilterAndIndent(dict, [\"foo\", \"someNumber\"], 2)\n// {\n//   \"foo\": \"bar\",\n//   \"someNumber\": 42\n// }\n\nJSON.stringifyAny(() => \"hello world\")\n// None\n\nBigInt.fromInt(0)->JSON.stringifyAny\n// exception\n```\n\n## Exceptions \n\n- Raises a TypeError if the value contains circular references.\n- Raises a TypeError if the value contains `BigInt`s."
        ],
        "signature": "let stringifyAnyWithFilterAndIndent: ('a, array<string>, int) => string",
        "deprecated": "Use `stringifyAny` with optional parameters instead"
      }
    ]
  },
  "core/type": {
    "id": "Core.Type",
    "name": "Type",
    "docstrings": [
      "Utilities for classifying the type of JavaScript values at runtime."
    ],
    "items": [
      {
        "id": "Core.Type.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The possible types of JavaScript values."
        ],
        "signature": "type t = [\n  | #bigint\n  | #boolean\n  | #function\n  | #number\n  | #object\n  | #string\n  | #symbol\n  | #undefined\n]"
      },
      {
        "id": "Core.Type.typeof",
        "kind": "value",
        "name": "typeof",
        "docstrings": [
          "`typeof(someValue)`\n\nReturns the underlying JavaScript type of any runtime value.\n\nSee [`typeof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof) on MDN.\n\n## Examples\n```rescript\nConsole.log(Type.typeof(\"Hello\")) // Logs \"string\" to the console.\n\nlet someVariable = true\n\nswitch someVariable->Type.typeof {\n| #boolean => Console.log(\"This is a bool, yay!\")\n| _ => Console.log(\"Oh, not a bool sadly...\")\n}\n```"
        ],
        "signature": "let typeof: 'a => t"
      }
    ]
  },
  "core/symbol": {
    "id": "Core.Symbol",
    "name": "Symbol",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Symbol.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = Js.Types.symbol"
      },
      {
        "id": "Core.Symbol.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: string => t"
      },
      {
        "id": "Core.Symbol.getFor",
        "kind": "value",
        "name": "getFor",
        "docstrings": [],
        "signature": "let getFor: string => t"
      },
      {
        "id": "Core.Symbol.keyFor",
        "kind": "value",
        "name": "keyFor",
        "docstrings": [],
        "signature": "let keyFor: t => option<string>"
      },
      {
        "id": "Core.Symbol.asyncIterator",
        "kind": "value",
        "name": "asyncIterator",
        "docstrings": [],
        "signature": "let asyncIterator: t"
      },
      {
        "id": "Core.Symbol.hasInstance",
        "kind": "value",
        "name": "hasInstance",
        "docstrings": [],
        "signature": "let hasInstance: t"
      },
      {
        "id": "Core.Symbol.isConcatSpreadable",
        "kind": "value",
        "name": "isConcatSpreadable",
        "docstrings": [],
        "signature": "let isConcatSpreadable: t"
      },
      {
        "id": "Core.Symbol.iterator",
        "kind": "value",
        "name": "iterator",
        "docstrings": [],
        "signature": "let iterator: t"
      },
      {
        "id": "Core.Symbol.match",
        "kind": "value",
        "name": "match",
        "docstrings": [],
        "signature": "let match: t"
      },
      {
        "id": "Core.Symbol.matchAll",
        "kind": "value",
        "name": "matchAll",
        "docstrings": [],
        "signature": "let matchAll: t"
      },
      {
        "id": "Core.Symbol.replace",
        "kind": "value",
        "name": "replace",
        "docstrings": [],
        "signature": "let replace: t"
      },
      {
        "id": "Core.Symbol.search",
        "kind": "value",
        "name": "search",
        "docstrings": [],
        "signature": "let search: t"
      },
      {
        "id": "Core.Symbol.species",
        "kind": "value",
        "name": "species",
        "docstrings": [],
        "signature": "let species: t"
      },
      {
        "id": "Core.Symbol.split",
        "kind": "value",
        "name": "split",
        "docstrings": [],
        "signature": "let split: t"
      },
      {
        "id": "Core.Symbol.toPrimitive",
        "kind": "value",
        "name": "toPrimitive",
        "docstrings": [],
        "signature": "let toPrimitive: t"
      },
      {
        "id": "Core.Symbol.toStringTag",
        "kind": "value",
        "name": "toStringTag",
        "docstrings": [],
        "signature": "let toStringTag: t"
      },
      {
        "id": "Core.Symbol.unscopables",
        "kind": "value",
        "name": "unscopables",
        "docstrings": [],
        "signature": "let unscopables: t"
      }
    ]
  },
  "core/string": {
    "id": "Core.String",
    "name": "String",
    "docstrings": [
      "Functions for interacting with JavaScript strings.\nSee: [`String`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)."
    ],
    "items": [
      {
        "id": "Core.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(value)` converts the given value to a `string`.\n\n## Examples\n\n```rescript\nString.make(3.5) == \"3.5\"\nString.make([1, 2, 3]) == \"1,2,3\"\n```"
        ],
        "signature": "let make: 'a => string"
      },
      {
        "id": "Core.String.fromCharCode",
        "kind": "value",
        "name": "fromCharCode",
        "docstrings": [
          "`fromCharCode(n)` creates a `string` containing the character corresponding to\nthat number, `n` ranges from 0 to 65535. If out of range, the lower 16 bits of\nthe value are used. Thus, `fromCharCode(0x1F63A)` gives the same result as\n`fromCharCode(0xF63A)`.\nSee [`String.fromCharCode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) on MDN.\n\n## Examples\n\n```rescript\nString.fromCharCode(65) == \"A\"\nString.fromCharCode(0x3c8) == ``\nString.fromCharCode(0xd55c) == ``\nString.fromCharCode(-64568) == ``\n```"
        ],
        "signature": "let fromCharCode: int => string"
      },
      {
        "id": "Core.String.fromCharCodeMany",
        "kind": "value",
        "name": "fromCharCodeMany",
        "docstrings": [
          "`fromCharCodeMany([n1, n2, n3])` creates a `string` from the characters\ncorresponding to the given numbers, using the same rules as `fromCharCode`.\nSee [`String.fromCharCode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) on MDN.\n\n## Examples\n\n```rescript\nString.fromCharCodeMany([189, 43, 190, 61]) == \"+=\"\nString.fromCharCodeMany([65, 66, 67]) == \"ABC\"\n```"
        ],
        "signature": "let fromCharCodeMany: array<int> => string"
      },
      {
        "id": "Core.String.fromCodePoint",
        "kind": "value",
        "name": "fromCodePoint",
        "docstrings": [
          "`fromCodePoint(n)` creates a `string` containing the character corresponding to\nthat numeric code point.\nSee [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) on MDN.\n\n## Examples\n\n```rescript\nString.fromCodePoint(65) == \"A\"\nString.fromCodePoint(0x3c8) == ``\nString.fromCodePoint(0xd55c) == ``\nString.fromCodePoint(0x1f63a) == ``\n```\n\n## Exceptions\n\n- `RangeError`: If the number is not a valid code point, like `fromCharCode(-5)`."
        ],
        "signature": "let fromCodePoint: int => string"
      },
      {
        "id": "Core.String.fromCodePointMany",
        "kind": "value",
        "name": "fromCodePointMany",
        "docstrings": [
          "`fromCodePointMany([n1, n2, n3])` creates a `string` from the characters\ncorresponding to the given code point numbers, using the same rules as\n`fromCodePoint`.\nSee [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) on MDN.\n\n## Examples\n\n```rescript\nString.fromCodePointMany([0xd55c, 0xae00, 0x1f63a]) == ``\n```\n\n## Exceptions\n\n- `RangeError`: If one of the number is not a valid code point, like\n`fromCharCode([1, -5])`."
        ],
        "signature": "let fromCodePointMany: array<int> => string"
      },
      {
        "id": "Core.String.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: (string, string) => bool"
      },
      {
        "id": "Core.String.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (string, string) => Core__Ordering.t"
      },
      {
        "id": "Core.String.length",
        "kind": "value",
        "name": "length",
        "docstrings": [
          "`length(str)` returns the length of the given `string`.\nSee [`String.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length) on MDN.\n\n## Examples\n\n```rescript\nString.length(\"abcd\") == 4\n```"
        ],
        "signature": "let length: string => int"
      },
      {
        "id": "Core.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "`get(str, index)` returns an `option<string>` at the given `index` number. If\n`index` is out of range, this function returns `None`.\n\n## Examples\n\n```rescript\nString.get(\"ReScript\", 0) == Some(\"R\")\nString.get(\"Hello\", 4) == Some(\"o\")\nString.get(`JS`, 4) == None\n```"
        ],
        "signature": "let get: (string, int) => option<string>"
      },
      {
        "id": "Core.String.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(str, index)` returns an `string` at the given `index` number.\n\nThis is _unsafe_, meaning it will return `undefined` value if `index` does not exist in `string`.\n\nUse `String.getUnsafe` only when you are sure the `index` exists.\n## Examples\n\n```rescript\nString.getUnsafe(\"ReScript\", 0) == \"R\"\nString.getUnsafe(\"Hello\", 4) == \"o\"\n```"
        ],
        "signature": "let getUnsafe: (string, int) => string"
      },
      {
        "id": "Core.String.charAt",
        "kind": "value",
        "name": "charAt",
        "docstrings": [
          "`charAt(str, index)` gets the character at `index` within string `str`. If\n`index` is negative or greater than the length of `str`, it returns the empty\nstring. If the string contains characters outside the range \\u0000-\\uffff, it\nwill return the first 16-bit value at that position in the string.\nSee [`String.charAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt) on MDN.\n\n## Examples\n\n```rescript\nString.charAt(\"ReScript\", 0) == \"R\"\nString.charAt(\"Hello\", 12) == \"\"\nString.charAt(`JS`, 5) == \"\"\n```"
        ],
        "signature": "let charAt: (string, int) => string"
      },
      {
        "id": "Core.String.charCodeAt",
        "kind": "value",
        "name": "charCodeAt",
        "docstrings": [
          "`charCodeAt(str, index)` returns the character code at position `index` in\nstring `str` the result is in the range 0-65535, unlike `codePointAt`, so it\nwill not work correctly for characters with code points greater than or equal\nto 0x10000. The return type is `float` because this function returns NaN if\n`index` is less than zero or greater than the length of the string.\nSee [`String.charCodeAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt) on MDN.\n\n## Examples\n\n```rescript\nString.charCodeAt(``, 0) == 0xd83d->Int.toFloat\nString.codePointAt(``, 0) == Some(0x1f63a)\n```"
        ],
        "signature": "let charCodeAt: (string, int) => float"
      },
      {
        "id": "Core.String.codePointAt",
        "kind": "value",
        "name": "codePointAt",
        "docstrings": [
          "`codePointAt(str, index)` returns the code point at position `index` within\nstring `str` as a `Some(value)`. The return value handles code points greater\nthan or equal to 0x10000. If there is no code point at the given position, the\nfunction returns `None`.\nSee [`String.codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt) on MDN.\n\n## Examples\n\n```rescript\nString.codePointAt(`?`, 1) == Some(0x1f63a)\nString.codePointAt(\"abc\", 5) == None\n```"
        ],
        "signature": "let codePointAt: (string, int) => option<int>"
      },
      {
        "id": "Core.String.concat",
        "kind": "value",
        "name": "concat",
        "docstrings": [
          "`concat(original, append)` returns a new `string` with `append` added after\n`original`.\nSee [`String.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat) on MDN.\n\n## Examples\n\n```rescript\nString.concat(\"cow\", \"bell\") == \"cowbell\"\nString.concat(\"Re\", \"Script\") == \"ReScript\"\n```"
        ],
        "signature": "let concat: (string, string) => string"
      },
      {
        "id": "Core.String.concatMany",
        "kind": "value",
        "name": "concatMany",
        "docstrings": [
          "`concatMany(original, arr)` returns a new `string` consisting of each item of an\narray of strings added to the `original` string.\nSee [`String.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat) on MDN.\n\n## Examples\n\n```rescript\nString.concatMany(\"1st\", [\"2nd\", \"3rd\", \"4th\"]) == \"1st2nd3rd4th\"\n```"
        ],
        "signature": "let concatMany: (string, array<string>) => string"
      },
      {
        "id": "Core.String.endsWith",
        "kind": "value",
        "name": "endsWith",
        "docstrings": [
          "`endsWith(str, substr)` returns `true` if the `str` ends with `substr`, `false`\notherwise.\nSee [`String.endsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) on MDN.\n\n## Examples\n\n```rescript\nString.endsWith(\"BuckleScript\", \"Script\") == true\nString.endsWith(\"BuckleShoes\", \"Script\") == false\n```"
        ],
        "signature": "let endsWith: (string, string) => bool"
      },
      {
        "id": "Core.String.endsWithFrom",
        "kind": "value",
        "name": "endsWithFrom",
        "docstrings": [
          "`endsWithFrom(str, ending, len)` returns `true` if the first len characters of\n`str` end with `ending`, `false` otherwise. If `len` is greater than or equal\nto the length of `str`, then it works like `endsWith`.\nSee [`String.endsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) on MDN.\n\n## Examples\n\n```rescript\nString.endsWithFrom(\"abcd\", \"cd\", 4) == true\nString.endsWithFrom(\"abcde\", \"cd\", 3) == false\nString.endsWithFrom(\"abcde\", \"cde\", 99) == true\nString.endsWithFrom(\"example.dat\", \"ple\", 7) == true\n```"
        ],
        "signature": "let endsWithFrom: (string, string, int) => bool"
      },
      {
        "id": "Core.String.includes",
        "kind": "value",
        "name": "includes",
        "docstrings": [
          "`includes(str, searchValue)` returns `true` if `searchValue` is found anywhere\nwithin `str`, `false` otherwise.\nSee [`String.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) on MDN.\n\n## Examples\n\n```rescript\nString.includes(\"programmer\", \"gram\") == true\nString.includes(\"programmer\", \"er\") == true\nString.includes(\"programmer\", \"pro\") == true\nString.includes(\"programmer.dat\", \"xyz\") == false\n```"
        ],
        "signature": "let includes: (string, string) => bool"
      },
      {
        "id": "Core.String.includesFrom",
        "kind": "value",
        "name": "includesFrom",
        "docstrings": [
          "`includesFrom(str, searchValue, start)` returns `true` if `searchValue` is found\nanywhere within `str` starting at character number `start` (where 0 is the\nfirst character), `false` otherwise.\nSee [`String.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) on MDN.\n\n## Examples\n\n```rescript\nString.includesFrom(\"programmer\", \"gram\", 1) == true\nString.includesFrom(\"programmer\", \"gram\", 4) == false\nString.includesFrom(``, ``, 1) == true\n```"
        ],
        "signature": "let includesFrom: (string, string, int) => bool"
      },
      {
        "id": "Core.String.indexOf",
        "kind": "value",
        "name": "indexOf",
        "docstrings": [
          "`indexOf(str, searchValue)` returns the position at which `searchValue` was\nfirst found within `str`, or `-1` if `searchValue` is not in `str`.\nSee [`String.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf) on MDN.\n\n## Examples\n\n```rescript\nString.indexOf(\"bookseller\", \"ok\") == 2\nString.indexOf(\"bookseller\", \"sell\") == 4\nString.indexOf(\"beekeeper\", \"ee\") == 1\nString.indexOf(\"bookseller\", \"xyz\") == -1\n```"
        ],
        "signature": "let indexOf: (string, string) => int"
      },
      {
        "id": "Core.String.indexOfOpt",
        "kind": "value",
        "name": "indexOfOpt",
        "docstrings": [
          "`indexOfOpt(str, searchValue)`. Like `indexOf`, but return an `option<int>`.\n\n## Examples\n\n```rescript\nString.indexOfOpt(\"bookseller\", \"ok\") == Some(2)\nString.indexOfOpt(\"bookseller\", \"xyz\") == None\n```"
        ],
        "signature": "let indexOfOpt: (string, string) => option<int>"
      },
      {
        "id": "Core.String.indexOfFrom",
        "kind": "value",
        "name": "indexOfFrom",
        "docstrings": [
          "`indexOfFrom(str, searchValue, start)` returns the position at which\n`searchValue` was found within `str` starting at character position `start`, or\n`-1` if `searchValue` is not found in that portion of `str`. The return value is\nrelative to the beginning of the string, no matter where the search started\nfrom.\nSee [`String.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf) on MDN.\n\n## Examples\n\n```rescript\nString.indexOfFrom(\"bookseller\", \"ok\", 1) == 2\nString.indexOfFrom(\"bookseller\", \"sell\", 2) == 4\nString.indexOfFrom(\"bookseller\", \"sell\", 5) == -1\n```"
        ],
        "signature": "let indexOfFrom: (string, string, int) => int"
      },
      {
        "id": "Core.String.lastIndexOf",
        "kind": "value",
        "name": "lastIndexOf",
        "docstrings": [
          "`lastIndexOf(str, searchValue)` returns the position of the last occurrence of\n`searchValue` within `str`, searching backwards from the end of the string.\nReturns `-1` if `searchValue` is not in `str`. The return value is always\nrelative to the beginning of the string.\nSee [`String.lastIndexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf) on MDN.\n\n## Examples\n\n```rescript\nString.lastIndexOf(\"bookseller\", \"ok\") == 2\nString.lastIndexOf(\"beekeeper\", \"ee\") == 4\nString.lastIndexOf(\"abcdefg\", \"xyz\") == -1\n```"
        ],
        "signature": "let lastIndexOf: (string, string) => int"
      },
      {
        "id": "Core.String.lastIndexOfOpt",
        "kind": "value",
        "name": "lastIndexOfOpt",
        "docstrings": [
          "`lastIndexOfOpt(str, searchValue)`. Like `lastIndexOfOpt`, but return an\n`option<int>`.\n\n## Examples\n\n```rescript\nString.lastIndexOfOpt(\"bookseller\", \"ok\") == Some(2)\nString.lastIndexOfOpt(\"beekeeper\", \"ee\") == Some(4)\nString.lastIndexOfOpt(\"abcdefg\", \"xyz\") == None\n```"
        ],
        "signature": "let lastIndexOfOpt: (string, string) => option<int>"
      },
      {
        "id": "Core.String.lastIndexOfFrom",
        "kind": "value",
        "name": "lastIndexOfFrom",
        "docstrings": [
          "`lastIndexOfFrom(str, searchValue, start)` returns the position of the last\noccurrence of `searchValue` within `str`, searching backwards from the given\nstart position. Returns `-1` if `searchValue` is not in `str`. The return value\nis always relative to the beginning of the string.\nSee [`String.lastIndexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf) on MDN.\n\n## Examples\n\n```rescript\nString.lastIndexOfFrom(\"bookseller\", \"ok\", 6) == 2\nString.lastIndexOfFrom(\"beekeeper\", \"ee\", 8) == 4\nString.lastIndexOfFrom(\"beekeeper\", \"ee\", 3) == 1\nString.lastIndexOfFrom(\"abcdefg\", \"xyz\", 4) == -1\n```"
        ],
        "signature": "let lastIndexOfFrom: (string, string, int) => int"
      },
      {
        "id": "Core.String.match",
        "kind": "value",
        "name": "match",
        "docstrings": [
          "`match(str, regexp)` matches a `string` against the given `regexp`. If there is\nno match, it returns `None`. For regular expressions without the g modifier, if\nthere is a match, the return value is `Some(array)` where the array contains:\n- The entire matched string\n- Any capture groups if the regexp had parentheses\nFor regular expressions with the g modifier, a matched expression returns\n`Some(array)` with all the matched substrings and no capture groups.\nSee [`String.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match) on MDN.\n\n## Examples\n\n```rescript\nString.match(\"The better bats\", %re(\"/b[aeiou]t/\")) == Some([Some(\"bet\")])\nString.match(\"The better bats\", %re(\"/b[aeiou]t/g\")) == Some([Some(\"bet\"), Some(\"bat\")])\nString.match(\"Today is 2018-04-05.\", %re(\"/(\\d+)-(\\d+)-(\\d+)/\")) ==\n  Some([Some(\"2018-04-05\"), Some(\"2018\"), Some(\"04\"), Some(\"05\")])\nString.match(\"The optional example\", %re(\"/(foo)?(example)/\")) == Some([Some(\"example\"), None, Some(\"example\")])\nString.match(\"The large container.\", %re(\"/b[aeiou]g/\")) == None\n```"
        ],
        "signature": "let match: (string, Core__RegExp.t) => option<Core__RegExp.Result.t>"
      },
      {
        "id": "Core.String.normalize",
        "kind": "value",
        "name": "normalize",
        "docstrings": [
          "`normalize(str)` returns the normalized Unicode string using Normalization Form\nCanonical (NFC) Composition. Consider the character , which can be represented\nas the single codepoint \\u00e3 or the combination of a lower case letter A\n\\u0061 and a combining tilde \\u0303. Normalization ensures that both can be\nstored in an equivalent binary representation.\nSee [`String.normalize`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize) on MDN.\nSee also [Unicode technical report #15](https://unicode.org/reports/tr15/) for details.\n\n## Examples\n\n```rescript\nlet string1 = \"\\uFB00\"\nlet string2 = \"\\u0066\\u0066\"\nConsole.log(string1 === string2) // false\n\nlet normalizeString1 = String.normalize(string1)\nlet normalizeString2 = String.normalize(string2)\nassert(normalizeString1 === normalizeString2)\n```"
        ],
        "signature": "let normalize: string => string"
      },
      {
        "id": "Core.String.normalizeForm",
        "kind": "type",
        "name": "normalizeForm",
        "docstrings": [
          "`normalizeByForm(str, form)` returns the normalized Unicode string using the\nspecified form of normalization, which may be one of:\n- \"NFC\"  Normalization Form Canonical Composition.\n- \"NFD\"  Normalization Form Canonical Decomposition.\n- \"NFKC\"  Normalization Form Compatibility Composition.\n- \"NFKD\"  Normalization Form Compatibility Decomposition.\nSee [`String.normalize`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize) on MDN.\nSee also [Unicode technical report #15](https://unicode.org/reports/tr15/) for\ndetails.\n\n## Examples\n\n```rescript\nlet string1 = \"\\uFB00\"\nlet string2 = \"\\u0066\\u0066\"\nConsole.log(string1 == string2) // false\n\nlet normalizeString1 = String.normalizeByForm(string1, #NFKD)\nlet normalizeString2 = String.normalizeByForm(string2, #NFKD)\nConsole.log(normalizeString1 == normalizeString2) // true\n```"
        ],
        "signature": "type normalizeForm = [#NFC | #NFD | #NFKC | #NFKD]"
      },
      {
        "id": "Core.String.normalizeByForm",
        "kind": "value",
        "name": "normalizeByForm",
        "docstrings": [],
        "signature": "let normalizeByForm: (string, normalizeForm) => string"
      },
      {
        "id": "Core.String.repeat",
        "kind": "value",
        "name": "repeat",
        "docstrings": [
          "`repeat(str, n)` returns a `string` that consists of `n` repetitions of `str`.\nSee [`String.repeat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat) on MDN.\n\n## Examples\n\n```rescript\nString.repeat(\"ha\", 3) == \"hahaha\"\nString.repeat(\"empty\", 0) == \"\"\n```\n\n## Exceptions\n\n- `RangeError`: if `n` is negative."
        ],
        "signature": "let repeat: (string, int) => string"
      },
      {
        "id": "Core.String.replace",
        "kind": "value",
        "name": "replace",
        "docstrings": [
          "`replace(str, substr, newSubstr)` returns a new `string` which is\nidentical to `str` except with the first matching instance of `substr` replaced\nby `newSubstr`. `substr` is treated as a verbatim string to match, not a\nregular expression.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nString.replace(\"old string\", \"old\", \"new\") == \"new string\"\nString.replace(\"the cat and the dog\", \"the\", \"this\") == \"this cat and the dog\"\n```"
        ],
        "signature": "let replace: (string, string, string) => string"
      },
      {
        "id": "Core.String.replaceRegExp",
        "kind": "value",
        "name": "replaceRegExp",
        "docstrings": [
          "`replaceRegExp(str, regex, replacement)` returns a new `string` where\noccurrences matching regex have been replaced by `replacement`.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nString.replaceRegExp(\"vowels be gone\", %re(\"/[aeiou]/g\"), \"x\") == \"vxwxls bx gxnx\"\nString.replaceRegExp(\"Juan Fulano\", %re(\"/(\\w+) (\\w+)/\"), \"$2, $1\") == \"Fulano, Juan\"\n```"
        ],
        "signature": "let replaceRegExp: (string, Core__RegExp.t, string) => string"
      },
      {
        "id": "Core.String.replaceAll",
        "kind": "value",
        "name": "replaceAll",
        "docstrings": [
          "`replaceAll(str, substr, newSubstr)` returns a new `string` which is\nidentical to `str` except with all matching instances of `substr` replaced\nby `newSubstr`. `substr` is treated as a verbatim string to match, not a\nregular expression.\nSee [`String.replaceAll`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll) on MDN.\n\n## Examples\n\n```rescript\nString.replaceAll(\"old old string\", \"old\", \"new\") == \"new new string\"\nString.replaceAll(\"the cat and the dog\", \"the\", \"this\") == \"this cat and this dog\"\n```"
        ],
        "signature": "let replaceAll: (string, string, string) => string"
      },
      {
        "id": "Core.String.replaceAllRegExp",
        "kind": "value",
        "name": "replaceAllRegExp",
        "docstrings": [
          "`replaceAllRegExp(str, regex, replacement)` returns a new `string` where\nall occurrences matching regex have been replaced by `replacement`.\nThe pattern must include the global (`g`) flag or a runtime TypeError will be thrown.\nSee [`String.replaceAll`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll) on MDN.\n\n## Examples\n\n```rescript\nString.replaceAllRegExp(\"vowels be gone\", %re(\"/[aeiou]/g\"), \"x\") == \"vxwxls bx gxnx\"\nString.replaceAllRegExp(\"aabbcc\", %re(\"/b/g\"), \".\") == \"aa..cc\"\n```"
        ],
        "signature": "let replaceAllRegExp: (string, Core__RegExp.t, string) => string"
      },
      {
        "id": "Core.String.unsafeReplaceRegExpBy0",
        "kind": "value",
        "name": "unsafeReplaceRegExpBy0",
        "docstrings": [
          "`unsafeReplaceRegExpBy0(str, regex, f)` returns a new `string` with some or all\nmatches of a pattern with no capturing parentheses replaced by the value\nreturned from the given function. The function receives as its parameters the\nmatched string, the offset at which the match begins, and the whole string being\nmatched.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nlet str = \"beautiful vowels\"\nlet re = %re(\"/[aeiou]/g\")\nlet matchFn = (~match, ~offset as _, ~input as _) => String.toUpperCase(match)\nString.unsafeReplaceRegExpBy0(str, re, matchFn) == \"bEAUtIfUl vOwEls\"\n```"
        ],
        "signature": "let unsafeReplaceRegExpBy0: (\n  string,\n  Core__RegExp.t,\n  (~match: string, ~offset: int, ~input: string) => string,\n) => string"
      },
      {
        "id": "Core.String.unsafeReplaceRegExpBy1",
        "kind": "value",
        "name": "unsafeReplaceRegExpBy1",
        "docstrings": [
          "`unsafeReplaceRegExpBy1(str, regexp, f)`. Like `unsafeReplaceRegExpBy0`, but `f`\nhas `group1` parameter.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nlet str = \"Jony is 40\"\nlet re = %re(\"/(Jony is )\\d+/g\")\nlet matchFn = (~match as _, ~group1, ~offset as _, ~input as _) => {\n  group1 ++ \"41\"\n}\nString.unsafeReplaceRegExpBy1(str, re, matchFn) == \"Jony is 41\"\n```"
        ],
        "signature": "let unsafeReplaceRegExpBy1: (\n  string,\n  Core__RegExp.t,\n  (\n    ~match: string,\n    ~group1: string,\n    ~offset: int,\n    ~input: string,\n  ) => string,\n) => string"
      },
      {
        "id": "Core.String.unsafeReplaceRegExpBy2",
        "kind": "value",
        "name": "unsafeReplaceRegExpBy2",
        "docstrings": [
          "`unsafeReplaceRegExpBy2(str, regexp, f)`. Like `unsafeReplaceRegExpBy1`, but `f`\nhas two group parameters.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN.\n\n## Examples\n\n```rescript\nlet str = \"7 times 6\"\nlet re = %re(\"/(\\d+) times (\\d+)/\")\nlet matchFn = (~match as _, ~group1, ~group2, ~offset as _, ~input as _) => {\n  switch (Int.fromString(group1), Int.fromString(group2)) {\n  | (Some(x), Some(y)) => Int.toString(x * y)\n  | _ => \"???\"\n  }\n}\nString.unsafeReplaceRegExpBy2(str, re, matchFn) == \"42\"\n```"
        ],
        "signature": "let unsafeReplaceRegExpBy2: (\n  string,\n  Core__RegExp.t,\n  (\n    ~match: string,\n    ~group1: string,\n    ~group2: string,\n    ~offset: int,\n    ~input: string,\n  ) => string,\n) => string"
      },
      {
        "id": "Core.String.unsafeReplaceRegExpBy3",
        "kind": "value",
        "name": "unsafeReplaceRegExpBy3",
        "docstrings": [
          "`unsafeReplaceRegExpBy3(str, regexp, f)`. Like `unsafeReplaceRegExpBy1`, but `f`\nhas three group parameters.\nSee [`String.replace`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) on MDN."
        ],
        "signature": "let unsafeReplaceRegExpBy3: (\n  string,\n  Core__RegExp.t,\n  (\n    ~match: string,\n    ~group1: string,\n    ~group2: string,\n    ~group3: string,\n    ~offset: int,\n    ~input: string,\n  ) => string,\n) => string"
      },
      {
        "id": "Core.String.search",
        "kind": "value",
        "name": "search",
        "docstrings": [
          "`search(str, regexp)` returns the starting position of the first match of\n`regexp` in the given `str`, or -1 if there is no match.\nSee [`String.search`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search) on MDN.\n\n## Examples\n\n```rescript\nString.search(\"testing 1 2 3\", %re(\"/\\d+/\")) == 8\nString.search(\"no numbers\", %re(\"/\\d+/\")) == -1\n```"
        ],
        "signature": "let search: (string, Core__RegExp.t) => int"
      },
      {
        "id": "Core.String.searchOpt",
        "kind": "value",
        "name": "searchOpt",
        "docstrings": [
          "`searchOpt(str, regexp)`. Like `search`, but return an `option<int>`.\n\n## Examples\n\n```rescript\nString.searchOpt(\"testing 1 2 3\", %re(\"/\\d+/\")) == Some(8)\nString.searchOpt(\"no numbers\", %re(\"/\\d+/\")) == None\n```"
        ],
        "signature": "let searchOpt: (string, Core__RegExp.t) => option<int>"
      },
      {
        "id": "Core.String.slice",
        "kind": "value",
        "name": "slice",
        "docstrings": [
          "`slice(str, ~start, ~end)` returns the substring of `str` starting at\ncharacter `start` up to but not including `end`.\n- If either `start` or `end` is negative, then it is evaluated as\n`length(str - start)` or `length(str - end)`.\n- If `end` is greater than the length of `str`, then it is treated as\n`length(str)`.\n- If `start` is greater than `end`, slice returns the empty string.\nSee [`String.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) on MDN.\n\n## Examples\n\n```rescript\nString.slice(\"abcdefg\", ~start=2, ~end=5) == \"cde\"\nString.slice(\"abcdefg\", ~start=2, ~end=9) == \"cdefg\"\nString.slice(\"abcdefg\", ~start=-4, ~end=-2) == \"de\"\nString.slice(\"abcdefg\", ~start=5, ~end=1) == \"\"\n```"
        ],
        "signature": "let slice: (string, ~start: int, ~end: int) => string"
      },
      {
        "id": "Core.String.sliceToEnd",
        "kind": "value",
        "name": "sliceToEnd",
        "docstrings": [
          "`sliceToEnd(str, ~start)` returns the substring of `str` starting at character\n`start` to the end of the string.\n- If `start` is negative, then it is evaluated as `length(str - start)`.\n- If `start` is greater than the length of `str`, then sliceToEnd returns the empty string.\nSee [`String.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) on MDN.\n\n## Examples\n\n```rescript\nString.sliceToEnd(\"abcdefg\", ~start=4) == \"efg\"\nString.sliceToEnd(\"abcdefg\", ~start=-2) == \"fg\"\nString.sliceToEnd(\"abcdefg\", ~start=7) == \"\"\n```"
        ],
        "signature": "let sliceToEnd: (string, ~start: int) => string"
      },
      {
        "id": "Core.String.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(str, delimiter)` splits the given `str` at every occurrence of\n`delimiter` and returns an array of the resulting substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.split(\"2018-01-02\", \"-\") == [\"2018\", \"01\", \"02\"]\nString.split(\"a,b,,c\", \",\") == [\"a\", \"b\", \"\", \"c\"]\nString.split(\"good::bad as great::awful\", \"::\") == [\"good\", \"bad as great\", \"awful\"]\nString.split(\"has-no-delimiter\", \";\") == [\"has-no-delimiter\"]\n```"
        ],
        "signature": "let split: (string, string) => array<string>"
      },
      {
        "id": "Core.String.splitAtMost",
        "kind": "value",
        "name": "splitAtMost",
        "docstrings": [
          "`splitAtMost(str, delimiter, ~limit)` splits the given `str` at every\noccurrence of `delimiter` and returns an array of the first `limit` resulting\nsubstrings. If `limit` is negative or greater than the number of substrings,\nthe array will contain all the substrings.\n\n## Examples\n\n```rescript\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=3) == [\"ant\", \"bee\", \"cat\"]\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=0) == []\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=9) == [\"ant\", \"bee\", \"cat\", \"dog\", \"elk\"]\n```"
        ],
        "signature": "let splitAtMost: (string, string, ~limit: int) => array<string>"
      },
      {
        "id": "Core.String.splitByRegExp",
        "kind": "value",
        "name": "splitByRegExp",
        "docstrings": [
          "`splitByRegExp(str, regexp)` splits the given `str` at every occurrence of\n`regexp` and returns an array of the resulting substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.splitByRegExp(\"Jan,Feb,Mar\", %re(\"/,/\")) == [Some(\"Jan\"), Some(\"Feb\"), Some(\"Mar\")]\n```"
        ],
        "signature": "let splitByRegExp: (string, Core__RegExp.t) => array<option<string>>"
      },
      {
        "id": "Core.String.splitByRegExpAtMost",
        "kind": "value",
        "name": "splitByRegExpAtMost",
        "docstrings": [
          "`splitByRegExpAtMost(str, regexp, ~limit)` splits the given `str` at every\noccurrence of `regexp` and returns an array of the first `limit` resulting\nsubstrings. If `limit` is negative or greater than the number of substrings, the\narray will contain all the substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.splitByRegExpAtMost(\"Hello World. How are you doing?\", %re(\"/ /\"), ~limit=3) == [\n  Some(\"Hello\"),\n  Some(\"World.\"),\n  Some(\"How\"),\n]\n```"
        ],
        "signature": "let splitByRegExpAtMost: (\n  string,\n  Core__RegExp.t,\n  ~limit: int,\n) => array<option<string>>"
      },
      {
        "id": "Core.String.startsWith",
        "kind": "value",
        "name": "startsWith",
        "docstrings": [
          "`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```"
        ],
        "signature": "let startsWith: (string, string) => bool"
      },
      {
        "id": "Core.String.startsWithFrom",
        "kind": "value",
        "name": "startsWithFrom",
        "docstrings": [
          "`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```"
        ],
        "signature": "let startsWithFrom: (string, string, int) => bool"
      },
      {
        "id": "Core.String.substring",
        "kind": "value",
        "name": "substring",
        "docstrings": [
          "`substring(str, ~start, ~end)` returns characters `start` up to but not\nincluding end from `str`.\n- If `start` is less than zero, it is treated as zero.\n- If `end` is zero or negative, the empty string is returned.\n- If `start` is greater than `end`, the `start` and `end` points are swapped.\nSee [`String.substring`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring) on MDN.\n\n## Examples\n\n```rescript\nString.substring(\"playground\", ~start=3, ~end=6) == \"ygr\"\nString.substring(\"playground\", ~start=6, ~end=3) == \"ygr\"\nString.substring(\"playground\", ~start=4, ~end=12) == \"ground\"\n```"
        ],
        "signature": "let substring: (string, ~start: int, ~end: int) => string"
      },
      {
        "id": "Core.String.substringToEnd",
        "kind": "value",
        "name": "substringToEnd",
        "docstrings": [
          "`substringToEnd(str, ~start)` returns the substring of `str` from position\n`start` to the end.\n- If `start` is less than or equal to zero, the entire string is returned.\n- If `start` is greater than or equal to the length of `str`, the empty string\nis returned.\nSee [`String.substring`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring) on MDN.\n\n## Examples\n\n```rescript\nString.substringToEnd(\"playground\", ~start=4) == \"ground\"\nString.substringToEnd(\"playground\", ~start=-3) == \"playground\"\nString.substringToEnd(\"playground\", ~start=12) == \"\"\n```"
        ],
        "signature": "let substringToEnd: (string, ~start: int) => string"
      },
      {
        "id": "Core.String.toLowerCase",
        "kind": "value",
        "name": "toLowerCase",
        "docstrings": [
          "`toLowerCase(str)` converts `str` to lower case using the locale-insensitive\ncase mappings in the Unicode Character Database. Notice that the conversion can\ngive different results depending upon context, for example with the Greek\nletter sigma, which has two different lower case forms, one when it is the last\ncharacter in a string and another when it is not.\nSee [`String.toLowerCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase) on MDN.\n\n## Examples\n\n```rescript\nString.toLowerCase(\"ABC\") == \"abc\"\nString.toLowerCase(``) == ``\nString.toLowerCase(``) == ``\n```"
        ],
        "signature": "let toLowerCase: string => string"
      },
      {
        "id": "Core.String.toLocaleLowerCase",
        "kind": "value",
        "name": "toLocaleLowerCase",
        "docstrings": [
          "`toLocaleLowerCase(str)` converts `str` to lower case using the current locale.\nSee [`String.toLocaleLowerCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase) on MDN."
        ],
        "signature": "let toLocaleLowerCase: string => string"
      },
      {
        "id": "Core.String.toUpperCase",
        "kind": "value",
        "name": "toUpperCase",
        "docstrings": [
          "`toUpperCase(str)` converts `str` to upper case using the locale-insensitive\ncase mappings in the Unicode Character Database. Notice that the conversion can\nexpand the number of letters in the result, for example the German \ncapitalizes to two Ses in a row.\nSee [`String.toUpperCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) on MDN.\n\n## Examples\n\n```rescript\nString.toUpperCase(\"abc\") == \"ABC\"\nString.toUpperCase(`Strae`) == `STRASSE`\nString.toUpperCase(``) == ``\n```"
        ],
        "signature": "let toUpperCase: string => string"
      },
      {
        "id": "Core.String.toLocaleUpperCase",
        "kind": "value",
        "name": "toLocaleUpperCase",
        "docstrings": [
          "`toLocaleUpperCase(str)` converts `str` to upper case using the current locale.\nSee [`String.toLocaleUpperCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase) on MDN."
        ],
        "signature": "let toLocaleUpperCase: string => string"
      },
      {
        "id": "Core.String.trim",
        "kind": "value",
        "name": "trim",
        "docstrings": [
          "`trim(str)` returns a string that is `str` with whitespace stripped from both\nends. Internal whitespace is not removed.\nSee [`String.trim`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim) on MDN.\n\n## Examples\n\n```rescript\nString.trim(\"   abc def   \") == \"abc def\"\nString.trim(\"\\n\\r\\t abc def \\n\\n\\t\\r \") == \"abc def\"\n```"
        ],
        "signature": "let trim: string => string"
      },
      {
        "id": "Core.String.trimStart",
        "kind": "value",
        "name": "trimStart",
        "docstrings": [
          "`trimStart(str)` returns a string that is `str` with whitespace stripped from\nthe beginning of a string. Internal whitespace is not removed.\nSee [`String.trimStart`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart) on MDN.\n\n## Examples\n\n```rescript\nString.trimStart(\"   Hello world!   \") == \"Hello world!   \"\nString.trimStart(\"   Hello   world!   \") == \"Hello   world!   \"\n```"
        ],
        "signature": "let trimStart: string => string"
      },
      {
        "id": "Core.String.trimEnd",
        "kind": "value",
        "name": "trimEnd",
        "docstrings": [
          "`trinEnd(str)` returns a string that is `str` with whitespace stripped from the\nend of a string. Internal whitespace is not removed.\nSee [`String.trimEnd`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd) on MDN.\n\n## Examples\n\n```rescript\nString.trimEnd(\"   Hello world!   \") == \"   Hello world!\"\nString.trimEnd(\"   Hello   world!   \") == \"   Hello   world!\"\n```"
        ],
        "signature": "let trimEnd: string => string"
      },
      {
        "id": "Core.String.padStart",
        "kind": "value",
        "name": "padStart",
        "docstrings": [
          "`padStart(str, n, padStr)` returns a string that has been padded with `padStr`\n(multiple times, if needed) until the resulting string reaches the given `n`\nlength. The padding is applied from the start of the current string.\nSee [`String.padStart`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart) on MDN.\n\n## Examples\n\n```rescript\nString.padStart(\"abc\", 5, \" \") == \"  abc\"\nString.padStart(\"abc\", 6, \"123465\") == \"123abc\"\n```"
        ],
        "signature": "let padStart: (string, int, string) => string"
      },
      {
        "id": "Core.String.padEnd",
        "kind": "value",
        "name": "padEnd",
        "docstrings": [
          "`padEnd(str, n, padStr)` returns a string that has been padded with `padStr`\n(multiple times, if needed) until the resulting string reaches the given `n`\nlength. The padding is applied from the end of the current string.\nSee [`String.padEnd`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd) on MDN.\n\n## Examples\n\n```rescript\nString.padEnd(\"Hello\", 10, \".\") == \"Hello.....\"\nString.padEnd(\"abc\", 1, \"\") == \"abc\"\n```"
        ],
        "signature": "let padEnd: (string, int, string) => string"
      },
      {
        "id": "Core.String.getSymbol",
        "kind": "value",
        "name": "getSymbol",
        "docstrings": [],
        "signature": "let getSymbol: (string, Core__Symbol.t) => option<'a>"
      },
      {
        "id": "Core.String.getSymbolUnsafe",
        "kind": "value",
        "name": "getSymbolUnsafe",
        "docstrings": [],
        "signature": "let getSymbolUnsafe: (string, Core__Symbol.t) => 'a"
      },
      {
        "id": "Core.String.setSymbol",
        "kind": "value",
        "name": "setSymbol",
        "docstrings": [],
        "signature": "let setSymbol: (string, Core__Symbol.t, 'a) => unit"
      },
      {
        "id": "Core.String.localeCompare",
        "kind": "value",
        "name": "localeCompare",
        "docstrings": [
          "`localeCompare(referenceStr, compareStr)` returns a float than indicatings\nwhether a reference string comes before or after, or is the same as the given\nstring in sort order. If `referenceStr` occurs before `compareStr` positive if\nthe `referenceStr` occurs after `compareStr`, `0` if they are equivalent.\nDo not rely on exact return values of `-1` or `1`\nSee [`String.localeCompare`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) on MDN.\n\n## Examples\n\n```rescript\nString.localeCompare(\"a\", \"c\") < 0.0 == true\nString.localeCompare(\"a\", \"a\") == 0.0\n```"
        ],
        "signature": "let localeCompare: (string, string) => float"
      }
    ]
  },
  "core/regexp": {
    "id": "Core.RegExp",
    "name": "RegExp",
    "docstrings": [
      "Functions for handling RegExp's in ReScript.\n\nSee [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) on MDN."
    ],
    "items": [
      {
        "id": "Core.RegExp.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Type representing an instantiated `RegExp`."
        ],
        "signature": "type t = Js.Re.t"
      },
      {
        "id": "Core.RegExp.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "`fromString(string)` creates a `RegExp.t` from the provided string. This can then be used to match on strings using `RegExp.exec`.\n\nSee [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"
        ],
        "signature": "let fromString: string => t"
      },
      {
        "id": "Core.RegExp.fromStringWithFlags",
        "kind": "value",
        "name": "fromStringWithFlags",
        "docstrings": [
          "`fromStringWithFlags(string)` creates a `RegExp.t` from the provided string, using the provided `flags`. This can then be used to match on strings using `RegExp.exec`.\n\nSee [`RegExp parameters`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp#parameters) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"
        ],
        "signature": "let fromStringWithFlags: (string, ~flags: string) => t"
      },
      {
        "id": "Core.RegExp.test",
        "kind": "value",
        "name": "test",
        "docstrings": [
          "`test(regexp, string)` tests whether the provided `regexp` matches on the provided string.\n\nSee [`RegExp.test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nif regexp->RegExp.test(\"ReScript is cool!\") {\n  Console.log(\"Yay, there's a word in there.\")\n}\n```"
        ],
        "signature": "let test: (t, string) => bool"
      },
      {
        "id": "Core.RegExp.exec",
        "kind": "value",
        "name": "exec",
        "docstrings": [
          "`exec(regexp, string)` executes the provided regexp on the provided string, optionally returning a `RegExp.Result.t` if the regexp matches on the string.\n\nSee [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\n\nswitch regexp->RegExp.exec(\"ReScript is pretty cool, right?\") {\n| None => Console.log(\"Nope, no match...\")\n| Some(result) => Console.log(result->RegExp.Result.fullMatch) // Prints \"ReScript\"\n}\n```"
        ],
        "signature": "let exec: (t, string) => option<Result.t>"
      },
      {
        "id": "Core.RegExp.lastIndex",
        "kind": "value",
        "name": "lastIndex",
        "docstrings": [
          "`lastIndex(regexp)` returns the index the next match will start from.\n\nSee [`RegExp.lastIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\nlet someStr = \"Many words here.\"\n\nConsole.log(regexp->RegExp.lastIndex) // Logs `0` to the console\n\nregexp->RegExp.exec(someStr)->ignore\n\nConsole.log(regexp->RegExp.lastIndex) // Logs `4` to the console\n```"
        ],
        "signature": "let lastIndex: t => int"
      },
      {
        "id": "Core.RegExp.setLastIndex",
        "kind": "value",
        "name": "setLastIndex",
        "docstrings": [
          "`setLastIndex(regexp, index)` set the index the next match will start from.\n\nSee [`RegExp.lastIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex) on MDN.\n\n## Examples\n```rescript\n// Match the first word in a sentence\nlet regexp = RegExp.fromString(\"\\\\w+\")\nlet someStr = \"Many words here.\"\n\nregexp->RegExp.setLastIndex(4)\nregexp->RegExp.exec(someStr)->ignore\n\nConsole.log(regexp->RegExp.lastIndex) // Logs `10` to the console\n```"
        ],
        "signature": "let setLastIndex: (t, int) => unit"
      },
      {
        "id": "Core.RegExp.ignoreCase",
        "kind": "value",
        "name": "ignoreCase",
        "docstrings": [
          "`ignoreCase(regexp)` returns whether the ignore case (`i`) flag is set on this `RegExp`.\n\nSee [`RegExp.ignoreCase`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.ignoreCase) // Logs `false`, since `i` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"i\")\nConsole.log(regexp2->RegExp.ignoreCase) // Logs `true`, since `i` is set\n```"
        ],
        "signature": "let ignoreCase: t => bool"
      },
      {
        "id": "Core.RegExp.global",
        "kind": "value",
        "name": "global",
        "docstrings": [
          "`global(regexp)` returns whether the global (`g`) flag is set on this `RegExp`.\n\nSee [`RegExp.global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.global) // Logs `true`, since `g` is set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"i\")\nConsole.log(regexp2->RegExp.global) // Logs `false`, since `g` is not set\n```"
        ],
        "signature": "let global: t => bool"
      },
      {
        "id": "Core.RegExp.multiline",
        "kind": "value",
        "name": "multiline",
        "docstrings": [
          "`multiline(regexp)` returns whether the multiline (`m`) flag is set on this `RegExp`.\n\nSee [`RegExp.multiline`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.multiline) // Logs `false`, since `m` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"mi\")\nConsole.log(regexp2->RegExp.multiline) // Logs `true`, since `m` is set\n```"
        ],
        "signature": "let multiline: t => bool"
      },
      {
        "id": "Core.RegExp.source",
        "kind": "value",
        "name": "source",
        "docstrings": [
          "`source(regexp)` returns the source text for this `RegExp`, without the two forward slashes (if present), and without any set flags.\n\nSee [`RegExp.source`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source) on MDN.\n\n## Examples\n```rescript\nlet regexp = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp->RegExp.source) // Logs `\\w+`, the source text of the `RegExp`\n```"
        ],
        "signature": "let source: t => string"
      },
      {
        "id": "Core.RegExp.sticky",
        "kind": "value",
        "name": "sticky",
        "docstrings": [
          "`sticky(regexp)` returns whether the sticky (`y`) flag is set on this `RegExp`.\n\nSee [`RegExp.sticky`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.unicode) // Logs `false`, since `y` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"my\")\nConsole.log(regexp2->RegExp.unicode) // Logs `true`, since `y` is set\n```"
        ],
        "signature": "let sticky: t => bool"
      },
      {
        "id": "Core.RegExp.unicode",
        "kind": "value",
        "name": "unicode",
        "docstrings": [
          "`unicode(regexp)` returns whether the unicode (`y`) flag is set on this `RegExp`.\n\nSee [`RegExp.unicode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode) on MDN.\n\n## Examples\n```rescript\nlet regexp1 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"g\")\nConsole.log(regexp1->RegExp.unicode) // Logs `false`, since `u` is not set\n\nlet regexp2 = RegExp.fromStringWithFlags(\"\\\\w+\", ~flags=\"mu\")\nConsole.log(regexp2->RegExp.unicode) // Logs `true`, since `u` is set\n```"
        ],
        "signature": "let unicode: t => bool"
      }
    ]
  },
  "core/promise": {
    "id": "Core.Promise",
    "name": "Promise",
    "docstrings": [
      "Functions for interacting with JavaScript Promise.\nSee: [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)."
    ],
    "items": [
      {
        "id": "Core.Promise.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a> = promise<'a>"
      },
      {
        "id": "Core.Promise.resolve",
        "kind": "value",
        "name": "resolve",
        "docstrings": [
          "`resolve(value)` creates a resolved Promise with a given `value`.\nSee [`Promise.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) on MDN.\n\n## Examples\n\n```rescript\nlet p = Promise.resolve(5) // promise<int>\n```"
        ],
        "signature": "let resolve: 'a => t<'a>"
      },
      {
        "id": "Core.Promise.reject",
        "kind": "value",
        "name": "reject",
        "docstrings": [
          "`reject(exn)` reject a Promise.\nSee [`Promise.reject`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject) on MDN.\n\n## Examples\n\n```rescript\nexception TestError(string)\n\nlet p = Promise.reject(TestError(\"some rejected value\"))\n```"
        ],
        "signature": "let reject: exn => t<'a>"
      },
      {
        "id": "Core.Promise.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(callback)` creates a new Promise based on a `callback` that receives two\nuncurried functions `resolve` and `reject` for defining the Promise's result.\n\n## Examples\n\n```rescript\nopen Promise\n\nlet n = 4\nPromise.make((resolve, reject) => {\n  if(n < 5) {\n    resolve(. \"success\")\n  }\n  else {\n    reject(. \"failed\")\n  }\n})\n->then(str => {\n  Console.log(str)->resolve\n})\n->catch(_ => {\n  Console.log(\"Error occurred\")\n  resolve()\n})\n->ignore\n```"
        ],
        "signature": "let make: (('a => unit, 'e => unit) => unit) => t<'a>"
      },
      {
        "id": "Core.Promise.promiseAndResolvers",
        "kind": "type",
        "name": "promiseAndResolvers",
        "docstrings": [],
        "signature": "type promiseAndResolvers<'a> = {\n  promise: t<'a>,\n  resolve: 'a => unit,\n  reject: exn => unit,\n}"
      },
      {
        "id": "Core.Promise.withResolvers",
        "kind": "value",
        "name": "withResolvers",
        "docstrings": [
          "`withResolvers()` returns a object containing a new promise with functions to resolve or reject it. See [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) on MDN.\n\n## Examples\n\n```rescript\nopen Promise\n\nlet {promise, resolve, _} = Promise.withResolvers()\n\nsetTimeout(() => {\n  resolve(. \"success\")\n}, 1000)->ignore\n\npromise\n->thenResolve(str => {\n  Console.log(str)\n})\n->ignore\n```"
        ],
        "signature": "let withResolvers: unit => promiseAndResolvers<'a>"
      },
      {
        "id": "Core.Promise.catch",
        "kind": "value",
        "name": "catch",
        "docstrings": [
          "`catch(promise, errorCallback)` registers an exception handler in a promise chain.\nThe `errorCallback` receives an `exn` value that can later be refined into a JS\nerror or ReScript error. The `errorCallback` needs to return a promise with the\nsame type as the consumed promise. See [`Promise.catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch) on MDN.\n\n## Examples\n\n```rescript\nopen Promise\n\nexception SomeError(string)\n\nreject(SomeError(\"this is an error\"))\n->then(_ => {\n  Ok(\"This result will never be returned\")->resolve\n})\n->catch(e => {\n  let msg = switch(e) {\n    | SomeError(msg) => \"ReScript error occurred: \" ++ msg\n    | Exn.Error(obj) =>\n      switch Exn.message(obj) {\n        | Some(msg) => \"JS exception occurred: \" ++ msg\n        | None => \"Some other JS value has been thrown\"\n      }\n    | _ => \"Unexpected error occurred\"\n  }\n\n  Error(msg)->resolve\n})\n->then(result => {\n  switch result {\n  | Ok(r) => Console.log2(\"Operation successful: \", r)\n  | Error(msg) => Console.log2(\"Operation failed: \", msg)\n  }->resolve\n})\n->ignore // Ignore needed for side-effects\n```\n\nIn case you want to return another promise in your `callback`, consider using\n`then` instead."
        ],
        "signature": "let catch: (t<'a>, exn => t<'a>) => t<'a>"
      },
      {
        "id": "Core.Promise.then",
        "kind": "value",
        "name": "then",
        "docstrings": [
          "`then(promise, callback)` returns a new promise based on the result of `promise`'s \nvalue. The `callback` needs to explicitly return a new promise via `resolve`.\nIt is **not allowed** to resolve a nested promise (like `resolve(resolve(1))`).\nSee [`Promise.then`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) on MDN.\n## Examples\n\n```rescript\nopen Promise\nresolve(5)\n->then(num => {\n  resolve(num + 5)\n})\n->then(num => {\n  Console.log2(\"Your lucky number is: \", num)\n  resolve()\n})\n->ignore\n```"
        ],
        "signature": "let then: (t<'a>, 'a => t<'b>) => t<'b>"
      },
      {
        "id": "Core.Promise.thenResolve",
        "kind": "value",
        "name": "thenResolve",
        "docstrings": [
          "`thenResolve(promise, callback)` converts an encapsulated value of a promise\ninto another promise wrapped value. It is **not allowed** to return a promise\nwithin the provided callback (e.g. `thenResolve(value => resolve(value))`).\n\n## Examples\n\n```rescript\nopen Promise\nresolve(\"Anna\")\n->thenResolve(str => {\n  \"Hello \" ++ str\n})\n->thenResolve(str => {\n  Console.log(str)\n})\n->ignore // Ignore needed for side-effects\n```\n\nIn case you want to return another promise in your `callback`, consider using\n`then` instead."
        ],
        "signature": "let thenResolve: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Core.Promise.finally",
        "kind": "value",
        "name": "finally",
        "docstrings": [
          "`finally(promise, callback)` is used to execute a function that is called no\nmatter if a promise was resolved or rejected. It will return the same `promise`\nit originally received. See [`Promise.finally`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally) on MDN.\n\n## Examples\n\n```rescript\nopen Promise\nexception SomeError(string)\nlet isDone = ref(false)\n\nresolve(5)\n->then(_ => {\n  reject(SomeError(\"test\"))\n})\n->then(v => {\n  Console.log2(\"final result\", v)\n  resolve()\n})\n->catch(_ => {\n  Console.log(\"Error handled\")\n  resolve()\n})\n->finally(() => {\n  Console.log(\"finally\")\n  isDone := true\n})\n->then(() => {\n  Console.log2(\"isDone:\", isDone.contents)\n  resolve()\n})\n->ignore\n```"
        ],
        "signature": "let finally: (t<'a>, unit => unit) => t<'a>"
      },
      {
        "id": "Core.Promise.race",
        "kind": "value",
        "name": "race",
        "docstrings": [
          "`race(arr)` runs all promises concurrently and returns promise settles with the eventual state of the first promise that settles. See [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) on MDN.\n\n## Examples\n\n```rescript\nopen Promise\nlet racer = (ms, name) => {\n  Promise.make((resolve, _) => {\n    setTimeout(() => {\n      resolve(name)\n    }, ms)->ignore\n  })\n}\n\nlet promises = [racer(1000, \"Turtle\"), racer(500, \"Hare\"), racer(100, \"Eagle\")]\n\nrace(promises)->then(winner => {\n  Console.log(\"The winner is \" ++ winner)\n  resolve()\n})\n```"
        ],
        "signature": "let race: array<t<'a>> => t<'a>"
      },
      {
        "id": "Core.Promise.any",
        "kind": "value",
        "name": "any",
        "docstrings": [
          "`any(arr)` runs all promises concurrently and returns promise fulfills when any of the input's promises fulfills, with this first fulfillment value. See [`Promise.any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any) on MDN.\n\n## Examples\n\n```rescript\nopen Promise\nlet racer = (ms, name) => {\n  Promise.make((resolve, _) => {\n    setTimeout(() => {\n      resolve(name)\n    }, ms)->ignore\n  })\n}\n\nlet promises = [racer(1000, \"Turtle\"), racer(500, \"Hare\"), racer(100, \"Eagle\")]\n\nany(promises)->then(winner => {\n  Console.log(\"The winner is \" ++ winner)\n  resolve()\n})\n```"
        ],
        "signature": "let any: array<t<'a>> => t<'a>"
      },
      {
        "id": "Core.Promise.all",
        "kind": "value",
        "name": "all",
        "docstrings": [
          "`all(promises)` runs all promises concurrently and returns a promise fulfills when all of the input's promises fulfill, with an array of the fulfillment values. See [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) on MDN.\n\n```rescript\nopen Promise\nlet promises = [resolve(1), resolve(2), resolve(3)]\n\nall(promises)\n->then((results) => {\n  results->Array.forEach(num => {\n    Console.log2(\"Number: \", num)\n  })\n\n  resolve()\n})\n->ignore\n```"
        ],
        "signature": "let all: array<t<'a>> => t<array<'a>>"
      },
      {
        "id": "Core.Promise.all2",
        "kind": "value",
        "name": "all2",
        "docstrings": [
          "`all2((p1, p2))`. Like `all()`, but with a fixed size tuple of 2"
        ],
        "signature": "let all2: ((t<'a>, t<'b>)) => t<('a, 'b)>"
      },
      {
        "id": "Core.Promise.all3",
        "kind": "value",
        "name": "all3",
        "docstrings": [
          "`all3((p1, p2, p3))`. Like `all()`, but with a fixed size tuple of 3"
        ],
        "signature": "let all3: ((t<'a>, t<'b>, t<'c>)) => t<('a, 'b, 'c)>"
      },
      {
        "id": "Core.Promise.all4",
        "kind": "value",
        "name": "all4",
        "docstrings": [
          "`all4((p1, p2, p3, p4))`. Like `all()`, but with a fixed size tuple of 4"
        ],
        "signature": "let all4: ((t<'a>, t<'b>, t<'c>, t<'d>)) => t<('a, 'b, 'c, 'd)>"
      },
      {
        "id": "Core.Promise.all5",
        "kind": "value",
        "name": "all5",
        "docstrings": [
          "`all5((p1, p2, p3, p4, p5))`. Like `all()`, but with a fixed size tuple of 5"
        ],
        "signature": "let all5: (\n  (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>),\n) => t<('a, 'b, 'c, 'd, 'e)>"
      },
      {
        "id": "Core.Promise.all6",
        "kind": "value",
        "name": "all6",
        "docstrings": [
          "`all6((p1, p2, p4, p5, p6))`. Like `all()`, but with a fixed size tuple of 6\n\")"
        ],
        "signature": "let all6: (\n  (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, t<'f>),\n) => t<('a, 'b, 'c, 'd, 'e, 'f)>"
      },
      {
        "id": "Core.Promise.settledResult",
        "kind": "type",
        "name": "settledResult",
        "docstrings": [],
        "signature": "type settledResult<'a> =\n  | Fulfilled({value: 'a})\n  | Rejected({reason: exn})"
      },
      {
        "id": "Core.Promise.allSettled",
        "kind": "value",
        "name": "allSettled",
        "docstrings": [
          "`allSettled(promises)` runs all promises concurrently and returns promise fulfills when all of the input's promises settle with an array of objects that describe the outcome of each promise. See [`Promise.allSettled`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled) on MDN.\n\n```rescript\nopen Promise\n\nexception TestError(string)\n\nlet promises = [resolve(1), resolve(2), reject(TestError(\"some rejected promise\"))]\n\nallSettled(promises)\n->then((results) => {\n  results->Array.forEach((result) => {\n    switch result {\n      | Fulfilled({value: num}) => \n        Console.log2(\"Number: \", num)\n      | Rejected({reason}) =>\n        Console.log(reason)\n    }\n  })\n\n  resolve()\n})\n->ignore\n```"
        ],
        "signature": "let allSettled: array<t<'a>> => t<array<settledResult<'a>>>"
      },
      {
        "id": "Core.Promise.allSettled2",
        "kind": "value",
        "name": "allSettled2",
        "docstrings": [
          "`allSettled2((p1, p2))`. Like `allSettled()`, but with a fixed size tuple of 2"
        ],
        "signature": "let allSettled2: (\n  (t<'a>, t<'b>),\n) => t<(settledResult<'a>, settledResult<'b>)>"
      },
      {
        "id": "Core.Promise.allSettled3",
        "kind": "value",
        "name": "allSettled3",
        "docstrings": [
          "`allSettled3((p1, p2, p3))`. Like `allSettled()`, but with a fixed size tuple of 3"
        ],
        "signature": "let allSettled3: (\n  (t<'a>, t<'b>, t<'c>),\n) => t<\n  (settledResult<'a>, settledResult<'b>, settledResult<'c>),\n>"
      },
      {
        "id": "Core.Promise.allSettled4",
        "kind": "value",
        "name": "allSettled4",
        "docstrings": [
          "`allSettled4((p1, p2, p3, p4))`. Like `allSettled()`, but with a fixed size tuple of 4"
        ],
        "signature": "let allSettled4: (\n  (t<'a>, t<'b>, t<'c>, t<'d>),\n) => t<\n  (\n    settledResult<'a>,\n    settledResult<'b>,\n    settledResult<'c>,\n    settledResult<'d>,\n  ),\n>"
      },
      {
        "id": "Core.Promise.allSettled5",
        "kind": "value",
        "name": "allSettled5",
        "docstrings": [
          "`allSettled5((p1, p2, p3, p4, p5))`. Like `allSettled()`, but with a fixed size tuple of 5"
        ],
        "signature": "let allSettled5: (\n  (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>),\n) => t<\n  (\n    settledResult<'a>,\n    settledResult<'b>,\n    settledResult<'c>,\n    settledResult<'d>,\n    settledResult<'e>,\n  ),\n>"
      },
      {
        "id": "Core.Promise.allSettled6",
        "kind": "value",
        "name": "allSettled6",
        "docstrings": [
          "`allSettled6((p1, p2, p4, p5, p6))`. Like `allSettled()`, but with a fixed size tuple of 6\n\")"
        ],
        "signature": "let allSettled6: (\n  (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, t<'f>),\n) => t<\n  (\n    settledResult<'a>,\n    settledResult<'b>,\n    settledResult<'c>,\n    settledResult<'d>,\n    settledResult<'e>,\n    settledResult<'f>,\n  ),\n>"
      },
      {
        "id": "Core.Promise.done",
        "kind": "value",
        "name": "done",
        "docstrings": [
          "`done(p)` is a safe way to ignore a promise. If a value is anything else than a\npromise, it will raise a type error."
        ],
        "signature": "let done: promise<'a> => unit"
      }
    ]
  },
  "core/ordering": {
    "id": "Core.Ordering",
    "name": "Ordering",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Ordering.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = float"
      },
      {
        "id": "Core.Ordering.less",
        "kind": "value",
        "name": "less",
        "docstrings": [],
        "signature": "let less: float"
      },
      {
        "id": "Core.Ordering.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: float"
      },
      {
        "id": "Core.Ordering.greater",
        "kind": "value",
        "name": "greater",
        "docstrings": [],
        "signature": "let greater: float"
      },
      {
        "id": "Core.Ordering.isLess",
        "kind": "value",
        "name": "isLess",
        "docstrings": [],
        "signature": "let isLess: float => bool"
      },
      {
        "id": "Core.Ordering.isEqual",
        "kind": "value",
        "name": "isEqual",
        "docstrings": [],
        "signature": "let isEqual: float => bool"
      },
      {
        "id": "Core.Ordering.isGreater",
        "kind": "value",
        "name": "isGreater",
        "docstrings": [],
        "signature": "let isGreater: float => bool"
      },
      {
        "id": "Core.Ordering.invert",
        "kind": "value",
        "name": "invert",
        "docstrings": [],
        "signature": "let invert: float => float"
      },
      {
        "id": "Core.Ordering.fromInt",
        "kind": "value",
        "name": "fromInt",
        "docstrings": [],
        "signature": "let fromInt: int => float"
      }
    ]
  },
  "core/object": {
    "id": "Core.Object",
    "name": "Object",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Object.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make` create a new object that inherits the properties and methods from the standard built-in Object, such as `toString`. See [Object on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)\n\n## Examples\n\n```rescript\nlet x = Object.make()\nx->Object.keysToArray->Array.length // 0\nx->Object.get(\"toString\")->Option.isSome // true\n```"
        ],
        "signature": "let make: unit => {..}"
      },
      {
        "id": "Core.Object.is",
        "kind": "value",
        "name": "is",
        "docstrings": [
          "`is` determines if two objects are identical in all contexts. Objects, arrays, records, and other non-primitives are only identical if they reference the **exact** same object in memory. Primitives like ints, floats, and strings are identical if they have the same value. `+0` and `-0` are distinct. NaN is equal to itself. See [Object.is on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)\n\nIn most scenarios use `==` or `===` or the custom `equals` function (if provided) for the type.\n\n## Examples\n\n```rescript\nObject.is(25, 13) // false\nObject.is(\"abc\", \"abc\") // true\nObject.is(undefined, undefined) // true\nObject.is(undefined, null) // false\nObject.is(-0.0, 0.0) // false\nObject.is(list{1, 2}, list{1, 2}) // false\n\nObject.is([1, 2, 3], [1, 2, 3]) // false\n[1, 2, 3] == [1, 2, 3] // true\n[1, 2, 3] === [1, 2, 3] // false\n\nlet fruit = {\"name\": \"Apple\" }\nObject.is(fruit, fruit) // true\nObject.is(fruit, {\"name\": \"Apple\" }) // false\nfruit == {\"name\": \"Apple\" } // true\nfruit === {\"name\": \"Apple\" } // false\n```"
        ],
        "signature": "let is: ('a, 'a) => bool"
      },
      {
        "id": "Core.Object.create",
        "kind": "value",
        "name": "create",
        "docstrings": [
          "`create` creates a new object, using an existing object as the prototype of the new object. See [Object.create on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n**Note:** ReScript provides [first-class support for immutable objects](https://rescript-lang.org/docs/manual/latest/object) and [records](https://rescript-lang.org/docs/manual/latest/record). This is often safer and more convenient than using `create` and other functions in this module.\n\n## Examples\n\n```rescript\nlet x = {\"fruit\": \"banana\"}\nlet y = Object.create(x)\ny->Object.get(\"fruit\") // Some(\"banana\")\n```"
        ],
        "signature": "let create: {..} => {..}"
      },
      {
        "id": "Core.Object.createWithProperties",
        "kind": "value",
        "name": "createWithProperties",
        "docstrings": [],
        "signature": "let createWithProperties: ({..}, {..}) => {..}"
      },
      {
        "id": "Core.Object.createWithNull",
        "kind": "value",
        "name": "createWithNull",
        "docstrings": [],
        "signature": "let createWithNull: unit => {..}"
      },
      {
        "id": "Core.Object.createWithNullAndProperties",
        "kind": "value",
        "name": "createWithNullAndProperties",
        "docstrings": [],
        "signature": "let createWithNullAndProperties: {..} => {..}"
      },
      {
        "id": "Core.Object.assign",
        "kind": "value",
        "name": "assign",
        "docstrings": [
          "`assign(target, source)` copies enumerable own properties from the source to the target, overwriting properties with the same name. It returns the modified target object. A deep clone is not created; properties are copied by reference.\n\n**Warning:** ReScript provides compile-time support for type-safe access to JavaScript objects. This eliminates common errors such as accessing properties that do not exist, or using a property of type x as if it were a y. Using `assign` can bypass these safety checks and lead to run-time errors (if you are not careful). ReScript provides [first-class support for immutable objects](https://rescript-lang.org/docs/manual/latest/object) and [records](https://rescript-lang.org/docs/manual/latest/record). This is often safer and more convenient than using `assign` and other functions in this module.\n\nSee [Object.assign on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign).\n\n## Examples\n\n```rescript\nObject.assign({\"a\": 1}, {\"a\": 2}) // {\"a\": 2}\nObject.assign({\"a\": 1, \"b\": 2}, {\"a\": 0}) // {\"a\": 0, \"b\": 2}\nObject.assign({\"a\": 1}, {\"a\": null}) // {\"a\": null}\n```"
        ],
        "signature": "let assign: ({..}, {..}) => {..}"
      },
      {
        "id": "Core.Object.assignMany",
        "kind": "value",
        "name": "assignMany",
        "docstrings": [
          "`assignMany(target, sources)` copies enumerable own properties from each source to the target, overwriting properties with the same name. Later sources' properties overwrite earlier ones. It returns the modified target object. A deep clone is not created; properties are copied by reference.\n\n**Note:** ReScript provides [first-class support for immutable objects](https://rescript-lang.org/docs/manual/latest/object), including spreading one object into another. This is often more convenient than using `assign` or `assignMany`.  \n\nSee [Object.assign on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign)."
        ],
        "signature": "let assignMany: ({..}, array<{..}>) => {..}"
      },
      {
        "id": "Core.Object.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: ({..} as 'a) => 'a"
      },
      {
        "id": "Core.Object.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "`get` gets the value of a property by name. Returns `None` if the property does not exist or has the value `undefined`. Otherwise returns `Some`, including if the value is `null`.\n\n## Examples\n\n```rescript\n{\"a\": 1}->Object.get(\"a\") // Some(1)\n{\"a\": 1}->Object.get(\"b\") // None\n{\"a\": undefined}->Object.get(\"a\") // None\n{\"a\": null}->Object.get(\"a\") // Some(null)\n{\"a\": 1}->Object.get(\"toString\")->Option.isSome // true\n```"
        ],
        "signature": "let get: ({..}, string) => option<'a>"
      },
      {
        "id": "Core.Object.getSymbol",
        "kind": "value",
        "name": "getSymbol",
        "docstrings": [
          "`getSymbol` gets the value of a property by symbol. Returns `None` if the property does not exist or has the value `undefined`. Otherwise returns `Some`, including if the value is `null`.\n\n## Examples\n\n```rescript\nlet fruit = Symbol.make(\"fruit\")\nlet x = Object.make()\nx->Object.setSymbol(fruit, \"banana\")\nx->Object.getSymbol(fruit) // Some(\"banana\")\n```"
        ],
        "signature": "let getSymbol: ({..}, Core__Symbol.t) => option<'a>"
      },
      {
        "id": "Core.Object.getSymbolUnsafe",
        "kind": "value",
        "name": "getSymbolUnsafe",
        "docstrings": [],
        "signature": "let getSymbolUnsafe: ({..}, Core__Symbol.t) => 'a"
      },
      {
        "id": "Core.Object.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(name, value)` assigns a value to the named object property, overwriting the previous value if any. See [Working with Objects on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#objects_and_properties)\n\n## Examples\n\n```rescript\n{\"a\": 1}->Object.set(\"a\", 2) // {\"a\": 2}\n{\"a\": 1}->Object.set(\"a\", None) // {\"a\": None}\n{\"a\": 1}->Object.set(\"b\", 2) // {\"a\": 1, \"b\": 2}\n```"
        ],
        "signature": "let set: ({..}, string, 'a) => unit"
      },
      {
        "id": "Core.Object.setSymbol",
        "kind": "value",
        "name": "setSymbol",
        "docstrings": [],
        "signature": "let setSymbol: ({..}, Core__Symbol.t, 'a) => unit"
      },
      {
        "id": "Core.Object.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [
          "`keysToArray` returns an array of an object's own enumerable string-keyed property names. See [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.keys) \nor [Object.keys on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys).\n\n## Examples\n\n```rescript\n{\"a\": 1, \"b\": 2}->Object.keysToArray // [\"a\", \"b\"]\n{\"a\": None}->Object.keysToArray // [\"a\"]\nObject.make()->Object.keysToArray // []\n```"
        ],
        "signature": "let keysToArray: {..} => array<string>"
      },
      {
        "id": "Core.Object.hasOwnProperty",
        "kind": "value",
        "name": "hasOwnProperty",
        "docstrings": [
          "`hasOwnProperty` determines whether the object has the specified property as its **own** property, as opposed to inheriting it. See [hasOwnProperty on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 2}\n{\"a\": 1}->Object.hasOwnProperty(\"a\") // true\n{\"a\": 1}->Object.hasOwnProperty(\"b\") // false\n{\"a\": 1}->Object.hasOwnProperty(\"toString\") // false\n```"
        ],
        "signature": "let hasOwnProperty: ({..}, string) => bool"
      },
      {
        "id": "Core.Object.seal",
        "kind": "value",
        "name": "seal",
        "docstrings": [
          "`seal` seals an object. Sealing an object prevents extensions and makes existing properties non-configurable. A sealed object has a fixed set of properties. Unlike `freeze`, values of existing properties can still be changed as long as they are writable. \n\n**Note:** `seal` returns the same object that was passed in; it does not create a copy. Any attempt to delete or add properties to a sealed object will fail, either silently or by throwing an error. \n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.seal) and [Object.seal on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 2}\npoint->Object.set(\"x\", -7) // succeeds\npoint->Object.seal->ignore\npoint->Object.set(\"z\", 9) // fails\npoint->Object.set(\"x\", 13) // succeeds\n```"
        ],
        "signature": "let seal: ({..} as 'a) => 'a"
      },
      {
        "id": "Core.Object.preventExtensions",
        "kind": "value",
        "name": "preventExtensions",
        "docstrings": [
          "`preventExtensions` prevents new properties from being added to the object. It modifies the object (rather than creating a copy) and returns it.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.preventextensions) and [Object.preventExtensions on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)\n\n## Examples\n\n```rescript\nlet obj = {\"a\": 1}\nobj->Object.set(\"b\", 2) // succeeds\nobj->Object.preventExtensions->ignore\nobj->Object.set(\"c\", 3) // fails\n```"
        ],
        "signature": "let preventExtensions: ({..} as 'a) => 'a"
      },
      {
        "id": "Core.Object.freeze",
        "kind": "value",
        "name": "freeze",
        "docstrings": [
          "`freeze` freezes an object. Freezing an object makes existing properties non-writable and prevents extensions. Once an object is frozen, new properties cannot be be added, existing properties cannot be removed, and their values cannot be changed.\n\n**Note:** `freeze` returns the same object that was passed in; it does not create a frozen copy. Any attempt to change a frozen object will fail, either silently or by throwing an exception.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.isfrozen) and [Object.isFrozen on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen).\n\n## Examples\n\n ```rescript\nlet obj = {\"a\": 1}\nobj->Object.set(\"a\", 2) // succeeds\nobj->Object.freeze->ignore\nobj->Object.set(\"a\", 3) // fails\n```"
        ],
        "signature": "let freeze: ({..} as 'a) => 'a"
      },
      {
        "id": "Core.Object.isSealed",
        "kind": "value",
        "name": "isSealed",
        "docstrings": [
          "`isSealed` determines if an object is sealed. A sealed object has a fixed set of properties.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.issealed) and [Object.isSealed on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed)\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 3}->Object.seal\nlet pointIsSealed = point->Object.isSealed // true\nlet fruit = {\"name\": \"Apple\" }\nlet fruitIsSealed = fruit->Object.isSealed // false\n ```"
        ],
        "signature": "let isSealed: 'a => bool"
      },
      {
        "id": "Core.Object.isFrozen",
        "kind": "value",
        "name": "isFrozen",
        "docstrings": [
          "`isFrozen` determines if an object is frozen. An object is frozen if an only if it is not extensible, all its properties are non-configurable, and all its data properties are non-writable.\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.isfrozen) and [Object.isFrozen on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen).\n\n## Examples\n\n```rescript\nlet point = {\"x\": 1, \"y\": 3}->Object.freeze\nlet pointIsFrozen = point->Object.isFrozen // true\nlet fruit = {\"name\": \"Apple\" }\nlet fruitIsFrozen = fruit->Object.isFrozen // false\n ```"
        ],
        "signature": "let isFrozen: 'a => bool"
      },
      {
        "id": "Core.Object.isExtensible",
        "kind": "value",
        "name": "isExtensible",
        "docstrings": [
          "`isExtensible` determines if an object is extensible (whether it can have new properties added to it).\n\nSee [ECMAScript Language Specification](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.isextensible) and [Object.isExtensible on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)\n\n## Examples\n\n```rescript\nlet obj = {\"a\": 1}\nobj->Object.isExtensible // true\nobj->Object.preventExtensions->ignore\nobj->Object.isExtensible // false\n```"
        ],
        "signature": "let isExtensible: 'a => bool"
      }
    ]
  },
  "core/nullable": {
    "id": "Core.Nullable",
    "name": "Nullable",
    "docstrings": [
      "Functions for handling nullable values.\n\nPrimarily useful when interoping with JavaScript when you don't know whether you'll get a value, `null` or `undefined`."
    ],
    "items": [
      {
        "id": "Core.Nullable.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Type representing a nullable value.\nA nullable value can be the value `'a`, `null` or `undefined`."
        ],
        "signature": "type t<'a> = Js.Nullable.t<'a> =\n  | Value('a)\n  | Null\n  | Undefined"
      },
      {
        "id": "Core.Nullable.null",
        "kind": "value",
        "name": "null",
        "docstrings": [
          "The value `null`.\n\nSee [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null) on MDN.\n\n## Examples\n```rescript\nConsole.log(Nullable.null) // Logs `null` to the console.\n```"
        ],
        "signature": "let null: t<'a>"
      },
      {
        "id": "Core.Nullable.undefined",
        "kind": "value",
        "name": "undefined",
        "docstrings": [
          "The value `undefined`.\n\nSee [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/undefined) on MDN.\n\n## Examples\n```rescript\nConsole.log(undefined) // Logs `undefined` to the console.\n```"
        ],
        "signature": "let undefined: t<'a>"
      },
      {
        "id": "Core.Nullable.isNullable",
        "kind": "value",
        "name": "isNullable",
        "docstrings": [
          "`isNullable(a)` returns `true` if `a` is null or undefined, `false` otherwise.\n\n## Examples\n\n```rescript\nlet myStr = \"Hello\"\nlet asNullable = myStr->Nullable.make\n\n// Can't do the below because we're now forced to check for nullability\n// myStr == asNullable\n\n// Check if asNullable is not null or undefined\nswitch asNullable->Nullable.isNullable {\n| true => assert(false)\n| false => assert(true)\n}\n```"
        ],
        "signature": "let isNullable: t<'a> => bool"
      },
      {
        "id": "Core.Nullable.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new nullable value from the provided value.\nThis means the compiler will enforce null checks for the new value.\n\n## Examples\n```rescript\nlet myStr = \"Hello\"\nlet asNullable = myStr->Nullable.make\n\n// Can't do the below because we're now forced to check for nullability\n// myStr == asNullable\n\n// Need to do this\nswitch asNullable->Nullable.toOption {\n| Some(value) if value == myStr => Console.log(\"Yay, values matched!\")\n| _ => Console.log(\"Values did not match.\")\n}\n```"
        ],
        "signature": "let make: 'a => t<'a>"
      },
      {
        "id": "Core.Nullable.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.Nullable.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (\n  t<'a>,\n  t<'b>,\n  ('a, 'b) => Core__Ordering.t,\n) => Core__Ordering.t"
      },
      {
        "id": "Core.Nullable.toOption",
        "kind": "value",
        "name": "toOption",
        "docstrings": [
          "Converts a nullable value into an option, so it can be pattern matched on.\nWill convert both `null` and `undefined` to `None`, and a present value to `Some(value)`.\n\n## Examples\n```rescript\nlet nullableString = Nullable.make(\"Hello\")\n\nswitch nullableString->Nullable.toOption {\n| Some(str) => Console.log2(\"Got string:\", str)\n| None => Console.log(\"Didn't have a value.\")\n}\n```"
        ],
        "signature": "let toOption: t<'a> => option<'a>"
      },
      {
        "id": "Core.Nullable.fromOption",
        "kind": "value",
        "name": "fromOption",
        "docstrings": [
          "Turns an `option` into a `Nullable.t`.\n\n## Examples\n```rescript\nlet optString = Some(\"Hello\")\nlet asNullable = optString->Nullable.fromOption // Nullable.t<string>\n```"
        ],
        "signature": "let fromOption: option<'a> => t<'a>"
      },
      {
        "id": "Core.Nullable.getOr",
        "kind": "value",
        "name": "getOr",
        "docstrings": [
          "`getOr(value, default)` returns `value` if not `null` or `undefined`,\notherwise return `default`.\n\n## Examples\n\n```rescript\nNullable.getOr(Nullable.null, \"Banana\") // Banana\nNullable.getOr(Nullable.make(\"Apple\"), \"Banana\") // Apple\n\nlet greet = (firstName: option<string>) =>\n  \"Greetings \" ++ firstName->Option.getOr(\"Anonymous\")\n\nNullable.make(\"Jane\")->Nullable.toOption->greet // \"Greetings Jane\"\nNullable.null->Nullable.toOption->greet // \"Greetings Anonymous\"\n```"
        ],
        "signature": "let getOr: (t<'a>, 'a) => 'a"
      },
      {
        "id": "Core.Nullable.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'a>, 'a) => 'a",
        "deprecated": "Use getOr instead"
      },
      {
        "id": "Core.Nullable.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(value)` raises an exception if `null` or `undefined`, otherwise returns the value.\n\n```rescript\nNullable.getExn(Nullable.make(3)) // 3\nNullable.getExn(Nullable.null) /* Raises an Error */\n```\n\n## Exceptions\n\n- Raises `Invalid_argument` if `value` is `null` or `undefined`"
        ],
        "signature": "let getExn: t<'a> => 'a"
      },
      {
        "id": "Core.Nullable.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(value)` returns `value`.\n\n## Examples\n\n```rescript\nNullable.getUnsafe(Nullable.make(3)) == 3\nNullable.getUnsafe(Nullable.null) // Raises an error\n```\n\n## Important\n\n- This is an unsafe operation, it assumes `value` is not `null` or `undefined`."
        ],
        "signature": "let getUnsafe: t<'a> => 'a"
      },
      {
        "id": "Core.Nullable.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(value, f)` call `f` on `value`. if `value` is not `null` or `undefined`, \nthen if calls `f`, otherwise returns `unit`.\n\n## Examples\n\n```rescript\nNullable.forEach(Nullable.make(\"thing\"), x => Console.log(x)) // logs \"thing\"\nNullable.forEach(Nullable.null, x => Console.log(x)) // returns ()\nNullable.forEach(undefined, x => Console.log(x)) // returns ()\n```"
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.Nullable.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(value, f)` returns `f(value)` if `value` is not `null` or `undefined`,\notherwise returns `value` unchanged.\n\n## Examples\n\n```rescript\nNullable.map(Nullable.make(3), x => x * x) // Nullable.make(9)\nNullable.map(undefined, x => x * x) // undefined\n```"
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Core.Nullable.mapOr",
        "kind": "value",
        "name": "mapOr",
        "docstrings": [
          "`mapOr(value, default, f)` returns `f(value)` if `value` is not `null`\nor `undefined`, otherwise returns `default`.\n\n## Examples\n\n```rescript\nlet someValue = Nullable.make(3)\nsomeValue->Nullable.mapOr(0, x => x + 5) // 8\n\nlet noneValue = Nullable.null\nnoneValue->Nullable.mapOr(0, x => x + 5) // 0\n```"
        ],
        "signature": "let mapOr: (t<'a>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Core.Nullable.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [],
        "signature": "let mapWithDefault: (t<'a>, 'b, 'a => 'b) => 'b",
        "deprecated": "Use mapOr instead"
      },
      {
        "id": "Core.Nullable.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(value, f)` returns `f(value)` if `value` is not `null` or `undefined`,\notherwise returns `value` unchanged.\n\n## Examples\n\n```rescript\nlet addIfAboveOne = value =>\n  if (value > 1) {\n    Nullable.make(value + 1)\n  } else {\n    Nullable.null\n  }\n\nNullable.flatMap(Nullable.make(2), addIfAboveOne) // Nullable.make(3)\nNullable.flatMap(Nullable.make(-4), addIfAboveOne) // undefined\nNullable.flatMap(Nullable.null, addIfAboveOne) // undefined\n```"
        ],
        "signature": "let flatMap: (t<'a>, 'a => t<'b>) => t<'b>"
      }
    ]
  },
  "core/null": {
    "id": "Core.Null",
    "name": "Null",
    "docstrings": [
      "Functions for handling values that could be `null`.\n\nIf you also need to cover `undefined`, check out `Nullable` instead."
    ],
    "items": [
      {
        "id": "Core.Null.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "A type representing a value that can be either `'a` or `null`."
        ],
        "signature": "type t<'a> = Js.Null.t<'a> = Value('a) | Null"
      },
      {
        "id": "Core.Null.asNullable",
        "kind": "value",
        "name": "asNullable",
        "docstrings": [
          "Converts a `Null.t` into a `Nullable.t`.\n\n## Examples\n```rescript\nlet nullValue = Null.make(\"Hello\")\nlet asNullable = nullValue->Null.asNullable // Nullable.t<string>\n```"
        ],
        "signature": "let asNullable: t<'a> => Core__Nullable.t<'a>"
      },
      {
        "id": "Core.Null.null",
        "kind": "value",
        "name": "null",
        "docstrings": [
          "The value `null`.\n\nSee [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null) on MDN.\n\n## Examples\n```rescript\nConsole.log(null) // Logs `null` to the console.\n```"
        ],
        "signature": "let null: t<'a>"
      },
      {
        "id": "Core.Null.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new `Null.t` from the provided value.\nThis means the compiler will enforce null checks for the new value.\n\n## Examples\n```rescript\nlet myStr = \"Hello\"\nlet asNullValue = myStr->Null.make // The compiler now thinks this can be `string` or `null`.\n```"
        ],
        "signature": "let make: 'a => t<'a>"
      },
      {
        "id": "Core.Null.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Core.Null.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (\n  t<'a>,\n  t<'b>,\n  ('a, 'b) => Core__Ordering.t,\n) => Core__Ordering.t"
      },
      {
        "id": "Core.Null.toOption",
        "kind": "value",
        "name": "toOption",
        "docstrings": [
          "Converts a nullable value into an option, so it can be pattern matched on.\nWill convert `null` to `None`, and a present value to `Some(value)`.\n\n## Examples\n```rescript\nlet nullStr = Null.make(\"Hello\")\n\nswitch nullStr->Null.toOption {\n| Some(str) => Console.log2(\"Got string:\", str)\n| None => Console.log(\"Didn't have a value.\")\n}\n```"
        ],
        "signature": "let toOption: t<'a> => option<'a>"
      },
      {
        "id": "Core.Null.fromOption",
        "kind": "value",
        "name": "fromOption",
        "docstrings": [
          "Turns an `option` into a `Null.t`. `None` will be converted to `null`.\n\n## Examples\n```rescript\nlet optString: option<string> = None\nlet asNull = optString->Null.fromOption // Null.t<string>\nConsole.log(asNull == Null.null) // Logs `true` to the console.\n```"
        ],
        "signature": "let fromOption: option<'a> => t<'a>"
      },
      {
        "id": "Core.Null.getOr",
        "kind": "value",
        "name": "getOr",
        "docstrings": [
          "`getOr(value, default)` returns `value` if not `null`, otherwise return\n`default`.\n\n## Examples\n\n```rescript\nNull.getOr(Null.null, \"Banana\") // Banana\nNull.getOr(Null.make(\"Apple\"), \"Banana\") // Apple\n\nlet greet = (firstName: option<string>) =>\n  \"Greetings \" ++ firstName->Option.getOr(\"Anonymous\")\n\nNull.make(\"Jane\")->Null.toOption->greet // \"Greetings Jane\"\nNull.null->Null.toOption->greet // \"Greetings Anonymous\"\n```"
        ],
        "signature": "let getOr: (t<'a>, 'a) => 'a"
      },
      {
        "id": "Core.Null.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'a>, 'a) => 'a",
        "deprecated": "Use getOr instead"
      },
      {
        "id": "Core.Null.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(value)` raises an exception if `null`, otherwise returns the value.\n\n```rescript\nNull.getExn(Null.make(3)) // 3\nNull.getExn(Null.null) /* Raises an Error */\n```\n\n## Exceptions\n\n- Raises `Invalid_argument` if `value` is `null`,"
        ],
        "signature": "let getExn: t<'a> => 'a"
      },
      {
        "id": "Core.Null.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(value)` returns `value`.\n\n## Examples\n\n```rescript\nNull.getUnsafe(Null.make(3)) == 3\nNull.getUnsafe(Null.null) // Raises an error\n```\n\n## Important\n\n- This is an unsafe operation, it assumes `value` is not `null`."
        ],
        "signature": "let getUnsafe: t<'a> => 'a"
      },
      {
        "id": "Core.Null.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(value, f)` call `f` on `value`. if `value` is not `null`, then if calls\n`f`, otherwise returns `unit`.\n\n## Examples\n\n```rescript\nNull.forEach(Null.make(\"thing\"), x => Console.log(x)) // logs \"thing\"\nNull.forEach(Null.null, x => Console.log(x)) // logs nothing\n```"
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.Null.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(value, f)` returns `f(value)` if `value` is not `null`, otherwise returns\n`value` unchanged.\n\n## Examples\n\n```rescript\nNull.map(Null.make(3), x => x * x) // Null.make(9)\nNull.map(Null.null, x => x * x) // null\n```"
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Core.Null.mapOr",
        "kind": "value",
        "name": "mapOr",
        "docstrings": [
          "`mapOr(value, default, f)` returns `f(value)` if `value` is not `null`,\notherwise returns `default`.\n\n## Examples\n\n```rescript\nlet someValue = Null.make(3)\nsomeValue->Null.mapOr(0, x => x + 5) // 8\n\nlet noneValue = Null.null\nnoneValue->Null.mapOr(0, x => x + 5) // 0\n```"
        ],
        "signature": "let mapOr: (t<'a>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Core.Null.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [],
        "signature": "let mapWithDefault: (t<'a>, 'b, 'a => 'b) => 'b",
        "deprecated": "Use mapOr instead"
      },
      {
        "id": "Core.Null.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(value, f)` returns `f(value)` if `value` is not `null`, otherwise\nreturns `value` unchanged.\n\n## Examples\n\n```rescript\nlet addIfAboveOne = value =>\n  if (value > 1) {\n    Null.make(value + 1)\n  } else {\n    Null.null\n  }\n\nNull.flatMap(Null.make(2), addIfAboveOne) // Null.make(3)\nNull.flatMap(Null.make(-4), addIfAboveOne) // null\nNull.flatMap(Null.null, addIfAboveOne) // null\n```"
        ],
        "signature": "let flatMap: (t<'a>, 'a => t<'b>) => t<'b>"
      }
    ]
  },
  "core/math": {
    "id": "Core.Math",
    "name": "Math",
    "docstrings": [
      "Functions for interacting with JavaScript Math.\nSee: [`Math`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math)."
    ],
    "items": [
      {
        "id": "Core.Math.abs",
        "kind": "value",
        "name": "abs",
        "docstrings": [
          "`abs(v)` returns absolute value of `v`.\nSee [`Math.abs`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs) on MDN.\n\n## Examples\n\n```rescript\nMath.abs(-2.0) // 2.0\nMath.abs(3.0) // 3.0\n```"
        ],
        "signature": "let abs: float => float"
      },
      {
        "id": "Core.Math.acos",
        "kind": "value",
        "name": "acos",
        "docstrings": [
          "`acos(v)` returns arccosine (in radians) of argument `v`, returns `NaN` if the\nargument is outside the range [-1.0, 1.0].\nSee [`Math.acos`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acos) on MDN.\n\n## Examples\n\n```rescript\nMath.acos(-1.0) // 3.141592653589793\nMath.acos(-3.0)->Float.isNaN // true\n```"
        ],
        "signature": "let acos: float => float"
      },
      {
        "id": "Core.Math.acosh",
        "kind": "value",
        "name": "acosh",
        "docstrings": [
          "`acosh(v)` returns the inverse hyperbolic arccosine (in radians) of argument `v`,\nreturns `NaN` if the argument is less than `1.0`.\nSee [`Math.acosh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh) on MDN.\n\n## Examples\n\n```rescript\nMath.acosh(1.0) // 0.0\nMath.acosh(0.5)->Float.isNaN // true\n```"
        ],
        "signature": "let acosh: float => float"
      },
      {
        "id": "Core.Math.asin",
        "kind": "value",
        "name": "asin",
        "docstrings": [
          "`asin(v)` returns the inverse sine (in radians) of argument `v`, returns `NaN`\nif the argument `v` is outside the range [-1.0, 1.0].\nSee [`Math.asin`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asin) on MDN.\n\n## Examples\n\n```rescript\nMath.asin(-1.0) // -1.5707963267948966\nMath.asin(-2.0)->Float.isNaN // true\n```"
        ],
        "signature": "let asin: float => float"
      },
      {
        "id": "Core.Math.asinh",
        "kind": "value",
        "name": "asinh",
        "docstrings": [
          "`asinh(v)` returns the inverse hyperbolic sine of argument `v`.\nSee [`Math.asinh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh) on MDN.\n\n## Examples\n\n```rescript\nMath.asinh(-1.0) // -0.881373587019543\nMath.asinh(-0.0) // -0.0\n```"
        ],
        "signature": "let asinh: float => float"
      },
      {
        "id": "Core.Math.atan",
        "kind": "value",
        "name": "atan",
        "docstrings": [
          "`atan(v)` returns the inverse tangent (in radians) of argument `v`.\nSee [`Math.atan`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan) on MDN.\n\n## Examples\n\n```rescript\nMath.atan(-0.0) // -0.0\nMath.atan(0.0) // 0.0\nMath.atan(1.0) // 0.7853981633974483\n```"
        ],
        "signature": "let atan: float => float"
      },
      {
        "id": "Core.Math.atanh",
        "kind": "value",
        "name": "atanh",
        "docstrings": [
          "`atanh(v)` returns the invert hyperbolic tangent of argument `v`. Returns `NaN`\nif the argument `v` is is outside the range [-1.0, 1.0] and `Infinity` if `v`\nis `-1.0` or `1.0`.\nSee [`Math.atanh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh) on MDN.\n\n## Examples\n\n```rescript\nMath.atanh(-2.0)->Float.isNaN // true\nMath.atanh(-1.0)->Float.isFinite // false\nMath.atanh(-0.0) // -0.0\nMath.atanh(0.0) // 0.0\nMath.atanh(0.5) // 0.5493061443340548\n```"
        ],
        "signature": "let atanh: float => float"
      },
      {
        "id": "Core.Math.atan2",
        "kind": "value",
        "name": "atan2",
        "docstrings": [
          "`atan2(~y, ~x)` returns the angle (in radians) of the quotient `y /. x`. It is\nalso the angle between the *x*-axis and point (*x*, *y*).\nSee [`Math.atan2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2) on MDN.\n\n## Examples\n\n```rescript\nMath.atan2(~y=0.0, ~x=10.0) == 0.0\nMath.atan2(~x=5.0, ~y=5.0) == Math.Constants.pi /. 4.0\nMath.atan2(~x=90.0, ~y=15.0) // 1.4056476493802699\nMath.atan2(~x=15.0, ~y=90.0) // 0.16514867741462683\n```"
        ],
        "signature": "let atan2: (~y: float, ~x: float) => float"
      },
      {
        "id": "Core.Math.cbrt",
        "kind": "value",
        "name": "cbrt",
        "docstrings": [
          "`cbrt(v)` returns the cube root of argument `v`.\nSee [`Math.cbrt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt) on MDN.\n\n## Examples\n\n```rescript\nMath.cbrt(-1.0) // -1.0\nMath.cbrt(-0.0) // -0.0\nMath.cbrt(0.0) // 0.0\n```"
        ],
        "signature": "let cbrt: float => float"
      },
      {
        "id": "Core.Math.ceil",
        "kind": "value",
        "name": "ceil",
        "docstrings": [
          "`ceil(v)` returns the smallest integral value greater than or equal to the\nargument `v`. The result is a `float` and is not restricted to the `int` data\ntype range.\nSee [`Math.ceil`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil) on MDN.\n\n## Examples\n\n```rescript\nMath.ceil(3.1) == 4.0\nMath.ceil(3.0) == 3.0\nMath.ceil(-3.1) == -3.0\nMath.ceil(2_150_000_000.3) == 2_150_000_001.0\n```"
        ],
        "signature": "let ceil: float => float"
      },
      {
        "id": "Core.Math.cos",
        "kind": "value",
        "name": "cos",
        "docstrings": [
          "`cos(v)` returns the cosine of argument `v`, which must be specified in radians.\nSee [`Math.cos`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cos) on MDN.\n\n## Examples\n\n```rescript\nMath.cos(-0.0) // 1.0\nMath.cos(0.0) // 1.0\nMath.cos(1.0) // 0.5403023058681398\n```"
        ],
        "signature": "let cos: float => float"
      },
      {
        "id": "Core.Math.cosh",
        "kind": "value",
        "name": "cosh",
        "docstrings": [
          "`cosh(v)` returns the hyperbolic cosine of argument `v`, which must be specified\nin radians.\nSee [`Math.cosh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh) on MDN.\n\n## Examples\n\n```rescript\nMath.cosh(-1.0) // 1.5430806348152437\nMath.cosh(-0.0) // 1.0\nMath.cosh(0.0) // 1.0\n```"
        ],
        "signature": "let cosh: float => float"
      },
      {
        "id": "Core.Math.exp",
        "kind": "value",
        "name": "exp",
        "docstrings": [
          "`exp(v)` returns natural exponentional, returns *e* (the base of natural logarithms)\nto the power of the given argument `v`.\nSee [`Math.exp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/exp) on MDN.\n\n## Examples\n\n```rescript\nMath.exp(-1.0) // 0.36787944117144233\nMath.exp(0.0) // 1.0\n```"
        ],
        "signature": "let exp: float => float"
      },
      {
        "id": "Core.Math.expm1",
        "kind": "value",
        "name": "expm1",
        "docstrings": [
          "`expm1(v)` returns *e* (the base of natural logarithms) to the power of the given\nargument `v` minus 1.\nSee [`Math.expm1`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1) on MDN.\n\n## Examples\n\n```rescript\nMath.expm1(-1.0) // -0.6321205588285577\nMath.expm1(-0.0) // -0\n```"
        ],
        "signature": "let expm1: float => float"
      },
      {
        "id": "Core.Math.floor",
        "kind": "value",
        "name": "floor",
        "docstrings": [
          "`floor(v)` returns the largest integral value less than or equal to the argument\n`v`. The result is a `float` and is not restricted to the `int` data type range.\nSee [`Math.floor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor) on MDN.\n\n## Examples\n\n```rescript\nMath.floor(-45.95) // -46.0\nMath.floor(-45.05) // -46.0\nMath.floor(-0.0) // -0.0\n```"
        ],
        "signature": "let floor: float => float"
      },
      {
        "id": "Core.Math.fround",
        "kind": "value",
        "name": "fround",
        "docstrings": [
          "`fround(v)` returns the nearest single precision float.\nSee [`Math.fround`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround) on MDN.\n\n## Examples\n\n```rescript\nMath.fround(5.5) == 5.5\nMath.fround(5.05) == 5.050000190734863\n```"
        ],
        "signature": "let fround: float => float"
      },
      {
        "id": "Core.Math.hypot",
        "kind": "value",
        "name": "hypot",
        "docstrings": [
          "`hypot(a, b)` returns the square root of the sum of squares of its two arguments\n(the Pythagorean formula).\nSee [`Math.hypot`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot) on MDN.\n\n## Examples\n\n```rescript\nMath.hypot(3.0, 4.0) // 5.0\nMath.hypot(3.0, 5.0) // 5.8309518948453\n```"
        ],
        "signature": "let hypot: (float, float) => float"
      },
      {
        "id": "Core.Math.hypotMany",
        "kind": "value",
        "name": "hypotMany",
        "docstrings": [
          "`hypotMany(arr)` returns the square root of the sum of squares of the numbers in\nthe array argument (generalized Pythagorean equation). Using an array allows you\nto have more than two items. If `arr` is an empty array then returns `0.0`.\nSee [`Math.hypot`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot) on MDN.\n\n## Examples\n\n```rescript\nMath.hypotMany([3.0, 4.0, 5.0]) // 7.0710678118654755\nMath.hypotMany([]) // 0.0\n```"
        ],
        "signature": "let hypotMany: array<float> => float"
      },
      {
        "id": "Core.Math.log",
        "kind": "value",
        "name": "log",
        "docstrings": [
          "`log(v)` returns the natural logarithm of argument `v`, this is the number *x*\nsuch that `e^x` equals the argument. Returns `NaN` for negative arguments and\n`Infinity` for `0.0` or `-0.0`.\nSee [`Math.log`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log) on MDN.\n\n## Examples\n\n```rescript\nMath.log(-1.0)->Float.isNaN // true\nMath.log(-0.0)->Float.isFinite // false\nMath.log(0.0)->Float.isFinite // false\nMath.log(1.0) // 0\n```"
        ],
        "signature": "let log: float => float"
      },
      {
        "id": "Core.Math.log1p",
        "kind": "value",
        "name": "log1p",
        "docstrings": [
          "`log1p(v)` returns the natural logarithm of one plus the argument `v`.\nReturns `NaN` for arguments less than `-1` and `Infinity` if `v` is `-1.0`.\nSee [`Math.log1p`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p) on MDN.\n\n## Examples\n\n```rescript\nMath.log1p(-2.0)->Float.isNaN // true\nMath.log1p(-1.0)->Float.isFinite // false\nMath.log1p(-0.0) // -0\n```"
        ],
        "signature": "let log1p: float => float"
      },
      {
        "id": "Core.Math.log10",
        "kind": "value",
        "name": "log10",
        "docstrings": [
          "`log10(v)` returns the base 10 logarithm of argument `v`. Returns `NaN` for\nnegative `v`. If `v` is `-0.0` or `0.0` returns `Infinity`.\nSee [`Math.log10`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10) on MDN.\n\n## Examples\n\n```rescript\nMath.log10(-2.0)->Float.isNaN // true\nMath.log10(-0.0)->Float.isFinite // false\nMath.log10(0.0)->Float.isFinite // false\nMath.log10(1.0) // 0\n```"
        ],
        "signature": "let log10: float => float"
      },
      {
        "id": "Core.Math.log2",
        "kind": "value",
        "name": "log2",
        "docstrings": [
          "`log2(v)` returns the base 2 logarithm of argument `v`. Returns `NaN` for\nnegative `v` and `Infinity` if `v` is `-0.0` or `0.0`.\nSee [`Math.log2`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2) on MDN.\n\n## Examples\n\n```rescript\nMath.log2(-2.0)->Float.isNaN // true\nMath.log2(-0.0)->Float.isFinite // false\nMath.log2(0.0)->Float.isFinite // false\nMath.log2(1.0) // 0.0\n```"
        ],
        "signature": "let log2: float => float"
      },
      {
        "id": "Core.Math.min",
        "kind": "value",
        "name": "min",
        "docstrings": [
          "`min(a, b)` returns the minimum of its two float arguments.\nSee [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n## Examples\n\n```rescript\nMath.min(1.0, 2.0) // 1.0\nMath.min(-1.0, -2.0) // -2.0\n```"
        ],
        "signature": "let min: (float, float) => float"
      },
      {
        "id": "Core.Math.minMany",
        "kind": "value",
        "name": "minMany",
        "docstrings": [
          "`minMany(arr)` returns the minimum of the float in the given array `arr`.\nReturns `Infinity` if `arr` is empty.\nSee [`Math.min`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) on MDN.\n\n## Examples\n\n```rescript\nMath.minMany([1.0, 2.0]) // 1.0\nMath.minMany([-1.0, -2.0]) // -2.0\nMath.minMany([])->Float.isFinite // false\n```"
        ],
        "signature": "let minMany: array<float> => float"
      },
      {
        "id": "Core.Math.max",
        "kind": "value",
        "name": "max",
        "docstrings": [
          "`max(a, b)` returns the maximum of its two float arguments.\nSee [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n## Examples\n\n```rescript\nMath.max(1.0, 2.0) // 2.0\nMath.max(-1.0, -2.0) // -1.0\n```"
        ],
        "signature": "let max: (float, float) => float"
      },
      {
        "id": "Core.Math.maxMany",
        "kind": "value",
        "name": "maxMany",
        "docstrings": [
          "`maxMany(arr)` returns the maximum of the float in the given array `arr`.\nReturns `Infinity` if `arr` is empty.\nSee [`Math.max`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) on MDN.\n\n## Examples\n\n```rescript\nMath.maxMany([1.0, 2.0]) // 2.0\nMath.maxMany([-1.0, -2.0]) // -1.0\nMath.maxMany([])->Float.isFinite // false\n```"
        ],
        "signature": "let maxMany: array<float> => float"
      },
      {
        "id": "Core.Math.pow",
        "kind": "value",
        "name": "pow",
        "docstrings": [
          "`pow(a, ~exp)` raises the given base `a` to the given exponent `exp`.\nSee [`Math.pow`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow) on MDN.\n\n## Examples\n\n```rescript\nMath.pow(2.0, ~exp=4.0) // 16.0\nMath.pow(3.0, ~exp=4.0) // 81.0\n```"
        ],
        "signature": "let pow: (float, ~exp: float) => float"
      },
      {
        "id": "Core.Math.random",
        "kind": "value",
        "name": "random",
        "docstrings": [
          "`random()` returns a random number in the half-closed interval [0,1].\nSee [`Math.random`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) on MDN.\n\n## Examples\n\n```rescript\nMath.random()\n```"
        ],
        "signature": "let random: unit => float"
      },
      {
        "id": "Core.Math.round",
        "kind": "value",
        "name": "round",
        "docstrings": [
          "`round(v)` returns then value of `v` rounded to nearest integral value\n(expressed as a float). If the fractional portion of the argument `v` is greater\nthan `0.5`, the argument `v` is rounded to the float with the next higher\nabsolute value.\nSee [`Math.round`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round) on MDN.\n\n## Examples\n\n```rescript\nMath.round(-20.5) // -20.0\nMath.round(-0.1) // -0.0\nMath.round(0.0) // 0.0\nMath.round(-0.0) // -0.0\n```"
        ],
        "signature": "let round: float => float"
      },
      {
        "id": "Core.Math.sign",
        "kind": "value",
        "name": "sign",
        "docstrings": [
          "`sign(v)` returns the sign of its foat argument: `-1` if negative, `0` if\nzero, `1` if positive.\nSee [`Math.sign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign) on MDN.\n\n## Examples\n\n```rescript\nMath.sign(3.0) // 1.0\nMath.sign(-3.0) // 1.0\nMath.sign(0.0) // 0.0\n```"
        ],
        "signature": "let sign: float => float"
      },
      {
        "id": "Core.Math.sin",
        "kind": "value",
        "name": "sin",
        "docstrings": [
          "`sin(v)` returns the sine of argument `v`, which must be specified in radians.\nSee [`Math.sin`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sin) on MDN.\n\n## Examples\n\n```rescript\nMath.sin(-0.0) // -0.0\nMath.sin(0.0) // 0.0\nMath.sin(1.0) // 0.8414709848078965\n```"
        ],
        "signature": "let sin: float => float"
      },
      {
        "id": "Core.Math.sinh",
        "kind": "value",
        "name": "sinh",
        "docstrings": [
          "`sinh(v)` returns then hyperbolic sine of argument `v`, which must be specified\nin radians.\nSee [`Math.sinh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh) on MDN.\n\n## Examples\n\n```rescript\nMath.sinh(-0.0) // -0.0\nMath.sinh(0.0) // 0.0\nMath.sinh(1.0) // 1.1752011936438014\n```"
        ],
        "signature": "let sinh: float => float"
      },
      {
        "id": "Core.Math.sqrt",
        "kind": "value",
        "name": "sqrt",
        "docstrings": [
          "`sqrt(v)` returns the square root of `v`. If `v` is negative returns `NaN`.\nSee [`Math.sqrt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt) on MDN.\n\n## Examples\n\n```rescript\nMath.sqrt(-1.0)->Float.isNaN // true\nMath.sqrt(-0.0) // -0.0\nMath.sqrt(0.0) // 0.0\nMath.sqrt(1.0) // 1.0\nMath.sqrt(9.0) // 3.0\n```"
        ],
        "signature": "let sqrt: float => float"
      },
      {
        "id": "Core.Math.tan",
        "kind": "value",
        "name": "tan",
        "docstrings": [
          "`tan(v)` returns the tangent of argument `v`, which must be specified in\nradians. Returns `NaN` if `v` is positive `Infinity` or negative `Infinity`.\nSee [`Math.tan`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tan) on MDN.\n\n## Examples\n\n```rescript\nMath.tan(-0.0) // -0.0\nMath.tan(0.0) // 0.0\nMath.tan(1.0) // 1.5574077246549023\n```"
        ],
        "signature": "let tan: float => float"
      },
      {
        "id": "Core.Math.tanh",
        "kind": "value",
        "name": "tanh",
        "docstrings": [
          "`tanh(v)` returns the hyperbolic tangent of argument `v`, which must be\nspecified in radians.\nSee [`Math.tanh`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh) on MDN.\n\n## Examples\n\n```rescript\nMath.tanh(-0.0) // -0.0\nMath.tanh(0.0) // 0.0\nMath.tanh(1.0) // 0.7615941559557649\n```"
        ],
        "signature": "let tanh: float => float"
      },
      {
        "id": "Core.Math.trunc",
        "kind": "value",
        "name": "trunc",
        "docstrings": [
          "`trunc(v)` truncates the argument `v`, i.e., removes fractional digits.\nSee [`Math.trunc`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc) on MDN.\n\n## Examples\n\n```rescript\nMath.trunc(0.123) // 0.0\nMath.trunc(1.999) // 1.0\nMath.trunc(13.37) // 13.0\nMath.trunc(42.84) // 42.0\n```"
        ],
        "signature": "let trunc: float => float"
      }
    ]
  },
  "core/bigint": {
    "id": "Core.BigInt",
    "name": "BigInt",
    "docstrings": [],
    "items": [
      {
        "id": "Core.BigInt.asIntN",
        "kind": "value",
        "name": "asIntN",
        "docstrings": [],
        "signature": "let asIntN: (~width: int, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.asUintN",
        "kind": "value",
        "name": "asUintN",
        "docstrings": [],
        "signature": "let asUintN: (~width: int, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [],
        "signature": "let fromString: string => bigint"
      },
      {
        "id": "Core.BigInt.fromStringExn",
        "kind": "value",
        "name": "fromStringExn",
        "docstrings": [
          "Parses the given `string` into a `bigint` using JavaScript semantics. Return the\nnumber as a `bigint` if successfully parsed. Uncaught syntax exception otherwise.\n\n## Examples\n\n```rescript\n/* returns 123n */\nBigInt.fromStringExn(\"123\")\n\n/* returns 0n */\nBigInt.fromStringExn(\"\")\n\n/* returns 17n */\nBigInt.fromStringExn(\"0x11\")\n\n/* returns 3n */\nBigInt.fromStringExn(\"0b11\")\n\n/* returns 9n */\nBigInt.fromStringExn(\"0o11\")\n\n/* catch exception */\ntry {\n  BigInt.fromStringExn(\"a\")\n} catch {\n| Exn.Error(_error) => 0n\n}\n```"
        ],
        "signature": "let fromStringExn: string => bigint"
      },
      {
        "id": "Core.BigInt.fromInt",
        "kind": "value",
        "name": "fromInt",
        "docstrings": [],
        "signature": "let fromInt: int => bigint"
      },
      {
        "id": "Core.BigInt.fromFloat",
        "kind": "value",
        "name": "fromFloat",
        "docstrings": [],
        "signature": "let fromFloat: float => bigint"
      },
      {
        "id": "Core.BigInt.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "Formats a `bigint` as a string. Return a `string` representing the given value.\nSee [`toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) on MDN.\n\n## Examples\n\n```rescript\n/* prints \"123\" */\nJs.BigInt.toString(123n)->Js.log\n```"
        ],
        "signature": "let toString: (bigint, ~radix: int=?) => string"
      },
      {
        "id": "Core.BigInt.toStringWithRadix",
        "kind": "value",
        "name": "toStringWithRadix",
        "docstrings": [],
        "signature": "let toStringWithRadix: (bigint, ~radix: int) => string",
        "deprecated": "Use `toString` with `~radix` instead"
      },
      {
        "id": "Core.BigInt.toLocaleString",
        "kind": "value",
        "name": "toLocaleString",
        "docstrings": [
          "Returns a string with a language-sensitive representation of this BigInt value.\n\n## Examples\n\n```rescript\n/* prints \"123\" */\nJs.BigInt.toString(123n)->Js.log\n```"
        ],
        "signature": "let toLocaleString: bigint => string"
      },
      {
        "id": "Core.BigInt.toFloat",
        "kind": "value",
        "name": "toFloat",
        "docstrings": [],
        "signature": "let toFloat: bigint => float"
      },
      {
        "id": "Core.BigInt.toInt",
        "kind": "value",
        "name": "toInt",
        "docstrings": [],
        "signature": "let toInt: bigint => int"
      },
      {
        "id": "Core.BigInt.+",
        "kind": "value",
        "name": "+",
        "docstrings": [],
        "signature": "let +: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.-",
        "kind": "value",
        "name": "-",
        "docstrings": [],
        "signature": "let -: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.*",
        "kind": "value",
        "name": "*",
        "docstrings": [],
        "signature": "let *: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt./",
        "kind": "value",
        "name": "/",
        "docstrings": [],
        "signature": "let /: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.~-",
        "kind": "value",
        "name": "~-",
        "docstrings": [],
        "signature": "let ~-: bigint => bigint"
      },
      {
        "id": "Core.BigInt.~+",
        "kind": "value",
        "name": "~+",
        "docstrings": [],
        "signature": "let ~+: bigint => bigint"
      },
      {
        "id": "Core.BigInt.**",
        "kind": "value",
        "name": "**",
        "docstrings": [],
        "signature": "let **: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.sub",
        "kind": "value",
        "name": "sub",
        "docstrings": [],
        "signature": "let sub: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.mul",
        "kind": "value",
        "name": "mul",
        "docstrings": [],
        "signature": "let mul: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.div",
        "kind": "value",
        "name": "div",
        "docstrings": [],
        "signature": "let div: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.mod",
        "kind": "value",
        "name": "mod",
        "docstrings": [],
        "signature": "let mod: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.land",
        "kind": "value",
        "name": "land",
        "docstrings": [],
        "signature": "let land: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.lor",
        "kind": "value",
        "name": "lor",
        "docstrings": [],
        "signature": "let lor: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.lxor",
        "kind": "value",
        "name": "lxor",
        "docstrings": [],
        "signature": "let lxor: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.lsl",
        "kind": "value",
        "name": "lsl",
        "docstrings": [],
        "signature": "let lsl: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.asr",
        "kind": "value",
        "name": "asr",
        "docstrings": [],
        "signature": "let asr: (bigint, bigint) => bigint"
      },
      {
        "id": "Core.BigInt.lnot",
        "kind": "value",
        "name": "lnot",
        "docstrings": [],
        "signature": "let lnot: bigint => bigint"
      }
    ]
  },
  "core/int": {
    "id": "Core.Int",
    "name": "Int",
    "docstrings": [
      "Functions for interacting with JavaScript Number.\nSee: [`Number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)."
    ],
    "items": [
      {
        "id": "Core.Int.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: (int, int) => bool"
      },
      {
        "id": "Core.Int.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (int, int) => Core__Ordering.t"
      },
      {
        "id": "Core.Int.toExponential",
        "kind": "value",
        "name": "toExponential",
        "docstrings": [
          "`toExponential(n, ~digits=?)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point. See [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\n\n## Examples\n\n```rescript\nInt.toExponential(1000) // \"1e+3\"\nInt.toExponential(-1000) // \"-1e+3\"\nInt.toExponential(77, ~digits=2) // \"7.70e+1\"\nInt.toExponential(5678, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10."
        ],
        "signature": "let toExponential: (int, ~digits: int=?) => string"
      },
      {
        "id": "Core.Int.toExponentialWithPrecision",
        "kind": "value",
        "name": "toExponentialWithPrecision",
        "docstrings": [
          "`toExponential(n, ~digits)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point. See [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\non MDN.\n\n## Examples\n\n```rescript\nInt.toExponentialWithPrecision(77, ~digits=2) // \"7.70e+1\"\nInt.toExponentialWithPrecision(5678, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10."
        ],
        "signature": "let toExponentialWithPrecision: (int, ~digits: int) => string",
        "deprecated": "Use `toExponential` instead"
      },
      {
        "id": "Core.Int.toFixed",
        "kind": "value",
        "name": "toFixed",
        "docstrings": [
          "`toFixed(n, ~digits=?)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n## Examples\n\n```rescript\nInt.toFixed(123456) // \"123456.00\"\nInt.toFixed(10) // \"10.00\"\nInt.toFixed(300, ~digits=4) // \"300.0000\"\nInt.toFixed(300, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100."
        ],
        "signature": "let toFixed: (int, ~digits: int=?) => string"
      },
      {
        "id": "Core.Int.toFixedWithPrecision",
        "kind": "value",
        "name": "toFixedWithPrecision",
        "docstrings": [
          "`toFixedWithPrecision(n, ~digits)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n## Examples\n\n```rescript\nInt.toFixedWithPrecision(300, ~digits=4) // \"300.0000\"\nInt.toFixedWithPrecision(300, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100."
        ],
        "signature": "let toFixedWithPrecision: (int, ~digits: int) => string",
        "deprecated": "Use `toFixed` instead"
      },
      {
        "id": "Core.Int.toPrecision",
        "kind": "value",
        "name": "toPrecision",
        "docstrings": [
          "`toPrecision(n, ~digits=?)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecision(100) // \"100\"\nInt.toPrecision(1) // \"1\"\nInt.toPrecision(100, ~digits=2) // \"1.0e+2\"\nInt.toPrecision(1, ~digits=2) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits."
        ],
        "signature": "let toPrecision: (int, ~digits: int=?) => string"
      },
      {
        "id": "Core.Int.toPrecisionWithPrecision",
        "kind": "value",
        "name": "toPrecisionWithPrecision",
        "docstrings": [
          "`toPrecisionWithPrecision(n, ~digits)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecisionWithPrecision(100, ~digits=2) // \"1.0e+2\"\nInt.toPrecisionWithPrecision(1, ~digits=2) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits."
        ],
        "signature": "let toPrecisionWithPrecision: (int, ~digits: int) => string",
        "deprecated": "Use `toPrecision` instead"
      },
      {
        "id": "Core.Int.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "`toString(n, ~radix=?)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toString(1000) // \"1000\"\nInt.toString(-1000) // \"-1000\"\nInt.toString(6, ~radix=2) // \"110\"\nInt.toString(373592855, ~radix=16) // \"16449317\"\nInt.toString(123456, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36."
        ],
        "signature": "let toString: (int, ~radix: int=?) => string"
      },
      {
        "id": "Core.Int.toStringWithRadix",
        "kind": "value",
        "name": "toStringWithRadix",
        "docstrings": [
          "`toStringWithRadix(n, ~radix)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toStringWithRadix(6, ~radix=2) // \"110\"\nInt.toStringWithRadix(373592855, ~radix=16) // \"16449317\"\nInt.toStringWithRadix(123456, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36."
        ],
        "signature": "let toStringWithRadix: (int, ~radix: int) => string",
        "deprecated": "Use `toString` instead"
      },
      {
        "id": "Core.Int.toLocaleString",
        "kind": "value",
        "name": "toLocaleString",
        "docstrings": [
          "`toLocaleString(n)` return a `string` with language-sensitive representing the\ngiven value. See [`Number.toLocaleString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString) on MDN.\n\n## Examples\n\n```rescript\n// If the application uses English as the default language\nInt.toLocaleString(1000) // \"1,000\"\n\n// If the application uses Portuguese Brazil as the default language\nInt.toLocaleString(1000) // \"1.000\"\n```"
        ],
        "signature": "let toLocaleString: int => string"
      },
      {
        "id": "Core.Int.toFloat",
        "kind": "value",
        "name": "toFloat",
        "docstrings": [
          "`toFloat(n)` return a `float` representing the given value.\n\n## Examples\n\n```rescript\nInt.toFloat(100) == 100.0\nInt.toFloat(2) == 2.0\n```"
        ],
        "signature": "let toFloat: int => float"
      },
      {
        "id": "Core.Int.fromFloat",
        "kind": "value",
        "name": "fromFloat",
        "docstrings": [
          "`fromFloat(n)` return an `int` representing the given value. The conversion is\ndone by truncating the decimal part.\n\n## Examples\n\n```rescript\nInt.fromFloat(2.0) == 2\nInt.fromFloat(1.999) == 1\nInt.fromFloat(1.5) == 1\nInt.fromFloat(0.9999) == 0\n```"
        ],
        "signature": "let fromFloat: float => int"
      },
      {
        "id": "Core.Int.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "`fromString(str, ~radix=?)` return an `option<int>` representing the given value\n`str`. `~radix` specifies the radix base to use for the formatted number.\n\n## Examples\n\n```rescript\nInt.fromString(\"0\") == Some(0)\nInt.fromString(\"NaN\") == None\nInt.fromString(\"6\", ~radix=2) == None\n```"
        ],
        "signature": "let fromString: (string, ~radix: int=?) => option<int>"
      },
      {
        "id": "Core.Int.mod",
        "kind": "value",
        "name": "mod",
        "docstrings": [
          "`mod(n1, n2)` calculates the modulo (remainder after division) of two integers.\n\n## Examples\n\n```rescript\nInt.mod(7, 4) == 3\n```"
        ],
        "signature": "let mod: (int, int) => int"
      },
      {
        "id": "Core.Int.rangeOptions",
        "kind": "type",
        "name": "rangeOptions",
        "docstrings": [
          "The options for `range`."
        ],
        "signature": "type rangeOptions = {step?: int, inclusive?: bool}"
      },
      {
        "id": "Core.Int.range",
        "kind": "value",
        "name": "range",
        "docstrings": [
          "`range(start, end, ~options=?)` returns an int array of the sequence of integers in the\nrange `[start, end)`. That is, including `start` but excluding `end`.\n\nIf `step` is not set and `start < end`, the sequence will be increasing in steps of 1.\n\nIf `step` is not set and `start > end`, the sequence will be decreasing in steps of -1.\n\nIf `step` is set, the sequence will increase or decrease by that amount for each\nstep. If `start < end` and `step` is negative, or vice versa, an empty array is\nreturned since the sequence would otherwise never reach or exceed the end value\nand hence be infinite. If `step` is `0` and `start !=` end, a `RangeError` is\nraised as the sequence would never reach or exceed the end value and hence be\ninfinite.\n\nIf `inclusive` is set to `true`, the sequence will include `end` if `step` is\nset such that the sequence includes it.\n\n## Examples\n\n```rescript\nInt.range(3, 6) == [3, 4, 5]\nInt.range(-3, -1) == [-3, -2]\nInt.range(3, 1) == [3, 2]\nInt.range(3, 7, ~options={step: 2}) == [3, 5]\nInt.range(3, 7, ~options={step: 2, inclusive: true}) == [3, 5, 7]\nInt.range(3, 6, ~options={step: -2}) // RangeError\n```\n\n## Exceptions\n\n- Raises `RangeError` if `step == 0 && start != end`."
        ],
        "signature": "let range: (int, int, ~options: rangeOptions=?) => array<int>"
      },
      {
        "id": "Core.Int.rangeWithOptions",
        "kind": "value",
        "name": "rangeWithOptions",
        "docstrings": [
          "`rangeWithOptions(start, end, options)` is like `range`, but with `step` and\n`inclusive` options configurable.\n\nIf `step` is set, the sequence will increase or decrease by that amount for each\nstep. If `start < end` and `step` is negative, or vice versa, an empty array is\nreturned since the sequence would otherwise never reach or exceed the end value\nand hence be infinite. If `step` is `0` and `start !=` end, a `RangeError` is\nraised as the sequence would never reach or exceed the end value and hence be\ninfinite.\n\nIf `inclusive` is set to `true`, the sequence will include `end` if `step` is\nset such that the sequence includes it.\n\n## Examples\n\n```rescript\nInt.rangeWithOptions(3, 7, {step: 2}) == [3, 5]\nInt.rangeWithOptions(3, 7, {step: 2, inclusive: true}) == [3, 5, 7]\nInt.rangeWithOptions(3, 6, {step: -2}) // RangeError\n```\n\n## Exceptions\n\n- Raises `RangeError` if `step == 0 && start != end`."
        ],
        "signature": "let rangeWithOptions: (int, int, rangeOptions) => array<int>",
        "deprecated": "Use `range` instead"
      },
      {
        "id": "Core.Int.clamp",
        "kind": "value",
        "name": "clamp",
        "docstrings": [
          "`clamp(~min=?, ~max=?, value)` returns `value`, optionally bounded by `min` and `max`.\n\nif `max` < `min` returns `min`.\n\n## Examples\n\n```rescript\nInt.clamp(42) == 42\nInt.clamp(42, ~min=50) == 50\nInt.clamp(42, ~max=40) == 40\nInt.clamp(42, ~min=50, ~max=40) == 50\n```"
        ],
        "signature": "let clamp: (~min: int=?, ~max: int=?, int) => int"
      }
    ]
  },
  "core/float": {
    "id": "Core.Float",
    "name": "Float",
    "docstrings": [
      "Functions for interacting with float."
    ],
    "items": [
      {
        "id": "Core.Float.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: (float, float) => bool"
      },
      {
        "id": "Core.Float.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (float, float) => Core__Ordering.t"
      },
      {
        "id": "Core.Float.isNaN",
        "kind": "value",
        "name": "isNaN",
        "docstrings": [
          "`isNaN(v)` tests if the given `v` is `NaN`.\nSee [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN) on MDN.\n\n## Examples\n\n```rescript\nFloat.isNaN(3.0) // false\nFloat.isNaN(Float.Constants.nan) // true\n```"
        ],
        "signature": "let isNaN: float => bool"
      },
      {
        "id": "Core.Float.isFinite",
        "kind": "value",
        "name": "isFinite",
        "docstrings": [
          "`isFinite(v)` tests if the given `v` is finite.\nSee [`isFinite`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite) on MDN.\n\n## Examples\n\n```rescript\nFloat.isFinite(1.0) // true\nFloat.isFinite(Float.Constants.nan) // false\nFloat.isFinite(Float.Constants.positiveInfinity) // false\n```"
        ],
        "signature": "let isFinite: float => bool"
      },
      {
        "id": "Core.Float.parseFloat",
        "kind": "value",
        "name": "parseFloat",
        "docstrings": [
          "`parseFloat(v)` parse the given `v` and returns a float. Leading whitespace in\n`v` is ignored. Returns `NaN` if `v` can't be parsed. Use [`fromString`] to\nensure it returns a valid float and not `NaN`.\nSee [`parseFloat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) on MDN.\n\n## Examples\n\n```rescript\nFloat.parseFloat(\"1.0\") // 1.0\nFloat.parseFloat(\"  3.14   \") // 3.14\nFloat.parseFloat(\"3.0\") // 3.0\nFloat.parseFloat(\"3.14some non-digit characters\") // 3.14\nFloat.parseFloat(\"error\")->Float.isNaN // true\n```"
        ],
        "signature": "let parseFloat: string => float"
      },
      {
        "id": "Core.Float.parseInt",
        "kind": "value",
        "name": "parseInt",
        "docstrings": [
          "`parseInt(v, ~radix=?)` parse the given `v` and returns a float. Leading\nwhitespace in this argument `v`is ignored. `radix` specifies the radix base to\nuse for the formatted number. The value must be in the range [2, 36] (inclusive).\nReturns `NaN` if `v` can't be parsed and `radix` is smaller than 2 or bigger\nthan 36.\nSee [`parseInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt) on MDN.\n\n## Examples\n\n```rescript\nFloat.parseInt(\"1.0\") // 1.0\nFloat.parseInt(\"  3.14   \") // 3.0\nFloat.parseInt(3) // 3.0\nFloat.parseInt(\"3.14some non-digit characters\") // 3.0\nFloat.parseInt(\"error\")->Float.isNaN // true\nFloat.parseInt(\"10.0\", ~radix=2) // 2.0\nFloat.parseInt(\"15 * 3\", ~radix=10) // 15.0\nFloat.parseInt(\"12\", ~radix=13) // 15.0\nFloat.parseInt(\"17\", ~radix=40)->Float.isNaN // true\n```"
        ],
        "signature": "let parseInt: ('a, ~radix: int=?) => float"
      },
      {
        "id": "Core.Float.parseIntWithRadix",
        "kind": "value",
        "name": "parseIntWithRadix",
        "docstrings": [
          "`parseIntWithRadix(v, ~radix)` parse the given `v` and returns a float. Leading\nwhitespace in this argument `v`is ignored. `radix` specifies the radix base to\nuse for the formatted number. The value must be in the range [2, 36] (inclusive).\nReturns `NaN` if `v` can't be parsed and `radix` is smaller than 2 or bigger\nthan 36.\nSee [`parseInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt) on MDN.\n\n## Examples\n\n```rescript\nFloat.parseIntWithRadix(\"10.0\", ~radix=2) // 2.0\nFloat.parseIntWithRadix(\"15 * 3\", ~radix=10) // 15.0\nFloat.parseIntWithRadix(\"12\", ~radix=13) // 15.0\nFloat.parseIntWithRadix(\"17\", ~radix=40)->Float.isNaN // true\n```"
        ],
        "signature": "let parseIntWithRadix: ('a, ~radix: int) => float",
        "deprecated": "Use `parseInt` instead"
      },
      {
        "id": "Core.Float.toExponential",
        "kind": "value",
        "name": "toExponential",
        "docstrings": [
          "`toExponential(v, ~digits=?)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point.\nSee [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) on MDN.\n\n## Examples\n\n```rescript\nFloat.toExponential(1000.0) // \"1e+3\"\nFloat.toExponential(-1000.0) // \"-1e+3\"\nFloat.toExponential(77.0, ~digits=2) // \"7.70e+1\"\nFloat.toExponential(5678.0, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10."
        ],
        "signature": "let toExponential: (float, ~digits: int=?) => string"
      },
      {
        "id": "Core.Float.toExponentialWithPrecision",
        "kind": "value",
        "name": "toExponentialWithPrecision",
        "docstrings": [
          "`toExponential(v, ~digits)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point.\nSee [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential) on MDN.\n\n## Examples\n\n```rescript\nFloat.toExponentialWithPrecision(77.0, ~digits=2) // \"7.70e+1\"\nFloat.toExponentialWithPrecision(5678.0, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10."
        ],
        "signature": "let toExponentialWithPrecision: (float, ~digits: int) => string",
        "deprecated": "Use `toExponential` instead"
      },
      {
        "id": "Core.Float.toFixed",
        "kind": "value",
        "name": "toFixed",
        "docstrings": [
          "`toFixed(v, ~digits=?)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point.\nSee [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) on MDN.\n\n## Examples\n\n```rescript\nFloat.toFixed(123456.0) // \"123456.00\"\nFloat.toFixed(10.0) // \"10.00\"\nFloat.toFixed(300.0, ~digits=4) // \"300.0000\"\nFloat.toFixed(300.0, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100."
        ],
        "signature": "let toFixed: (float, ~digits: int=?) => string"
      },
      {
        "id": "Core.Float.toFixedWithPrecision",
        "kind": "value",
        "name": "toFixedWithPrecision",
        "docstrings": [
          "`toFixedWithPrecision(v, ~digits)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point.\nSee [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) on MDN.\n\n## Examples\n\n```rescript\nFloat.toFixedWithPrecision(300.0, ~digits=4) // \"300.0000\"\nFloat.toFixedWithPrecision(300.0, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100."
        ],
        "signature": "let toFixedWithPrecision: (float, ~digits: int) => string",
        "deprecated": "Use `toFixed` instead"
      },
      {
        "id": "Core.Float.toPrecision",
        "kind": "value",
        "name": "toPrecision",
        "docstrings": [
          "`toPrecision(v, ~digits=?)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits.\nSee [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nFloat.toPrecision(100.0) // \"100\"\nFloat.toPrecision(1.0) // \"1\"\nFloat.toPrecision(100.0, ~digits=2) // \"1.0e+2\"\nFloat.toPrecision(1.0, ~digits=1) // \"1\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits."
        ],
        "signature": "let toPrecision: (float, ~digits: int=?) => string"
      },
      {
        "id": "Core.Float.toPrecisionWithPrecision",
        "kind": "value",
        "name": "toPrecisionWithPrecision",
        "docstrings": [
          "`toPrecisionWithPrecision(v, ~digits)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits.\nSee [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nFloat.toPrecisionWithPrecision(100.0, ~digits=2) // \"1.0e+2\"\nFloat.toPrecisionWithPrecision(1.0, ~digits=1) // \"1\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits."
        ],
        "signature": "let toPrecisionWithPrecision: (float, ~digits: int) => string",
        "deprecated": "Use `toPrecision` instead"
      },
      {
        "id": "Core.Float.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "`toString(v)` return a `string` representing the given value.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) on MDN.\n\n## Examples\n\n```rescript\nFloat.toString(1000.0) // \"1000\"\nFloat.toString(-1000.0) // \"-1000\"\n```"
        ],
        "signature": "let toString: (float, ~radix: int=?) => string"
      },
      {
        "id": "Core.Float.toStringWithRadix",
        "kind": "value",
        "name": "toStringWithRadix",
        "docstrings": [
          "`toStringWithRadix(v, ~radix)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) on MDN.\n\n## Examples\n\n```rescript\nFloat.toStringWithRadix(6.0, ~radix=2) // \"110\"\nFloat.toStringWithRadix(3735928559.0, ~radix=16) // \"deadbeef\"\nFloat.toStringWithRadix(123456.0, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36."
        ],
        "signature": "let toStringWithRadix: (float, ~radix: int) => string",
        "deprecated": "Use `toString` with `~radix` instead"
      },
      {
        "id": "Core.Float.toLocaleString",
        "kind": "value",
        "name": "toLocaleString",
        "docstrings": [
          "`toLocaleString(v)` return a `string` with language-sensitive representing the\ngiven value.\nSee [`Number.toLocaleString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString) on MDN.\n\n## Examples\n\n```rescript\n// If the application uses English as the default language\nFloat.toLocaleString(1000.0) // \"1,000\"\n\n// If the application uses Portuguese Brazil as the default language\nFloat.toLocaleString(1000.0) // \"1.000\"\n```"
        ],
        "signature": "let toLocaleString: float => string"
      },
      {
        "id": "Core.Float.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "`fromString(str)` return an `option<int>` representing the given value `str`.\n\n## Examples\n\n```rescript\nFloat.fromString(\"0\") == Some(0.0)\nFloat.fromString(\"NaN\") == None\nFloat.fromString(\"6\") == Some(6.0)\n```"
        ],
        "signature": "let fromString: string => option<float>"
      },
      {
        "id": "Core.Float.toInt",
        "kind": "value",
        "name": "toInt",
        "docstrings": [
          "`toInt(v)` returns an int to given float `v`.\n\n## Examples\n\n```rescript\nFloat.toInt(2.0) == 2\nFloat.toInt(1.0) == 1\nFloat.toInt(1.1) == 1\nFloat.toInt(1.6) == 1\n```"
        ],
        "signature": "let toInt: float => int"
      },
      {
        "id": "Core.Float.fromInt",
        "kind": "value",
        "name": "fromInt",
        "docstrings": [
          "`fromInt(v)` returns a float to given int `v`.\n\n## Examples\n\n```rescript\nFloat.fromInt(2) == 2.0\nFloat.fromInt(1) == 1.0\n```"
        ],
        "signature": "let fromInt: int => float"
      },
      {
        "id": "Core.Float.mod",
        "kind": "value",
        "name": "mod",
        "docstrings": [
          "`mod(n1, n2)` calculates the modulo (remainder after division) of two floats.\n\n## Examples\n\n```rescript\nFloat.mod(7.0, 4.0) == 3.0\n```"
        ],
        "signature": "let mod: (float, float) => float"
      },
      {
        "id": "Core.Float.clamp",
        "kind": "value",
        "name": "clamp",
        "docstrings": [
          "`clamp(~min=?, ~max=?, value)` returns `value`, optionally bounded by `min` and `max`.\n\nif `max` < `min` returns `min`.\n\n## Examples\n\n```rescript\nFloat.clamp(4.2) == 4.2\nFloat.clamp(4.2, ~min=4.3) == 4.3\nFloat.clamp(4.2, ~max=4.1) == 4.1\nFloat.clamp(4.2, ~min=4.3, ~max=4.1) == 4.3\n```"
        ],
        "signature": "let clamp: (~min: float=?, ~max: float=?, float) => float"
      }
    ]
  },
  "core/error": {
    "id": "Core.Error",
    "name": "Error",
    "docstrings": [
      "Functions for working with JavaScript exceptions.\n\nSee [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) on MDN."
    ],
    "items": [
      {
        "id": "Core.Error.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Represents a JavaScript exception."
        ],
        "signature": "type t = Js.Exn.t"
      },
      {
        "id": "Core.Error.fromException",
        "kind": "value",
        "name": "fromException",
        "docstrings": [],
        "signature": "let fromException: exn => option<t>"
      },
      {
        "id": "Core.Error.toException",
        "kind": "value",
        "name": "toException",
        "docstrings": [
          "Turns an `Error.t` into an `exn`.\n\n## Examples\n```rescript\nlet error = Error.make(\"Something went wrong.\")\n\nlet asExn = error->Error.toException // `asExn` is now type `exn`\n```"
        ],
        "signature": "let toException: t => exn"
      },
      {
        "id": "Core.Error.stack",
        "kind": "value",
        "name": "stack",
        "docstrings": [
          "`stack(error)` retrieves the `stack` property of the error, if it exists. The stack is a list of what functions were called, and what files they are defined in, prior to the error happening.\n\nSee [`Error.prototype.stack`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack) on MDN.\n\n## Example\n```rescript\nlet error = Error.make(\"error\")\nConsole.log(error->Error.stack) // Logs `stack` if it exists on `someError`\n```"
        ],
        "signature": "let stack: t => option<string>"
      },
      {
        "id": "Core.Error.message",
        "kind": "value",
        "name": "message",
        "docstrings": [
          "`message(error)` retrieves the `message` property of the error, if it exists.\n\nSee [`Error.prototype.message`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/message) on MDN.\n\n## Example\n```rescript\nlet error = Error.SyntaxError.make(\"Some message here\")\nConsole.log(error->Error.message) // Logs \"Some message here\" to the console\n```"
        ],
        "signature": "let message: t => option<string>"
      },
      {
        "id": "Core.Error.name",
        "kind": "value",
        "name": "name",
        "docstrings": [
          "`name(error)` retrieves the `name` property of the error, if it exists.\n\nSee [`Error.prototype.name`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/name) on MDN.\n\n## Example\n```rescript\nlet error = Error.SyntaxError.make(\"Some message here\")\nConsole.log(error->Error.name) // Logs \"SyntaxError\" to the console\n```"
        ],
        "signature": "let name: t => option<string>"
      },
      {
        "id": "Core.Error.fileName",
        "kind": "value",
        "name": "fileName",
        "docstrings": [
          "`fileName(error)` retrieves the `fileName` property of the error, if it exists.\n\nSee [`Error.prototype.fileName`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/fileName) on MDN."
        ],
        "signature": "let fileName: t => option<string>"
      },
      {
        "id": "Core.Error.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(message)` creates a new error, setting its `message` to the provided value.\n\nSee [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error) on MDN.\n\n## Example\n```rescript\nlet error = Error.make(\"Some message here\")\nConsole.log(error->Error.message) // Logs \"Some message here\" to the console\nConsole.log(error->Error.name) // Logs \"Error\" to the console, because this is a regular error\n```"
        ],
        "signature": "let make: string => t"
      },
      {
        "id": "Core.Error.raise",
        "kind": "value",
        "name": "raise",
        "docstrings": [
          "Raises (throws in JavaScript language) the provided `Error.t`, which will stop execution.\n\n## Examples\n```rescript\nlet error = Error.make(\"Everything is upside down.\")\n\nif 5 > 10 {\n  error->Error.raise\n} else {\n  Console.log(\"Phew, sanity still rules.\")\n}\n```"
        ],
        "signature": "let raise: t => 'a"
      },
      {
        "id": "Core.Error.panic",
        "kind": "value",
        "name": "panic",
        "docstrings": [
          "Raises a panic exception with the given message.\n\nA panic exception is a native JavaScript exception that is not intended to be caught and\nhandled. Compared to a ReScript exception this will give a better stack trace and\ndebugging experience.\n\n## Examples\n```rescript\nError.panic(\"Uh oh. This was unexpected!\")\n```"
        ],
        "signature": "let panic: string => 'a"
      }
    ]
  },
  "core/dict": {
    "id": "Core.Dict",
    "name": "Dict",
    "docstrings": [
      "A mutable dictionary with string keys.\n\nCompiles to a regular JavaScript object."
    ],
    "items": [
      {
        "id": "Core.Dict.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "Type representing a dictionary of value `'a`."
        ],
        "signature": "type t<'a> = Js.Dict.t<'a>"
      },
      {
        "id": "Core.Dict.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(dict, key)` Returns the `value` at the provided `key`.\n\nThis is _unsafe_, meaning it will return `undefined` value if `key` does not exist in `dict`.\n\nUse `Dict.getUnsafe` only when you are sure the key exists (i.e. when iterating `Dict.keys` result).\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"key1\", \"value1\"), (\"key2\", \"value2\")])\nlet value = dict->Dict.getUnsafe(\"key1\")\nConsole.log(value) // value1\n```"
        ],
        "signature": "let getUnsafe: (t<'a>, string) => 'a"
      },
      {
        "id": "Core.Dict.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the value at the provided key, if it exists. Returns an option.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"someKey\", \"someValue\")])\n\nswitch dict->Dict.get(\"someKey\") {\n| None => Console.log(\"Nope, didn't have the key.\")\n| Some(value) => Console.log(value)\n}\n```"
        ],
        "signature": "let get: (t<'a>, string) => option<'a>"
      },
      {
        "id": "Core.Dict.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(dictionary, key, value)` sets the value at the provided key to the provided value.\n\n## Examples\n```rescript\nlet dict = Dict.make()\n\ndict->Dict.set(\"someKey\", \"someValue\")\n```"
        ],
        "signature": "let set: (t<'a>, string, 'a) => unit"
      },
      {
        "id": "Core.Dict.delete",
        "kind": "value",
        "name": "delete",
        "docstrings": [
          "`delete(dictionary, key)` deletes the value at `key`, if it exists.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"someKey\", \"someValue\")])\n\ndict->Dict.delete(\"someKey\")\n```"
        ],
        "signature": "let delete: (t<'a>, string) => unit"
      },
      {
        "id": "Core.Dict.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make()` creates a new, empty dictionary.\n\n## Examples\n```rescript\nlet dict1: Dict.t<int> = Dict.make() // You can annotate the type of the values of your dict yourself if you want\n\nlet dict2 = Dict.make() // Or you can let ReScript infer it via usage.\ndict2->Dict.set(\"someKey\", 12)\n```"
        ],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Core.Dict.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray(entries)` creates a new dictionary from the provided array of key/value pairs.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"key1\", \"value1\"), (\"key2\", \"value2\")])\n```"
        ],
        "signature": "let fromArray: array<(string, 'a)> => t<'a>"
      },
      {
        "id": "Core.Dict.fromIterator",
        "kind": "value",
        "name": "fromIterator",
        "docstrings": [
          "`fromIterator(entries)` creates a new dictionary from the provided iterator of key/value pairs.\n\n## Examples\n```rescript\n// Pretend we have an iterator of the correct shape\n@val external someIterator: Iterator.t<(string, int)> = \"someIterator\"\n\nlet dict = Dict.fromIterator(someIterator) // Dict.t<int>\n```"
        ],
        "signature": "let fromIterator: Core__Iterator.t<(string, 'a)> => t<'a>"
      },
      {
        "id": "Core.Dict.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "`toArray(dictionary)` returns an array of all the key/value pairs of the dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.make()\ndict->Dict.set(\"someKey\", 1)\ndict->Dict.set(\"someKey2\", 2)\nlet asArray = dict->Dict.toArray\nConsole.log(asArray) // Logs `[[\"someKey\", 1], [\"someKey2\", 2]]` to the console\n```"
        ],
        "signature": "let toArray: t<'a> => array<(string, 'a)>"
      },
      {
        "id": "Core.Dict.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [
          "`keysToArray(dictionary)` returns an array of all the keys of the dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.make()\ndict->Dict.set(\"someKey\", 1)\ndict->Dict.set(\"someKey2\", 2)\nlet keys = dict->Dict.keysToArray\nConsole.log(keys) // Logs `[\"someKey\", \"someKey2\"]` to the console\n```"
        ],
        "signature": "let keysToArray: t<'a> => array<string>"
      },
      {
        "id": "Core.Dict.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [
          "`valuesToArray(dictionary)` returns an array of all the values of the dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.make()\ndict->Dict.set(\"someKey\", 1)\ndict->Dict.set(\"someKey2\", 2)\nlet values = dict->Dict.valuesToArray\nConsole.log(values) // Logs `[1, 2]` to the console\n```"
        ],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Core.Dict.assign",
        "kind": "value",
        "name": "assign",
        "docstrings": [
          "`assign(dictionary1, dictionary2)` [shallowly](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy) merges dictionary2 into dictionary1, and returns dictionary1.\n\nBeware this will *mutate* dictionary1. If you're looking for a way to copy a dictionary, check out `Dict.copy`.\n\n## Examples\n```rescript\nlet dict1 = Dict.make()\ndict1->Dict.set(\"firstKey\", 1)\nConsole.log(dict1->Dict.keysToArray) // Logs `[\"firstKey\"]`\n\nlet dict2 = Dict.make()\ndict2->Dict.set(\"someKey\", 2)\ndict2->Dict.set(\"someKey2\", 3)\n\nlet dict1 = dict1->Dict.assign(dict2)\n\nConsole.log(dict1->Dict.keysToArray) // Logs `[\"firstKey\", \"someKey\", \"someKey2\"]`\n\n```"
        ],
        "signature": "let assign: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Core.Dict.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(dictionary)` [shallowly copies](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy) the provided dictionary to a new dictionary.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"key1\", \"value1\"), (\"key2\", \"value2\")])\nlet dict2 = dict->Dict.copy\n\n// Both log `[\"key1\", \"key2\"]` here.\nConsole.log2(dict->Dict.keysToArray, dict2->Dict.keysToArray)\n```"
        ],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Core.Dict.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(dictionary, f)` iterates through all values of the dict.\n\n> Please note that this is *without the keys*, just the values. If you need the key as well, use `Dict.forEachWithKey`.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"key1\", \"value1\"), (\"key2\", \"value2\")])\n\ndict->Dict.forEach(value => {\n  Console.log(value)\n})\n```"
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.Dict.forEachWithKey",
        "kind": "value",
        "name": "forEachWithKey",
        "docstrings": [
          "`forEachWithKey(dictionary, f)` iterates through all values of the dict, including the key for each value.\n\n## Examples\n```rescript\nlet dict = Dict.fromArray([(\"key1\", \"value1\"), (\"key2\", \"value2\")])\n\ndict->Dict.forEachWithKey((value, key) => {\n  Console.log2(value, key)\n})\n```"
        ],
        "signature": "let forEachWithKey: (t<'a>, ('a, string) => unit) => unit"
      },
      {
        "id": "Core.Dict.mapValues",
        "kind": "value",
        "name": "mapValues",
        "docstrings": [
          "`mapValues(dictionary, f)` returns a new dictionary with the same keys, and `f` applied to each value in the original dictionary.\n\n## Examples\n\n```rescript\nlet dict = Dict.fromArray([(\"key1\", 1), (\"key2\", 2)])\n\ndict->Dict.mapValues(v => v + 10)->Dict.toArray // [(\"key1\", 11), (\"key2\", 12)]\ndict->Dict.mapValues(v => Int.toString(v))->Dict.toArray // [(\"key1\", \"1\"), (\"key2\", \"2\")]\n```"
        ],
        "signature": "let mapValues: (t<'a>, 'a => 'b) => t<'b>"
      }
    ]
  },
  "core/date": {
    "id": "Core.Date",
    "name": "Date",
    "docstrings": [
      "Functions for interacting with JavaScript Dates."
    ],
    "items": [
      {
        "id": "Core.Date.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "A type representing a JavaScript date."
        ],
        "signature": "type t = Js.Date.t"
      },
      {
        "id": "Core.Date.msSinceEpoch",
        "kind": "type",
        "name": "msSinceEpoch",
        "docstrings": [
          "Time, in milliseconds, since / until the UNIX epoch (January 1, 1970 00:00:00 UTC).\nPositive numbers represent dates after, negative numbers dates before epoch."
        ],
        "signature": "type msSinceEpoch = float"
      },
      {
        "id": "Core.Date.localeOptions",
        "kind": "type",
        "name": "localeOptions",
        "docstrings": [
          "A type representing date time format options.\n\nNote: There are some properties missing:\n- fractionalSecondDigits\n- dayPeriod\n- calendar\n- numberingSystem\n- localeMatcher\n- timeZone\n- hour12\n- hourCycle\n- formatMatcher\n\nSee full spec at https://tc39.es/ecma402/#datetimeformat-objects"
        ],
        "signature": "type localeOptions = {\n  dateStyle?: [#full | #long | #medium | #short],\n  timeStyle?: [#full | #long | #medium | #short],\n  weekday?: [#long | #narrow | #short],\n  era?: [#long | #narrow | #short],\n  year?: [#\"2-digit\" | #numeric],\n  month?: [\n    | #\"2-digit\"\n    | #long\n    | #narrow\n    | #numeric\n    | #short\n  ],\n  day?: [#\"2-digit\" | #numeric],\n  hour?: [#\"2-digit\" | #numeric],\n  minute?: [#\"2-digit\" | #numeric],\n  second?: [#\"2-digit\" | #numeric],\n  timeZoneName?: [#long | #short],\n}"
      },
      {
        "id": "Core.Date.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make()`\n\nCreates a date object with the current date time as value.\n\n## Examples\n```rescript\nDate.make()\n```"
        ],
        "signature": "let make: unit => t"
      },
      {
        "id": "Core.Date.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "`fromString(dateTimeString)`\n\nCreates a date object from given date time string.\nThe string has to be in the ISO 8601 format YYYY-MM-DDTHH:mm:ss.sssZ (https://tc39.es/ecma262/#sec-date-time-string-format).\n\nInvalid date time strings will create invalid dates.\nYou can use the result like any valid date, but many functions like `toString` will return \"Invalid Date\" or functions like `Date.getTime` will return NaN.\n\n## Examples\n```rescript\nDate.fromString(\"2023\") // 2023-01-01T00:00:00.000Z\n\nDate.fromString(\"2023-02-20\") // 2023-02-20T00:00:00.000Z\n\nDate.fromString(\"2023-02-20T16:40:00.00Z\") // 2023-02-20T16:40:00.000Z\n\nDate.fromString(\"\") // Invalid Date\n\nDate.fromString(\"\")->Date.getTime // NaN\n```"
        ],
        "signature": "let fromString: string => t"
      },
      {
        "id": "Core.Date.fromTime",
        "kind": "value",
        "name": "fromTime",
        "docstrings": [
          "`fromTime(msSinceEpoch)`\n\nCreates a date object from the given time in milliseconds since / until UNIX epoch (January 1, 1970 00:00:00 UTC).\nPositive numbers create dates after epoch, negative numbers create dates before epoch.\n\n## Examples\n```rescript\nDate.fromTime(0.0)\n// 1970-01-01T00:00:00.000Z\n\nDate.fromTime(-86_400_000.0)\n// 1969-12-31T00:00:00.000Z\n\nDate.fromTime(86_400_000.0)\n// 1970-01-02T00:00:00.000Z\n```"
        ],
        "signature": "let fromTime: msSinceEpoch => t"
      },
      {
        "id": "Core.Date.makeWithYM",
        "kind": "value",
        "name": "makeWithYM",
        "docstrings": [
          "Creates a date object with the given year and month.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYM(~year=2023, ~month=0)\n// 2023-01-01T00:00:00.000Z\n\nDate.makeWithYM(~year=2023, ~month=11)\n// 2023-12-01T00:00:00.000Z\n\nDate.makeWithYM(~year=2023, ~month=12)\n// 2024-01-01T00:00:00.000Z\n\nDate.makeWithYM(~year=2023, ~month=-1)\n// 2022-12-01T00:00:00.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"
        ],
        "signature": "let makeWithYM: (~year: int, ~month: int) => t"
      },
      {
        "id": "Core.Date.makeWithYMD",
        "kind": "value",
        "name": "makeWithYMD",
        "docstrings": [
          "Creates a date object with the given year, month and date (day of month).\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMD(~year=2023, ~month=1, ~date=20)\n// 2023-02-20T00:00:00.000Z\n\nDate.makeWithYMD(~year=2023, ~month=1, ~date=-1)\n// 2022-11-29T00:00:00.000Z\n\nDate.makeWithYMD(~year=2023, ~month=1, ~date=29)\n// 2023-03-01T00:00:00.000Z\n```"
        ],
        "signature": "let makeWithYMD: (~year: int, ~month: int, ~date: int) => t"
      },
      {
        "id": "Core.Date.makeWithYMDH",
        "kind": "value",
        "name": "makeWithYMDH",
        "docstrings": [
          "Creates a date object with the given year, month, date (day of month) and hours.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=16)\n// 2023-02-20T16:00:00.000Z\n\nDate.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=24)\n// 2023-02-21T00:00:00.000Z\n\nDate.makeWithYMDH(~year=2023, ~month=1, ~date=20, ~hours=-1)\n// 2023-02-19T23:00:00.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"
        ],
        "signature": "let makeWithYMDH: (~year: int, ~month: int, ~date: int, ~hours: int) => t"
      },
      {
        "id": "Core.Date.makeWithYMDHM",
        "kind": "value",
        "name": "makeWithYMDHM",
        "docstrings": [
          "Creates a date object with the given year, month, date (day of month), hours and minutes.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40)\n// 2023-02-20T16:40:00.000Z\n\nDate.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=60)\n// 2023-02-20T17:00:00.000Z\n\nDate.makeWithYMDHM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=-1)\n// 2023-02-20T15:59:00.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"
        ],
        "signature": "let makeWithYMDHM: (\n  ~year: int,\n  ~month: int,\n  ~date: int,\n  ~hours: int,\n  ~minutes: int,\n) => t"
      },
      {
        "id": "Core.Date.makeWithYMDHMS",
        "kind": "value",
        "name": "makeWithYMDHMS",
        "docstrings": [
          "Creates a date object with the given year, month, date (day of month), hours, minutes and seconds.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0)\n// 2023-02-20T16:40:00.000Z\n\nDate.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=60)\n// 2023-02-20T16:41:00.000Z\n\nDate.makeWithYMDHMS(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=-1)\n// 2023-02-20T16:39:59.000Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"
        ],
        "signature": "let makeWithYMDHMS: (\n  ~year: int,\n  ~month: int,\n  ~date: int,\n  ~hours: int,\n  ~minutes: int,\n  ~seconds: int,\n) => t"
      },
      {
        "id": "Core.Date.makeWithYMDHMSM",
        "kind": "value",
        "name": "makeWithYMDHMSM",
        "docstrings": [
          "Creates a date object with the given year, month, date (day of month), hours, minutes, seconds and milliseconds.\nBe aware of using a value for year < 100, because it behaves inconsistent (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years).\nMonths are 0-indexed (0 = January, 11 = December).\nValues, which are out of range, will be carried over to the next bigger unit (s. example).\n\n## Examples\n```rescript\nDate.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=0)\n// 2023-02-20T16:40:00.000Z\n\nDate.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=1000)\n// 2023-02-20T16:40:01.000Z\n\nDate.makeWithYMDHMSM(~year=2023, ~month=1, ~date=20, ~hours=16, ~minutes=40, ~seconds=0, ~milliseconds=-1)\n// 2023-02-20T16:39:59.999Z\n\n// Note: The output depends on your local time zone.\n// In nodejs you can change it by using the TZ env (`export TZ='Europe/London' && node index.bs.js`)\n\n```"
        ],
        "signature": "let makeWithYMDHMSM: (\n  ~year: int,\n  ~month: int,\n  ~date: int,\n  ~hours: int,\n  ~minutes: int,\n  ~seconds: int,\n  ~milliseconds: int,\n) => t"
      },
      {
        "id": "Core.Date.now",
        "kind": "value",
        "name": "now",
        "docstrings": [
          "`now()`\n\nReturns the time, in milliseconds, between UNIX epoch (January 1, 1970 00:00:00 UTC) and the current date time."
        ],
        "signature": "let now: unit => msSinceEpoch"
      },
      {
        "id": "Core.Date.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: (t, t) => bool"
      },
      {
        "id": "Core.Date.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (t, t) => Core__Ordering.t"
      },
      {
        "id": "Core.Date.getTime",
        "kind": "value",
        "name": "getTime",
        "docstrings": [
          "`getTime(date)`\n\nReturns the time, in milliseconds, between UNIX epoch (January 1, 1970 00:00:00 UTC) and the current date time.\nInvalid dates will return NaN.\nDates before epoch will return negative numbers.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20\")->Date.getTime\n// 1676851200000\n```"
        ],
        "signature": "let getTime: t => msSinceEpoch"
      },
      {
        "id": "Core.Date.getTimezoneOffset",
        "kind": "value",
        "name": "getTimezoneOffset",
        "docstrings": [
          "`getTimezoneOffset(date)`\n\nReturns the time in minutes between the UTC time and the locale time.\nThe timezone of the given date doesn't matter.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01\")->Date.getTimezoneOffset\n// -60 with local time zone = Europe/Berlin\n\nDate.fromString(\"2023-06-01\")->Date.getTimezoneOffset\n// -120 with local time zone = Europe/Berlin\n```"
        ],
        "signature": "let getTimezoneOffset: t => int"
      },
      {
        "id": "Core.Date.getFullYear",
        "kind": "value",
        "name": "getFullYear",
        "docstrings": [
          "`getFullYear(date)`\n\nReturns the year of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20\")->Date.getFullYear\n// 2023\n```"
        ],
        "signature": "let getFullYear: t => int"
      },
      {
        "id": "Core.Date.getMonth",
        "kind": "value",
        "name": "getMonth",
        "docstrings": [
          "`getMonth(date)`\n\nReturns the month (0-indexed) of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01\")->Date.getMonth\n// 0\n```"
        ],
        "signature": "let getMonth: t => int"
      },
      {
        "id": "Core.Date.getDate",
        "kind": "value",
        "name": "getDate",
        "docstrings": [
          "`getDate(date)`\n\nReturns the date (day of month) of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getDate\n// 20\n```"
        ],
        "signature": "let getDate: t => int"
      },
      {
        "id": "Core.Date.getHours",
        "kind": "value",
        "name": "getHours",
        "docstrings": [
          "`getHours(date)`\n\nReturns the hours of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getHours\n// 16\n```"
        ],
        "signature": "let getHours: t => int"
      },
      {
        "id": "Core.Date.getMinutes",
        "kind": "value",
        "name": "getMinutes",
        "docstrings": [
          "`getMinutes(date)`\n\nReturns the minutes of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getMinutes\n// 40\n```"
        ],
        "signature": "let getMinutes: t => int"
      },
      {
        "id": "Core.Date.getSeconds",
        "kind": "value",
        "name": "getSeconds",
        "docstrings": [
          "`getSeconds(date)`\n\nReturns the seconds of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getSeconds\n// 0\n```"
        ],
        "signature": "let getSeconds: t => int"
      },
      {
        "id": "Core.Date.getMilliseconds",
        "kind": "value",
        "name": "getMilliseconds",
        "docstrings": [
          "`getMilliseconds(date)`\n\nReturns the milliseconds of a given date (according to local time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getMilliseconds\n// 0\n```"
        ],
        "signature": "let getMilliseconds: t => int"
      },
      {
        "id": "Core.Date.getDay",
        "kind": "value",
        "name": "getDay",
        "docstrings": [
          "`getDay(date)`\n\nReturns the day of week of a given date (according to local time).\n0 = Sunday, 1 = Monday, ... 6 = Saturday\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.getDay\n// 1\n```"
        ],
        "signature": "let getDay: t => int"
      },
      {
        "id": "Core.Date.setFullYear",
        "kind": "value",
        "name": "setFullYear",
        "docstrings": [
          "`setFullYear(date, year)`\n\nSets the year of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setFullYear(2024)\n```"
        ],
        "signature": "let setFullYear: (t, int) => unit"
      },
      {
        "id": "Core.Date.setFullYearM",
        "kind": "value",
        "name": "setFullYearM",
        "docstrings": [
          "`setFullYearM(date, ~year, ~month)`\n\nSets the year and month of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setFullYearM(~year=2024, ~month=0)\n```"
        ],
        "signature": "let setFullYearM: (t, ~year: int, ~month: int) => unit"
      },
      {
        "id": "Core.Date.setFullYearMD",
        "kind": "value",
        "name": "setFullYearMD",
        "docstrings": [
          "`setFullYearMD(date, ~year, ~month, ~date)`\n\nSets the year, month and date (day of month) of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setFullYearMD(~year=2024, ~month=0, ~date=1)\n```"
        ],
        "signature": "let setFullYearMD: (t, ~year: int, ~month: int, ~date: int) => unit"
      },
      {
        "id": "Core.Date.setMonth",
        "kind": "value",
        "name": "setMonth",
        "docstrings": [
          "`setMonth(date, month)`\n\nSets the month of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMonth(0)\n```"
        ],
        "signature": "let setMonth: (t, int) => unit"
      },
      {
        "id": "Core.Date.setDate",
        "kind": "value",
        "name": "setDate",
        "docstrings": [
          "`setDate(date, day)`\n\nSets the date (day of month) of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setDate(1)\n```"
        ],
        "signature": "let setDate: (t, int) => unit"
      },
      {
        "id": "Core.Date.setHours",
        "kind": "value",
        "name": "setHours",
        "docstrings": [
          "`setHours(date, hours)`\n\nSets the hours of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHours(0)\n```"
        ],
        "signature": "let setHours: (t, int) => unit"
      },
      {
        "id": "Core.Date.setHoursM",
        "kind": "value",
        "name": "setHoursM",
        "docstrings": [
          "`setHoursM(date, ~hours, ~minutes)`\n\nSets the hours and minutes of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHoursM(~hours=0, ~minutes=0)\n```"
        ],
        "signature": "let setHoursM: (t, ~hours: int, ~minutes: int) => unit"
      },
      {
        "id": "Core.Date.setHoursMS",
        "kind": "value",
        "name": "setHoursMS",
        "docstrings": [
          "`setHoursMS(date, ~hours, ~minutes, ~seconds)`\n\nSets the hours, minutes and seconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHoursMS(~hours=0, ~minutes=0, ~seconds=0)\n```"
        ],
        "signature": "let setHoursMS: (t, ~hours: int, ~minutes: int, ~seconds: int) => unit"
      },
      {
        "id": "Core.Date.setHoursMSMs",
        "kind": "value",
        "name": "setHoursMSMs",
        "docstrings": [
          "`setHoursMSMs(date, ~hours, ~minutes, ~seconds, ~milliseconds)`\n\nSets the hours, minutes, seconds and milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setHoursMSMs(~hours=0, ~minutes=0, ~seconds=0, ~milliseconds=0)\n```"
        ],
        "signature": "let setHoursMSMs: (\n  t,\n  ~hours: int,\n  ~minutes: int,\n  ~seconds: int,\n  ~milliseconds: int,\n) => unit"
      },
      {
        "id": "Core.Date.setMinutes",
        "kind": "value",
        "name": "setMinutes",
        "docstrings": [
          "`setMinutes(date, minutes)`\n\nSets the minutes of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMinutes(0)\n```"
        ],
        "signature": "let setMinutes: (t, int) => unit"
      },
      {
        "id": "Core.Date.setMinutesS",
        "kind": "value",
        "name": "setMinutesS",
        "docstrings": [
          "`setMinutesS(date, ~minutes, ~seconds)`\n\nSets the minutes and seconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMinutesS(~minutes=0, ~seconds=0)\n```"
        ],
        "signature": "let setMinutesS: (t, ~minutes: int, ~seconds: int) => unit"
      },
      {
        "id": "Core.Date.setMinutesSMs",
        "kind": "value",
        "name": "setMinutesSMs",
        "docstrings": [
          "`setMinutesSMs(date, ~minutes, ~seconds, ~milliseconds)`\n\nSets the minutes, seconds and milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMinutesSMs(~minutes=0, ~seconds=0, ~milliseconds=0)\n```"
        ],
        "signature": "let setMinutesSMs: (\n  t,\n  ~minutes: int,\n  ~seconds: int,\n  ~milliseconds: int,\n) => unit"
      },
      {
        "id": "Core.Date.setSeconds",
        "kind": "value",
        "name": "setSeconds",
        "docstrings": [
          "`setSeconds(date, seconds)`\n\nSets the seconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setSeconds(0)\n```"
        ],
        "signature": "let setSeconds: (t, int) => unit"
      },
      {
        "id": "Core.Date.setSecondsMs",
        "kind": "value",
        "name": "setSecondsMs",
        "docstrings": [
          "`setSecondsMs(date, ~seconds, ~milliseconds)`\n\nSets the seconds and milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setSecondsMs(~seconds=0, ~milliseconds=0)\n```"
        ],
        "signature": "let setSecondsMs: (t, ~seconds: int, ~milliseconds: int) => unit"
      },
      {
        "id": "Core.Date.setMilliseconds",
        "kind": "value",
        "name": "setMilliseconds",
        "docstrings": [
          "`setMilliseconds(date, milliseconds)`\n\nSets the milliseconds of a date (according to local time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setMilliseconds(0)\n```"
        ],
        "signature": "let setMilliseconds: (t, int) => unit"
      },
      {
        "id": "Core.Date.getUTCFullYear",
        "kind": "value",
        "name": "getUTCFullYear",
        "docstrings": [
          "`getUTCFullYear(date)`\n\nReturns the year of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCFullYear // 2022\n```"
        ],
        "signature": "let getUTCFullYear: t => int"
      },
      {
        "id": "Core.Date.getUTCMonth",
        "kind": "value",
        "name": "getUTCMonth",
        "docstrings": [
          "`getUTCMonth(date)`\n\nReturns the month of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCMonth // 11\n```"
        ],
        "signature": "let getUTCMonth: t => int"
      },
      {
        "id": "Core.Date.getUTCDate",
        "kind": "value",
        "name": "getUTCDate",
        "docstrings": [
          "`getUTCDate(date)`\n\nReturns the date (day of month) of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCDate // 31\n```"
        ],
        "signature": "let getUTCDate: t => int"
      },
      {
        "id": "Core.Date.getUTCHours",
        "kind": "value",
        "name": "getUTCHours",
        "docstrings": [
          "`getUTCHours(date)`\n\nReturns the hours of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCHours // 23\n```"
        ],
        "signature": "let getUTCHours: t => int"
      },
      {
        "id": "Core.Date.getUTCMinutes",
        "kind": "value",
        "name": "getUTCMinutes",
        "docstrings": [
          "`getUTCMinutes(date)`\n\nReturns the minutes of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCMinutes // 0\n```"
        ],
        "signature": "let getUTCMinutes: t => int"
      },
      {
        "id": "Core.Date.getUTCSeconds",
        "kind": "value",
        "name": "getUTCSeconds",
        "docstrings": [
          "`getUTCSeconds(date)`\n\nReturns the seconds of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCSeconds // 0\n```"
        ],
        "signature": "let getUTCSeconds: t => int"
      },
      {
        "id": "Core.Date.getUTCMilliseconds",
        "kind": "value",
        "name": "getUTCMilliseconds",
        "docstrings": [
          "`getUTCMilliseconds(date)`\n\nReturns the milliseconds of a given date (according to UTC time).\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCMilliseconds // 0\n```"
        ],
        "signature": "let getUTCMilliseconds: t => int"
      },
      {
        "id": "Core.Date.getUTCDay",
        "kind": "value",
        "name": "getUTCDay",
        "docstrings": [
          "`getUTCDay(date)`\n\nReturns the day (day of week) of a given date (according to UTC time).\n0 = Sunday, 1 = Monday, ... 6 = Saturday\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.getUTCDay // 6\n```"
        ],
        "signature": "let getUTCDay: t => int"
      },
      {
        "id": "Core.Date.setUTCFullYear",
        "kind": "value",
        "name": "setUTCFullYear",
        "docstrings": [
          "`setUTCFullYear(date, year)`\n\nSets the year of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCFullYear(2024)\n```"
        ],
        "signature": "let setUTCFullYear: (t, int) => unit"
      },
      {
        "id": "Core.Date.setUTCFullYearM",
        "kind": "value",
        "name": "setUTCFullYearM",
        "docstrings": [
          "`setUTCFullYearM(date, ~year, ~month)`\n\nSets the year and month of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCFullYearM(~year=2024, ~month=0)\n```"
        ],
        "signature": "let setUTCFullYearM: (t, ~year: int, ~month: int) => unit"
      },
      {
        "id": "Core.Date.setUTCFullYearMD",
        "kind": "value",
        "name": "setUTCFullYearMD",
        "docstrings": [
          "`setUTCFullYearMD(date, ~year, ~month, ~date)`\n\nSets the year, month and date (day of month) of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCFullYearMD(~year=2024, ~month=0, ~date=1)\n```"
        ],
        "signature": "let setUTCFullYearMD: (t, ~year: int, ~month: int, ~date: int) => unit"
      },
      {
        "id": "Core.Date.setUTCMonth",
        "kind": "value",
        "name": "setUTCMonth",
        "docstrings": [
          "`setUTCMonth(date, month)`\n\nSets the month of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMonth(0)\n```"
        ],
        "signature": "let setUTCMonth: (t, int) => unit"
      },
      {
        "id": "Core.Date.setUTCDate",
        "kind": "value",
        "name": "setUTCDate",
        "docstrings": [
          "`setDate(date, day)`\n\nSets the date (day of month) of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCDate(1)\n```"
        ],
        "signature": "let setUTCDate: (t, int) => unit"
      },
      {
        "id": "Core.Date.setUTCHours",
        "kind": "value",
        "name": "setUTCHours",
        "docstrings": [
          "`setUTCHours(date, hours)`\n\nSets the hours of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHours(0)\n```"
        ],
        "signature": "let setUTCHours: (t, int) => unit"
      },
      {
        "id": "Core.Date.setUTCHoursM",
        "kind": "value",
        "name": "setUTCHoursM",
        "docstrings": [
          "`setHoursM(date, ~hours, ~minutes)`\n\nSets the hours and minutes of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHoursM(~hours=0, ~minutes=0)\n```"
        ],
        "signature": "let setUTCHoursM: (t, ~hours: int, ~minutes: int) => unit"
      },
      {
        "id": "Core.Date.setUTCHoursMS",
        "kind": "value",
        "name": "setUTCHoursMS",
        "docstrings": [
          "`setUTCHoursMS(date, ~hours, ~minutes, ~seconds)`\n\nSets the hours, minutes and seconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHoursMS(~hours=0, ~minutes=0, ~seconds=0)\n```"
        ],
        "signature": "let setUTCHoursMS: (t, ~hours: int, ~minutes: int, ~seconds: int) => unit"
      },
      {
        "id": "Core.Date.setUTCHoursMSMs",
        "kind": "value",
        "name": "setUTCHoursMSMs",
        "docstrings": [
          "`setUTCHoursMSMs(date, ~hours, ~minutes, ~seconds, ~milliseconds)`\n\nSets the hours, minutes, seconds and milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCHoursMSMs(~hours=0, ~minutes=0, ~seconds=0, ~milliseconds=0)\n```"
        ],
        "signature": "let setUTCHoursMSMs: (\n  t,\n  ~hours: int,\n  ~minutes: int,\n  ~seconds: int,\n  ~milliseconds: int,\n) => unit"
      },
      {
        "id": "Core.Date.setUTCMinutes",
        "kind": "value",
        "name": "setUTCMinutes",
        "docstrings": [
          "`setUTCMinutes(date, minutes)`\n\nSets the minutes of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMinutes(0)\n```"
        ],
        "signature": "let setUTCMinutes: (t, int) => unit"
      },
      {
        "id": "Core.Date.setUTCMinutesS",
        "kind": "value",
        "name": "setUTCMinutesS",
        "docstrings": [
          "`setUTCMinutesS(date, ~minutes, ~seconds)`\n\nSets the minutes and seconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMinutesS(~minutes=0, ~seconds=0)\n```"
        ],
        "signature": "let setUTCMinutesS: (t, ~minutes: int, ~seconds: int) => unit"
      },
      {
        "id": "Core.Date.setUTCMinutesSMs",
        "kind": "value",
        "name": "setUTCMinutesSMs",
        "docstrings": [
          "`setUTCMinutesSMs(date, ~minutes, ~seconds, ~milliseconds)`\n\nSets the minutes, seconds and milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMinutesSMs(~minutes=0, ~seconds=0, ~milliseconds=0)\n```"
        ],
        "signature": "let setUTCMinutesSMs: (\n  t,\n  ~minutes: int,\n  ~seconds: int,\n  ~milliseconds: int,\n) => unit"
      },
      {
        "id": "Core.Date.setUTCSeconds",
        "kind": "value",
        "name": "setUTCSeconds",
        "docstrings": [
          "`setUTCSeconds(date, seconds)`\n\nSets the seconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCSeconds(0)\n```"
        ],
        "signature": "let setUTCSeconds: (t, int) => unit"
      },
      {
        "id": "Core.Date.setUTCSecondsMs",
        "kind": "value",
        "name": "setUTCSecondsMs",
        "docstrings": [
          "`setUTCSecondsMs(date, ~seconds, ~milliseconds)`\n\nSets the seconds and milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCSecondsMs(~seconds=0, ~milliseconds=0)\n```"
        ],
        "signature": "let setUTCSecondsMs: (t, ~seconds: int, ~milliseconds: int) => unit"
      },
      {
        "id": "Core.Date.setUTCMilliseconds",
        "kind": "value",
        "name": "setUTCMilliseconds",
        "docstrings": [
          "`setUTCMilliseconds(date, milliseconds)`\n\nSets the milliseconds of a date (according to UTC time).\nBeware this will *mutate* the date.\n\n## Examples\n```rescript\nDate.fromString(\"2023-02-20T16:40:00.00\")->Date.setUTCMilliseconds(0)\n```"
        ],
        "signature": "let setUTCMilliseconds: (t, int) => unit"
      },
      {
        "id": "Core.Date.toDateString",
        "kind": "value",
        "name": "toDateString",
        "docstrings": [
          "`toDateString(date)`\n\nConverts a JavaScript date to a standard date string. The date will be mapped to the current time zone.\nIf you want to convert it to a localized string, use `Date.toLocaleDateString` instead.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.toDateString->Console.log\n// Sun Jan 01 2023\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toDateString->Console.log\n// Sat Dec 31 2022\n```"
        ],
        "signature": "let toDateString: t => string"
      },
      {
        "id": "Core.Date.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "`toString(date)`\n\nConverts a JavaScript date to a standard date time string. The date will be mapped to the current time zone.\nIf you want to convert it to a localized string, use `Date.toLocaleString` instead.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.toString->Console.log\n// Sun Jan 01 2023 00:00:00 GMT+0100 (Central European Standard Time)\n\nDate.fromString(\"2023-06-01T00:00:00.00+01:00\")->Date.toString->Console.log\n// Thu Jun 01 2023 01:00:00 GMT+0200 (Central European Summer Time)\n```"
        ],
        "signature": "let toString: t => string"
      },
      {
        "id": "Core.Date.toTimeString",
        "kind": "value",
        "name": "toTimeString",
        "docstrings": [
          "`toTimeString(date)`\n\nConverts a JavaScript date to a standard time string. The date will be mapped to the current time zone.\nIf you want to convert it to a localized string, use `Date.toLocaleStimeString` instead.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+01:00\")->Date.toTimeString->Console.log\n// 00:00:00 GMT+0100 (Central European Standard Time)\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toTimeString->Console.log\n// 17:00:00 GMT+0100 (Central European Standard Time)\n```"
        ],
        "signature": "let toTimeString: t => string"
      },
      {
        "id": "Core.Date.toLocaleDateString",
        "kind": "value",
        "name": "toLocaleDateString",
        "docstrings": [
          "`toLocaleDateString(date)`\n\nConverts a JavaScript date to a localized date string. It will use the current locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleDateString->Console.log\n// 2/19/2023\n```"
        ],
        "signature": "let toLocaleDateString: t => string"
      },
      {
        "id": "Core.Date.toLocaleDateStringWithLocale",
        "kind": "value",
        "name": "toLocaleDateStringWithLocale",
        "docstrings": [
          "`toLocaleDateStringWithLocale(date, locale)`\n\nConverts a JavaScript date to a localized date string. It will use the specified locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleDateStringWithLocale(\"en-US\")->Console.log\n// 2/19/2023\n```"
        ],
        "signature": "let toLocaleDateStringWithLocale: (t, string) => string"
      },
      {
        "id": "Core.Date.toLocaleDateStringWithLocaleAndOptions",
        "kind": "value",
        "name": "toLocaleDateStringWithLocaleAndOptions",
        "docstrings": [
          "`toLocaleDateStringWithLocaleAndOptions(date, locale, options)`\n\nConverts a JavaScript date to a localized date string. It will use the specified locale and formatting options.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleDateStringWithLocaleAndOptions(\"en-US\", { dateStyle: #long })->Console.log\n// February 19, 2023\n\nDate.make()->Date.toLocaleDateStringWithLocaleAndOptions(\"de\", { hour: #\"2-digit\", minute: #\"2-digit\" })->Console.log\n// 19.2.2023, 15:40\n\nDate.make()->Date.toLocaleDateStringWithLocaleAndOptions(\"de\", { year: #numeric })->Console.log\n// 2023\n```"
        ],
        "signature": "let toLocaleDateStringWithLocaleAndOptions: (t, string, localeOptions) => string"
      },
      {
        "id": "Core.Date.toLocaleString",
        "kind": "value",
        "name": "toLocaleString",
        "docstrings": [
          "`toLocaleString(date)`\n\nConverts a JavaScript date to a localized date-time string. It will use the current locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleString->Console.log\n// 2/19/2023, 3:40:00PM\n```"
        ],
        "signature": "let toLocaleString: t => string"
      },
      {
        "id": "Core.Date.toLocaleStringWithLocale",
        "kind": "value",
        "name": "toLocaleStringWithLocale",
        "docstrings": [
          "`toLocaleStringWithLocale(date, locale)`\n\nConverts a JavaScript date to a localized date-time string. It will use the specified locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleStringWithLocale(\"en-US\")->Console.log\n// 2/19/2023, 3:40:00PM\n```"
        ],
        "signature": "let toLocaleStringWithLocale: (t, string) => string"
      },
      {
        "id": "Core.Date.toLocaleStringWithLocaleAndOptions",
        "kind": "value",
        "name": "toLocaleStringWithLocaleAndOptions",
        "docstrings": [
          "`toLocaleStringWithLocaleAndOptions(date, locale, options)`\n\nConverts a JavaScript date to a localized date-time string. It will use the specified locale and formatting options.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleStringWithLocaleAndOptions(\"en\", { dateStyle: #short, timeStyle: #short })->Console.log\n// 2/19/23, 3:40PM\n\nDate.make()->Date.toLocaleStringWithLocaleAndOptions(\"en\", { era: #long, year: #numeric, month: #\"2-digit\", day: #\"2-digit\", hour: #numeric, timeZoneName: #short })->Console.log\n// 02/19/2023 Anno Domini, 3PM GMT+1\n```"
        ],
        "signature": "let toLocaleStringWithLocaleAndOptions: (t, string, localeOptions) => string"
      },
      {
        "id": "Core.Date.toLocaleTimeString",
        "kind": "value",
        "name": "toLocaleTimeString",
        "docstrings": [
          "`toLocaleTimeString(date)`\n\nConverts a JavaScript date to a localized time string. It will use the current locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleTimeString->Console.log\n// 3:40:00PM\n```"
        ],
        "signature": "let toLocaleTimeString: t => string"
      },
      {
        "id": "Core.Date.toLocaleTimeStringWithLocale",
        "kind": "value",
        "name": "toLocaleTimeStringWithLocale",
        "docstrings": [
          "`toLocaleTimeStringWithLocale(date, locale)`\n\nConverts a JavaScript date to a localized time string. It will use the specified locale.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleTimeStringWithLocale(\"en-US\")->Console.log\n// 3:40:00PM\n```"
        ],
        "signature": "let toLocaleTimeStringWithLocale: (t, string) => string"
      },
      {
        "id": "Core.Date.toLocaleTimeStringWithLocaleAndOptions",
        "kind": "value",
        "name": "toLocaleTimeStringWithLocaleAndOptions",
        "docstrings": [
          "`toLocaleTimeStringWithLocaleAndOptions(date, locale, options)`\n\nConverts a JavaScript date to a localized time string. It will use the specified locale and formatting options.\n\n## Examples\n```rescript\nDate.make()->Date.toLocaleTimeStringWithLocaleAndOptions(\"en-US\", { timeStyle: #long })->Console.log\n// 3:40:00PM GMT+1\n\nDate.make()->Date.toLocaleTimeStringWithLocaleAndOptions(\"de\", { hour: #\"2-digit\", minute: #\"2-digit\" })->Console.log\n// 15:40\n```"
        ],
        "signature": "let toLocaleTimeStringWithLocaleAndOptions: (t, string, localeOptions) => string"
      },
      {
        "id": "Core.Date.toISOString",
        "kind": "value",
        "name": "toISOString",
        "docstrings": [
          "`toISOString(date)`\n\nConverts a JavaScript date to a ISO 8601 string (YYYY-MM-DDTHH:mm:ss.sssZ). The date will be mapped to the UTC time.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+00:00\")->Date.toISOString->Console.log\n// 2023-01-01T00:00:00.000Z\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toISOString->Console.log\n// 2022-12-31T16:00:00.000Z\n```"
        ],
        "signature": "let toISOString: t => string"
      },
      {
        "id": "Core.Date.toUTCString",
        "kind": "value",
        "name": "toUTCString",
        "docstrings": [
          "`toUTCString(date)`\n\nConverts a JavaScript date to date time string. The date will be mapped to the UTC time.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+00:00\")->Date.toUTCString->Console.log\n// Sun, 01 Jan 2023 00:00:00 GMT\n\nDate.fromString(\"2023-01-01T00:00:00.00+08:00\")->Date.toUTCString->Console.log\n// Sat, 31 Dec 2022 16:00:00 GMT\n```"
        ],
        "signature": "let toUTCString: t => string"
      },
      {
        "id": "Core.Date.toJSON",
        "kind": "value",
        "name": "toJSON",
        "docstrings": [
          "`toJSON(date)`\n\nConverts a JavaScript date to a string.\nIf the date is valid, the function will return the same result as `Date.toISOString`.\nInvalid dates will return `None`.\n\n## Examples\n```rescript\nDate.fromString(\"2023-01-01T00:00:00.00+00:00\")->Date.toJSON\n// Some(\"2023-01-01T00:00:00.000Z\")\n\nDate.fromString(\"\")->Date.toJSON\n// None\n```"
        ],
        "signature": "let toJSON: t => option<string>"
      }
    ]
  },
  "core/dataview": {
    "id": "Core.DataView",
    "name": "DataView",
    "docstrings": [],
    "items": [
      {
        "id": "Core.DataView.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Core.DataView.fromBuffer",
        "kind": "value",
        "name": "fromBuffer",
        "docstrings": [],
        "signature": "let fromBuffer: Core__ArrayBuffer.t => t"
      },
      {
        "id": "Core.DataView.fromBufferToEnd",
        "kind": "value",
        "name": "fromBufferToEnd",
        "docstrings": [],
        "signature": "let fromBufferToEnd: (Core__ArrayBuffer.t, ~byteOffset: int) => t"
      },
      {
        "id": "Core.DataView.fromBufferWithRange",
        "kind": "value",
        "name": "fromBufferWithRange",
        "docstrings": [],
        "signature": "let fromBufferWithRange: (Core__ArrayBuffer.t, ~byteOffset: int, ~length: int) => t"
      },
      {
        "id": "Core.DataView.buffer",
        "kind": "value",
        "name": "buffer",
        "docstrings": [],
        "signature": "let buffer: t => Core__ArrayBuffer.t"
      },
      {
        "id": "Core.DataView.byteLength",
        "kind": "value",
        "name": "byteLength",
        "docstrings": [],
        "signature": "let byteLength: t => int"
      },
      {
        "id": "Core.DataView.byteOffset",
        "kind": "value",
        "name": "byteOffset",
        "docstrings": [],
        "signature": "let byteOffset: t => int"
      },
      {
        "id": "Core.DataView.getInt8",
        "kind": "value",
        "name": "getInt8",
        "docstrings": [],
        "signature": "let getInt8: t => int"
      },
      {
        "id": "Core.DataView.getUint8",
        "kind": "value",
        "name": "getUint8",
        "docstrings": [],
        "signature": "let getUint8: t => int"
      },
      {
        "id": "Core.DataView.getInt16",
        "kind": "value",
        "name": "getInt16",
        "docstrings": [],
        "signature": "let getInt16: t => int"
      },
      {
        "id": "Core.DataView.getUint16",
        "kind": "value",
        "name": "getUint16",
        "docstrings": [],
        "signature": "let getUint16: t => int"
      },
      {
        "id": "Core.DataView.getInt32",
        "kind": "value",
        "name": "getInt32",
        "docstrings": [],
        "signature": "let getInt32: t => int"
      },
      {
        "id": "Core.DataView.getUint32",
        "kind": "value",
        "name": "getUint32",
        "docstrings": [],
        "signature": "let getUint32: t => int"
      },
      {
        "id": "Core.DataView.getFloat32",
        "kind": "value",
        "name": "getFloat32",
        "docstrings": [],
        "signature": "let getFloat32: t => float"
      },
      {
        "id": "Core.DataView.getFloat64",
        "kind": "value",
        "name": "getFloat64",
        "docstrings": [],
        "signature": "let getFloat64: t => float"
      },
      {
        "id": "Core.DataView.getBigInt64",
        "kind": "value",
        "name": "getBigInt64",
        "docstrings": [],
        "signature": "let getBigInt64: t => bigint"
      },
      {
        "id": "Core.DataView.getBigUint64",
        "kind": "value",
        "name": "getBigUint64",
        "docstrings": [],
        "signature": "let getBigUint64: t => bigint"
      },
      {
        "id": "Core.DataView.setInt8",
        "kind": "value",
        "name": "setInt8",
        "docstrings": [],
        "signature": "let setInt8: (t, int) => unit"
      },
      {
        "id": "Core.DataView.setUint8",
        "kind": "value",
        "name": "setUint8",
        "docstrings": [],
        "signature": "let setUint8: (t, int) => unit"
      },
      {
        "id": "Core.DataView.setInt16",
        "kind": "value",
        "name": "setInt16",
        "docstrings": [],
        "signature": "let setInt16: (t, int) => unit"
      },
      {
        "id": "Core.DataView.setUint16",
        "kind": "value",
        "name": "setUint16",
        "docstrings": [],
        "signature": "let setUint16: (t, int) => unit"
      },
      {
        "id": "Core.DataView.setInt32",
        "kind": "value",
        "name": "setInt32",
        "docstrings": [],
        "signature": "let setInt32: (t, int) => unit"
      },
      {
        "id": "Core.DataView.setUint32",
        "kind": "value",
        "name": "setUint32",
        "docstrings": [],
        "signature": "let setUint32: (t, int) => unit"
      },
      {
        "id": "Core.DataView.setFloat32",
        "kind": "value",
        "name": "setFloat32",
        "docstrings": [],
        "signature": "let setFloat32: (t, float) => unit"
      },
      {
        "id": "Core.DataView.setFloat64",
        "kind": "value",
        "name": "setFloat64",
        "docstrings": [],
        "signature": "let setFloat64: (t, float) => unit"
      },
      {
        "id": "Core.DataView.setBigInt64",
        "kind": "value",
        "name": "setBigInt64",
        "docstrings": [],
        "signature": "let setBigInt64: (t, bigint) => unit"
      },
      {
        "id": "Core.DataView.setBigUint64",
        "kind": "value",
        "name": "setBigUint64",
        "docstrings": [],
        "signature": "let setBigUint64: (t, bigint) => unit"
      }
    ]
  },
  "core/console": {
    "id": "Core.Console",
    "name": "Console",
    "docstrings": [
      "Functions for interacting with JavaScript console.\n\nSee: [`console`](https://developer.mozilla.org/en-US/docs/Web/API/Console)."
    ],
    "items": [
      {
        "id": "Core.Console.assert_",
        "kind": "value",
        "name": "assert_",
        "docstrings": [
          "`assert_(assertion, value)` print a message to console if `assertion` evaluates `false`. Does nothing if it's `true`.\n\nSee [`console.assert`](https://developer.mozilla.org/en-US/docs/Web/API/console/assert)\non MDN.\n\n## Examples\n\n```rescript\nConsole.assert_(false, \"Hello World!\")\nConsole.assert_(42 == 42, \"The answer\")\n```"
        ],
        "signature": "let assert_: (bool, 'a) => unit"
      },
      {
        "id": "Core.Console.assert2",
        "kind": "value",
        "name": "assert2",
        "docstrings": [
          "`assert2(v1, v2)`. Like `assert_`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.assert2(false, \"Hello\", \"World\")\nConsole.assert2(42 == 42, [1, 2, 3], '4')\n```"
        ],
        "signature": "let assert2: (bool, 'a, 'b) => unit"
      },
      {
        "id": "Core.Console.assert3",
        "kind": "value",
        "name": "assert3",
        "docstrings": [
          "`assert3(v1, v2, v3)`. Like `assert_`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.assert3(false, \"Hello\", \"World\", \"ReScript\")\nConsole.assert3(42 == 42, \"One\", 2, #3)\n```"
        ],
        "signature": "let assert3: (bool, 'a, 'b, 'c) => unit"
      },
      {
        "id": "Core.Console.assert4",
        "kind": "value",
        "name": "assert4",
        "docstrings": [
          "`assert4(v1, v2, v3, v4)`. Like `assert_`, but with four arguments.\n\n## Examples\n\n```rescript\nlet value = 42\nConsole.assert4(false, \"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.assert4(value == 42, [1, 2], (3, 4), [#5, #6], #\"polyvar\")\n```"
        ],
        "signature": "let assert4: (bool, 'a, 'b, 'c, 'd) => unit"
      },
      {
        "id": "Core.Console.assert5",
        "kind": "value",
        "name": "assert5",
        "docstrings": [
          "`assert5(v1, v2, v3, v4, v5)`. Like `assert_`, but with five arguments.\n\n## Examples\n\n```rescript\nlet value = 42\nConsole.assert5(false, \"Hello\", \"World\", \"JS\", '!', '!')\nConsole.assert5(value == 42, [1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"
        ],
        "signature": "let assert5: (bool, 'a, 'b, 'c, 'd, 'e) => unit"
      },
      {
        "id": "Core.Console.assert6",
        "kind": "value",
        "name": "assert6",
        "docstrings": [
          "`assert6(v1, v2)`. Like `assert_`, but with six arguments.\n\n## Examples\n\n```rescript\nlet value = 42\nConsole.assert6(false, \"Hello\", \"World\", \"JS\", '!', '!', '?')\nConsole.assert6(value == 42, [1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"
        ],
        "signature": "let assert6: (bool, 'a, 'b, 'c, 'd, 'e, 'f) => unit"
      },
      {
        "id": "Core.Console.assertMany",
        "kind": "value",
        "name": "assertMany",
        "docstrings": [
          "`assertMany(assertion, arr)`. Like `assert_`, but variadic.\n\n## Examples\n\n```rescript\nlet value = 42\nConsole.assertMany(false, [\"Hello\", \"World\"])\nConsole.assertMany(value == 42, [1, 2, 3])\n```"
        ],
        "signature": "let assertMany: (bool, array<'a>) => unit"
      },
      {
        "id": "Core.Console.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "`clear()` clears the console, if allowed.\n\nSee [`console.clear`](https://developer.mozilla.org/en-US/docs/Web/API/console/clear)\non MDN.\n\n## Examples\n\n```rescript\nConsole.clear()\n```"
        ],
        "signature": "let clear: unit => unit"
      },
      {
        "id": "Core.Console.count",
        "kind": "value",
        "name": "count",
        "docstrings": [
          "`count(label)` prints to the console the number of times it's been called with the given label.\n\nSee [`console.count`](https://developer.mozilla.org/en-US/docs/Web/API/console/count)\non MDN.\n\n## Examples\n\n```rescript\nConsole.count(\"rescript\")\n```"
        ],
        "signature": "let count: string => unit"
      },
      {
        "id": "Core.Console.countReset",
        "kind": "value",
        "name": "countReset",
        "docstrings": [
          "`countReset(label)` resets the count for the given label to 0.\n\nSee [`console.countReset`](https://developer.mozilla.org/en-US/docs/Web/API/console/countReset)\non MDN.\n\n## Examples\n\n```rescript\nConsole.countReset(\"rescript\")\n```"
        ],
        "signature": "let countReset: string => unit"
      },
      {
        "id": "Core.Console.debug",
        "kind": "value",
        "name": "debug",
        "docstrings": [
          "`debug(value)` print a debug message to console.\n\nSee [`console.debug`](https://developer.mozilla.org/en-US/docs/Web/API/console/debug)\non MDN.\n\n## Examples\n\n```rescript\nConsole.debug(\"Hello\")\nlet obj = {\"name\": \"ReScript\", \"version\": 10}\nConsole.debug(obj)\n```"
        ],
        "signature": "let debug: 'a => unit"
      },
      {
        "id": "Core.Console.debug2",
        "kind": "value",
        "name": "debug2",
        "docstrings": [
          "`debug2(v1, v2)`. Like `debug`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.debug2(\"Hello\", \"World\")\nConsole.debug2([1, 2, 3], '4')\n```"
        ],
        "signature": "let debug2: ('a, 'b) => unit"
      },
      {
        "id": "Core.Console.debug3",
        "kind": "value",
        "name": "debug3",
        "docstrings": [
          "`debug3(v1, v2, v3)`. Like `debug`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.debug3(\"Hello\", \"World\", \"ReScript\")\nConsole.debug3(\"One\", 2, #3)\n```"
        ],
        "signature": "let debug3: ('a, 'b, 'c) => unit"
      },
      {
        "id": "Core.Console.debug4",
        "kind": "value",
        "name": "debug4",
        "docstrings": [
          "`debug4(v1, v2, v3, v4)`. Like `debug`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.debug4(\"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.debug4([1, 2], (3, 4), [#5, #6], #\"polyvar\")\n```"
        ],
        "signature": "let debug4: ('a, 'b, 'c, 'd) => unit"
      },
      {
        "id": "Core.Console.debug5",
        "kind": "value",
        "name": "debug5",
        "docstrings": [
          "`debug5(v1, v2, v3, v4, v5)`. Like `debug`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.debug5(\"Hello\", \"World\", \"JS\", '!', '!')\nConsole.debug5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"
        ],
        "signature": "let debug5: ('a, 'b, 'c, 'd, 'e) => unit"
      },
      {
        "id": "Core.Console.debug6",
        "kind": "value",
        "name": "debug6",
        "docstrings": [
          "`debug6(v1, v2, v3, v4, v5, v6)`. Like `debug`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.debug6(\"Hello\", \"World\", \"JS\", '!', '!', '?')\nConsole.debug6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"
        ],
        "signature": "let debug6: ('a, 'b, 'c, 'd, 'e, 'f) => unit"
      },
      {
        "id": "Core.Console.debugMany",
        "kind": "value",
        "name": "debugMany",
        "docstrings": [
          "`debugMany(arr)`. Like `debug`, but variadic.\n\n## Examples\n\n```rescript\nConsole.debugMany([\"Hello\", \"World\"])\nConsole.debugMany([1, 2, 3])\n```"
        ],
        "signature": "let debugMany: array<'a> => unit"
      },
      {
        "id": "Core.Console.dir",
        "kind": "value",
        "name": "dir",
        "docstrings": [
          "`dir(object)` displays an interactive view of the object in the console.\n\nSee [`console.dir`](https://developer.mozilla.org/en-US/docs/Web/API/console/dir)\non MDN.\n\n## Examples\n\n```rescript\nConsole.dir({\"language\": \"rescript\", \"version\": \"10.1.2\"})\n```"
        ],
        "signature": "let dir: 'a => unit"
      },
      {
        "id": "Core.Console.dirxml",
        "kind": "value",
        "name": "dirxml",
        "docstrings": [
          "`dirxml(object)` displays an interactive tree view of an XML/HTML element in the console.\n\nSee [`console.dirxml`](https://developer.mozilla.org/en-US/docs/Web/API/console/dirxml)\non MDN."
        ],
        "signature": "let dirxml: 'a => unit"
      },
      {
        "id": "Core.Console.error",
        "kind": "value",
        "name": "error",
        "docstrings": [
          "`error(value)` prints an error message to console.\n\nSee [`console.error`](https://developer.mozilla.org/en-US/docs/Web/API/console/error)\non MDN.\n\n## Examples\n\n```rescript\nConsole.error(\"error message\")\nConsole.error((\"error\", \"invalid value\"))\n```"
        ],
        "signature": "let error: 'a => unit"
      },
      {
        "id": "Core.Console.error2",
        "kind": "value",
        "name": "error2",
        "docstrings": [
          "`error(v1, v2)`. Like `error`, but two arguments.\n\n## Examples\n\n```rescript\nConsole.error2(\"Error\", \"here\")\nConsole.error2((\"log\", \"error\"), \"message\")\n```"
        ],
        "signature": "let error2: ('a, 'b) => unit"
      },
      {
        "id": "Core.Console.error3",
        "kind": "value",
        "name": "error3",
        "docstrings": [
          "`error3(v1, v2, v3)`. Like `error`, but three arguments.\n\n## Examples\n\n```rescript\nConsole.error3(\"Hello\", \"World\", \"!!!\")\nConsole.error3(#first, #second, #third)\n```"
        ],
        "signature": "let error3: ('a, 'b, 'c) => unit"
      },
      {
        "id": "Core.Console.error4",
        "kind": "value",
        "name": "error4",
        "docstrings": [
          "`error4(v1, v2, v3, v4)`. Like `error`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.error4(\"Hello\", \"World\", \"ReScript\", '!')\nConsole.error4(#first, #second, #third, (\"fourth\"))\n```"
        ],
        "signature": "let error4: ('a, 'b, 'c, 'd) => unit"
      },
      {
        "id": "Core.Console.error5",
        "kind": "value",
        "name": "error5",
        "docstrings": [
          "`error5(v1, v2, v3, v4, v5)`. Like `error`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.error5('e', 'r', 'r', 'o', 'r')\nConsole.error5(1, #second, #third, (\"fourth\"), 'c')\n```"
        ],
        "signature": "let error5: ('a, 'b, 'c, 'd, 'e) => unit"
      },
      {
        "id": "Core.Console.error6",
        "kind": "value",
        "name": "error6",
        "docstrings": [
          "`error6(v1, v2, v3, v4, v5, v6)`. Like `error`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.error6(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\", '!')\nConsole.error6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"
        ],
        "signature": "let error6: ('a, 'b, 'c, 'd, 'e, 'f) => unit"
      },
      {
        "id": "Core.Console.group",
        "kind": "value",
        "name": "group",
        "docstrings": [
          "`group(label)` creates a new \"group\" level with the given label.\n\nSee [`console.group`](https://developer.mozilla.org/en-US/docs/Web/API/console/group)\non MDN.\n\n## Example\n\n```rescript\nConsole.group(\"first group\")\nConsole.group(\"second group\")\nConsole.log(\"a message on the second level\")\nConsole.groupEnd()\nConsole.log(\"a message message on the first level\")\nConsole.groupEnd()\n```"
        ],
        "signature": "let group: string => unit"
      },
      {
        "id": "Core.Console.groupCollapsed",
        "kind": "value",
        "name": "groupCollapsed",
        "docstrings": [
          "`groupCollapsed(label)`. Like `group` but collapses the group initially.\n\nSee [`console.groupCollapsed`](https://developer.mozilla.org/en-US/docs/Web/API/console/groupCollapsed)\non MDN."
        ],
        "signature": "let groupCollapsed: string => unit"
      },
      {
        "id": "Core.Console.groupEnd",
        "kind": "value",
        "name": "groupEnd",
        "docstrings": [
          "`groupEnd()` ends the current group.\n\nSee [`console.groupEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/groupEnd)\non MDN."
        ],
        "signature": "let groupEnd: unit => unit"
      },
      {
        "id": "Core.Console.errorMany",
        "kind": "value",
        "name": "errorMany",
        "docstrings": [
          "`errorMany(arr)`. Like `error`, but variadic.\n\n## Examples\n\n```rescript\nConsole.errorMany([\"Hello\", \"World\"])\nConsole.errorMany([1, 2, 3])\n```"
        ],
        "signature": "let errorMany: array<'a> => unit"
      },
      {
        "id": "Core.Console.info",
        "kind": "value",
        "name": "info",
        "docstrings": [
          "`info(value)` print an informational message to console.\n\nSee [`console.info`](https://developer.mozilla.org/en-US/docs/Web/API/console/info)\non MDN.\n\n## Examples\n\n```rescript\nConsole.info(\"Information\")\nConsole.info((\"Hello\", \"JS\"))\n```"
        ],
        "signature": "let info: 'a => unit"
      },
      {
        "id": "Core.Console.info2",
        "kind": "value",
        "name": "info2",
        "docstrings": [
          "`info2(v1, v2)`. Like `info`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.info2(\"Info\", \"failed to download\")\nConsole.info2(#info, {\"name\": \"ReScript\"})\n```"
        ],
        "signature": "let info2: ('a, 'b) => unit"
      },
      {
        "id": "Core.Console.info3",
        "kind": "value",
        "name": "info3",
        "docstrings": [
          "`info3(v1, v2, v3)`. Like `info`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.info3(\"Hello\", \"World\", \"ReScript\")\nConsole.info3([1, 2, 3], #4, #5)\n```"
        ],
        "signature": "let info3: ('a, 'b, 'c) => unit"
      },
      {
        "id": "Core.Console.info4",
        "kind": "value",
        "name": "info4",
        "docstrings": [
          "`info4(v1, v2, v3, v4)`. Like `info`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.info4(\"Hello\", \"World\", \"ReScript\", '!')\nConsole.info4([1, 2, 3], #4, #5, #lastinfo)\n```"
        ],
        "signature": "let info4: ('a, 'b, 'c, 'd) => unit"
      },
      {
        "id": "Core.Console.info5",
        "kind": "value",
        "name": "info5",
        "docstrings": [
          "`info5(v1, v2, v3, v4, v5)`. Like `info`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.info5(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\")\nConsole.info5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"
        ],
        "signature": "let info5: ('a, 'b, 'c, 'd, 'e) => unit"
      },
      {
        "id": "Core.Console.info6",
        "kind": "value",
        "name": "info6",
        "docstrings": [
          "`info6(v1, v2, v3, v4, v5, v6)`. Like `info`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.info6(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\", '!')\nConsole.info6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"
        ],
        "signature": "let info6: ('a, 'b, 'c, 'd, 'e, 'f) => unit"
      },
      {
        "id": "Core.Console.infoMany",
        "kind": "value",
        "name": "infoMany",
        "docstrings": [
          "`infoMany(arr)`. Like `info`, but variadic.\n\n## Examples\n\n```rescript\nConsole.infoMany([\"Hello\", \"World\"])\nConsole.infoMany([1, 2, 3])\n```"
        ],
        "signature": "let infoMany: array<'a> => unit"
      },
      {
        "id": "Core.Console.log",
        "kind": "value",
        "name": "log",
        "docstrings": [
          "`log(value)` print a message to console.\n\nSee [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/console/log)\non MDN.\n\n## Examples\n\n```rescript\nConsole.log(\"Hello\")\nlet obj = {\"name\": \"ReScript\", \"version\": 10}\nConsole.log(obj)\n```"
        ],
        "signature": "let log: 'a => unit"
      },
      {
        "id": "Core.Console.log2",
        "kind": "value",
        "name": "log2",
        "docstrings": [
          "`log2(v1, v2)`. Like `log`, but with two arguments.\n\n## Examples\n\n```rescript\nConsole.log2(\"Hello\", \"World\")\nConsole.log2([1, 2, 3], '4')\n```"
        ],
        "signature": "let log2: ('a, 'b) => unit"
      },
      {
        "id": "Core.Console.log3",
        "kind": "value",
        "name": "log3",
        "docstrings": [
          "`log3(v1, v2, v3)`. Like `log`, but with three arguments.\n\n## Examples\n\n```rescript\nConsole.log3(\"Hello\", \"World\", \"ReScript\")\nConsole.log3(\"One\", 2, #3)\n```"
        ],
        "signature": "let log3: ('a, 'b, 'c) => unit"
      },
      {
        "id": "Core.Console.log4",
        "kind": "value",
        "name": "log4",
        "docstrings": [
          "`log4(v1, v2, v3, v4)`. Like `log`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.log4(\"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.log4([1, 2], (3, 4), [#5, #6], #\"polyvar\")\n```"
        ],
        "signature": "let log4: ('a, 'b, 'c, 'd) => unit"
      },
      {
        "id": "Core.Console.log5",
        "kind": "value",
        "name": "log5",
        "docstrings": [
          "`log5(v1, v2, v3, v4, v5)`. Like `log`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.log5(\"Hello\", \"World\", \"JS\", '!', '!')\nConsole.log5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"
        ],
        "signature": "let log5: ('a, 'b, 'c, 'd, 'e) => unit"
      },
      {
        "id": "Core.Console.log6",
        "kind": "value",
        "name": "log6",
        "docstrings": [
          "`log6(v1, v2, v3, v4, v5, v6)`. Like `log`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.log6(\"Hello\", \"World\", \"JS\", '!', '!', '?')\nConsole.log6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"
        ],
        "signature": "let log6: ('a, 'b, 'c, 'd, 'e, 'f) => unit"
      },
      {
        "id": "Core.Console.logMany",
        "kind": "value",
        "name": "logMany",
        "docstrings": [
          "`logMany(arr)`. Like `log`, but variadic.\n\n## Examples\n\n```rescript\nConsole.logMany([\"Hello\", \"World\"])\nConsole.logMany([1, 2, 3])\n```"
        ],
        "signature": "let logMany: array<'a> => unit"
      },
      {
        "id": "Core.Console.table",
        "kind": "value",
        "name": "table",
        "docstrings": [
          "`table(object)` displays an tabular view of the object in the console.\n\nSee [`console.table`](https://developer.mozilla.org/en-US/docs/Web/API/console/table)\non MDN.\n\n## Examples\n\n```rescript\nConsole.table({\"language\": \"rescript\", \"version\": \"10.1.2\"})\n```"
        ],
        "signature": "let table: 'a => unit"
      },
      {
        "id": "Core.Console.time",
        "kind": "value",
        "name": "time",
        "docstrings": [
          "`time(label)` creates a timer to measure how long an operation takes. `label`\nmust be a unique name. Call `console.timeEnd` with the same `label` to print\noutput time.\n\nSee [`console.time`](https://developer.mozilla.org/en-US/docs/Web/API/console/time)\non MDN.\n\n## Examples\n\n```rescript\nConsole.time(\"for_time\")\nfor x in 3 downto 1 {\n  Console.log(x)\n  Console.timeLog(\"for_time\")\n}\nConsole.timeEnd(\"for_time\")\n```"
        ],
        "signature": "let time: string => unit"
      },
      {
        "id": "Core.Console.timeEnd",
        "kind": "value",
        "name": "timeEnd",
        "docstrings": [
          "`timeEnd(label)` stops a timer created by `time`.\n\nSee [`console.timeEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeEnd)\non MDN.\n\n## Examples\n\n```rescript\nConsole.time(\"for_time\")\nfor x in 3 downto 1 {\n  Console.log(x)\n  Console.timeLog(\"for_time\")\n}\nConsole.timeEnd(\"for_time\")\n```"
        ],
        "signature": "let timeEnd: string => unit"
      },
      {
        "id": "Core.Console.timeLog",
        "kind": "value",
        "name": "timeLog",
        "docstrings": [
          "`timeLog(label)` prints the current elapsed time of the given timer to the console.\n\nSee [`console.timeLog`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeLog)\non MDN.\n\n## Examples\n\n```rescript\nConsole.time(\"for_time\")\nfor x in 3 downto 1 {\n  Console.log(x)\n  Console.timeLog(\"for_time\")\n}\nConsole.timeEnd(\"for_time\")\n```"
        ],
        "signature": "let timeLog: string => unit"
      },
      {
        "id": "Core.Console.trace",
        "kind": "value",
        "name": "trace",
        "docstrings": [
          "`trace()` print a stack trace to console.\n\nSee [`console.trace`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace)\non MDN.\n\n## Examples\n\n```rescript\nlet main = () => {\n  Console.trace()\n}\nmain()\n// In the console, the following trace will be displayed:\n// main\n// <anonymous>\n```"
        ],
        "signature": "let trace: unit => unit"
      },
      {
        "id": "Core.Console.warn",
        "kind": "value",
        "name": "warn",
        "docstrings": [
          "`warn(value)` print a warning message to console.\n\nSee [`console.warn`](https://developer.mozilla.org/en-US/docs/Web/API/console/warn)\non MDN.\n\n## Examples\n\n```rescript\nConsole.warn(\"Warning\")\nConsole.warn((\"Warning\", \"invalid number\"))\n```"
        ],
        "signature": "let warn: 'a => unit"
      },
      {
        "id": "Core.Console.warn2",
        "kind": "value",
        "name": "warn2",
        "docstrings": [
          "`warn2(v1, v2)`. Like `warn`, but two arguments.\n\n## Examples\n\n```rescript\nConsole.warn2(\"Hello\", \"World\")\nConsole.warn2([1, 2, 3], 4)\n```"
        ],
        "signature": "let warn2: ('a, 'b) => unit"
      },
      {
        "id": "Core.Console.warn3",
        "kind": "value",
        "name": "warn3",
        "docstrings": [
          "`warn3(v1, v2, v3)`. Like `warn`, but three arguments.\n\n## Examples\n\n```rescript\nConsole.warn3(\"Hello\", \"World\", \"ReScript\")\nConsole.warn3([1, 2, 3], #4, #5)\n```"
        ],
        "signature": "let warn3: ('a, 'b, 'c) => unit"
      },
      {
        "id": "Core.Console.warn4",
        "kind": "value",
        "name": "warn4",
        "docstrings": [
          "`warn4(v1, v2, v3, v4)`. Like `warn`, but with four arguments.\n\n## Examples\n\n```rescript\nConsole.warn4(\"Hello\", \"World\", \"ReScript\", \"!!!\")\nConsole.warn4(#first, #second, #third, (\"fourth\"))\n```"
        ],
        "signature": "let warn4: ('a, 'b, 'c, 'd) => unit"
      },
      {
        "id": "Core.Console.warn5",
        "kind": "value",
        "name": "warn5",
        "docstrings": [
          "`warn5(v1, v2, v3, v4, v5)`. Like `warn`, but with five arguments.\n\n## Examples\n\n```rescript\nConsole.warn5(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\")\nConsole.warn5([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"})\n```"
        ],
        "signature": "let warn5: ('a, 'b, 'c, 'd, 'e) => unit"
      },
      {
        "id": "Core.Console.warn6",
        "kind": "value",
        "name": "warn6",
        "docstrings": [
          "`warn6(v1, v2, v3, v4, v5, v6)`. Like `warn`, but with six arguments.\n\n## Examples\n\n```rescript\nConsole.warn6(\"Hello\", \"World\", \"from\", \"JS\", \"!!!\", '!')\nConsole.warn6([1, 2], (3, 4), [#5, #6], #\"polyvar\", {\"name\": \"ReScript\"}, 42)\n```"
        ],
        "signature": "let warn6: ('a, 'b, 'c, 'd, 'e, 'f) => unit"
      },
      {
        "id": "Core.Console.warnMany",
        "kind": "value",
        "name": "warnMany",
        "docstrings": [
          "`warnMany(arr)`. Like `warn`, but variadic.\n\n## Examples\n\n```rescript\nConsole.warnMany([\"Hello\", \"World\"])\nConsole.warnMany([1, 2, 3])\n```"
        ],
        "signature": "let warnMany: array<'a> => unit"
      }
    ]
  },
  "core/array": {
    "id": "Core.Array",
    "name": "Array",
    "docstrings": [],
    "items": [
      {
        "id": "Core.Array.fromIterator",
        "kind": "value",
        "name": "fromIterator",
        "docstrings": [
          "`fromIterator(iterator)`\n\n  Creates an array from the provided `iterator`\n\n  ```res example\n  let map = Map.fromArray([(\"foo\", 1), (\"bar\", 2)])\n\n  Array.fromIterator(map->Map.values) // [1, 2]\n  ```"
        ],
        "signature": "let fromIterator: Core__Iterator.t<'a> => array<'a>"
      },
      {
        "id": "Core.Array.fromArrayLike",
        "kind": "value",
        "name": "fromArrayLike",
        "docstrings": [],
        "signature": "let fromArrayLike: Js.Array2.array_like<'a> => array<'a>"
      },
      {
        "id": "Core.Array.fromArrayLikeWithMap",
        "kind": "value",
        "name": "fromArrayLikeWithMap",
        "docstrings": [],
        "signature": "let fromArrayLikeWithMap: (Js.Array2.array_like<'a>, 'a => 'b) => array<'b>"
      },
      {
        "id": "Core.Array.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(~length, init)`\n\n  Creates an array of length `length` initialized with the value of `init`.\n\n  ```res example\n  Array.make(~length=3, #apple) == [#apple, #apple, #apple]\n  ```"
        ],
        "signature": "let make: (~length: int, 'a) => array<'a>"
      },
      {
        "id": "Core.Array.fromInitializer",
        "kind": "value",
        "name": "fromInitializer",
        "docstrings": [
          "`fromInitializer(~length, f)`\n\n  Creates an array of length `length` initialized with the value returned from `f ` for each index.\n\n  ```res example\n  Array.fromInitializer(~length=3, i => i + 3) == [3, 4, 5]\n  ```"
        ],
        "signature": "let fromInitializer: (~length: int, int => 'a) => array<'a>"
      },
      {
        "id": "Core.Array.equal",
        "kind": "value",
        "name": "equal",
        "docstrings": [],
        "signature": "let equal: (array<'a>, array<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Core.Array.compare",
        "kind": "value",
        "name": "compare",
        "docstrings": [],
        "signature": "let compare: (\n  array<'a>,\n  array<'a>,\n  ('a, 'a) => Core__Ordering.t,\n) => Core__Ordering.t"
      },
      {
        "id": "Core.Array.isArray",
        "kind": "value",
        "name": "isArray",
        "docstrings": [],
        "signature": "let isArray: 'a => bool"
      },
      {
        "id": "Core.Array.length",
        "kind": "value",
        "name": "length",
        "docstrings": [
          "`length(array)` returns the length of (i.e. number of items in) the array.\n\nSee [`Array.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\n\nConsole.log(someArray->Array.length) // 2\n```"
        ],
        "signature": "let length: array<'a> => int"
      },
      {
        "id": "Core.Array.copyAllWithin",
        "kind": "value",
        "name": "copyAllWithin",
        "docstrings": [],
        "signature": "let copyAllWithin: (array<'a>, ~target: int) => array<'a>"
      },
      {
        "id": "Core.Array.copyWithinToEnd",
        "kind": "value",
        "name": "copyWithinToEnd",
        "docstrings": [],
        "signature": "let copyWithinToEnd: (array<'a>, ~target: int, ~start: int) => array<'a>"
      },
      {
        "id": "Core.Array.copyWithin",
        "kind": "value",
        "name": "copyWithin",
        "docstrings": [],
        "signature": "let copyWithin: (\n  array<'a>,\n  ~target: int,\n  ~start: int,\n  ~end: int,\n) => array<'a>"
      },
      {
        "id": "Core.Array.fillAll",
        "kind": "value",
        "name": "fillAll",
        "docstrings": [
          "`fillAll(array, value)` fills the entire `array` with `value`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.fill`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\nmyArray->Array.fillAll(9)\n\nConsole.log(myArray) // [9, 9, 9, 9]\n```"
        ],
        "signature": "let fillAll: (array<'a>, 'a) => unit"
      },
      {
        "id": "Core.Array.fillToEnd",
        "kind": "value",
        "name": "fillToEnd",
        "docstrings": [
          "`fillToEnd(array, value, ~start)` fills `array` with `value` from the `start` index.\n\nBeware this will *mutate* the array.\n\nSee [`Array.fill`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\nmyArray->Array.fillToEnd(9, ~start=1)\n\nConsole.log(myArray) // [1, 9, 9, 9]\n```"
        ],
        "signature": "let fillToEnd: (array<'a>, 'a, ~start: int) => unit"
      },
      {
        "id": "Core.Array.fill",
        "kind": "value",
        "name": "fill",
        "docstrings": [
          "`fill(array, value, ~start, ~end)` fills `array` with `value` from `start` to `end`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.fill`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\nmyArray->Array.fill(9, ~start=1, ~end=2)\n\nConsole.log(myArray) // [1, 9, 9, 4]\n```"
        ],
        "signature": "let fill: (array<'a>, 'a, ~start: int, ~end: int) => unit"
      },
      {
        "id": "Core.Array.pop",
        "kind": "value",
        "name": "pop",
        "docstrings": [
          "`pop(array)` removes the last item from `array` and returns it.\n\nBeware this will *mutate* the array.\n\nSee [`Array.pop`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nlet lastItem = someArray->Array.pop // \"hello\"\n\nConsole.log(someArray) // [\"hi\"]. Notice last item is gone.\n```"
        ],
        "signature": "let pop: array<'a> => option<'a>"
      },
      {
        "id": "Core.Array.push",
        "kind": "value",
        "name": "push",
        "docstrings": [
          "`push(array, item)` appends `item` to the end of `array`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.push`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.push(\"yay\")\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\"]\n```"
        ],
        "signature": "let push: (array<'a>, 'a) => unit"
      },
      {
        "id": "Core.Array.pushMany",
        "kind": "value",
        "name": "pushMany",
        "docstrings": [
          "`pushMany(array, itemsArray)` appends many new items to the end of the array.\n\nBeware this will *mutate* the array.\n\nSee [`Array.push`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.pushMany([\"yay\", \"wehoo\"])\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\", \"wehoo\"]\n```"
        ],
        "signature": "let pushMany: (array<'a>, array<'a>) => unit"
      },
      {
        "id": "Core.Array.reverse",
        "kind": "value",
        "name": "reverse",
        "docstrings": [
          "`reverse(array)` reverses the order of the items in `array`.\n\nBeware this will *mutate* the array.\n\nSee [`Array.reverse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.reverse\n\nConsole.log(someArray) // [\"hello\", \"h1\"]\n```"
        ],
        "signature": "let reverse: array<'a> => unit"
      },
      {
        "id": "Core.Array.shift",
        "kind": "value",
        "name": "shift",
        "docstrings": [
          "`shift(array)` removes the first item in the array, and returns it.\n\nBeware this will *mutate* the array.\n\nSee [`Array.shift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nlet lastItem = someArray->Array.shift // \"hi\"\n\nConsole.log(someArray) // [\"hello\"]. Notice first item is gone.\n```"
        ],
        "signature": "let shift: array<'a> => option<'a>"
      },
      {
        "id": "Core.Array.toSorted",
        "kind": "value",
        "name": "toSorted",
        "docstrings": [
          "`toSorted(array, comparator)` returns a new, sorted array from `array`, using the `comparator` function.\n\nSee [`Array.toSorted`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted) on MDN.\n\n## Examples\n```rescript\nlet someArray = [3, 2, 1]\nlet sorted = someArray->Array.toSorted(Int.compare)\n\nConsole.log(sorted) // [1, 2, 3]\nConsole.log(someArray) // [3, 2, 1]. Original unchanged\n```"
        ],
        "signature": "let toSorted: (array<'a>, ('a, 'a) => Core__Ordering.t) => array<'a>"
      },
      {
        "id": "Core.Array.sort",
        "kind": "value",
        "name": "sort",
        "docstrings": [
          "`sort(array, comparator)` sorts `array` in-place using the `comparator` function.\n\nBeware this will *mutate* the array.\n\nSee [`Array.sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) on MDN.\n\n## Examples\n```rescript\nlet someArray = [3, 2, 1]\nsomeArray->Array.sort((a, b) => float(a - b))\n\nConsole.log(someArray) // [1, 2, 3]\n```"
        ],
        "signature": "let sort: (array<'a>, ('a, 'a) => Core__Ordering.t) => unit"
      },
      {
        "id": "Core.Array.splice",
        "kind": "value",
        "name": "splice",
        "docstrings": [],
        "signature": "let splice: (\n  array<'a>,\n  ~start: int,\n  ~remove: int,\n  ~insert: array<'a>,\n) => unit"
      },
      {
        "id": "Core.Array.toSpliced",
        "kind": "value",
        "name": "toSpliced",
        "docstrings": [],
        "signature": "let toSpliced: (\n  array<'a>,\n  ~start: int,\n  ~remove: int,\n  ~insert: array<'a>,\n) => array<'a>"
      },
      {
        "id": "Core.Array.with",
        "kind": "value",
        "name": "with",
        "docstrings": [],
        "signature": "let with: (array<'a>, int, 'a) => array<'a>"
      },
      {
        "id": "Core.Array.unshift",
        "kind": "value",
        "name": "unshift",
        "docstrings": [
          "`unshift(array, item)` inserts a new item at the start of the array.\n\nBeware this will *mutate* the array.\n\nSee [`Array.unshift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.unshift(\"yay\")\n\nConsole.log(someArray) // [\"yay\", \"hi\", \"hello\"]\n```"
        ],
        "signature": "let unshift: (array<'a>, 'a) => unit"
      },
      {
        "id": "Core.Array.unshiftMany",
        "kind": "value",
        "name": "unshiftMany",
        "docstrings": [
          "`unshiftMany(array, itemsArray)` inserts many new items to the start of the array.\n\nBeware this will *mutate* the array.\n\nSee [`Array.push`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nsomeArray->Array.unshiftMany([\"yay\", \"wehoo\"])\n\nConsole.log(someArray) // [\"yay\", \"wehoo\", \"hi\", \"hello\"]\n```"
        ],
        "signature": "let unshiftMany: (array<'a>, array<'a>) => unit"
      },
      {
        "id": "Core.Array.concat",
        "kind": "value",
        "name": "concat",
        "docstrings": [
          "`concat(array1, array2)` concatenates the two arrays, creating a new array.\n\nSee [`Array.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) on MDN.\n\n## Examples\n```rescript\nlet array1 = [\"hi\", \"hello\"]\nlet array2 = [\"yay\", \"wehoo\"]\n\nlet someArray = array1->Array.concat(array2)\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\", \"wehoo\"]\n```"
        ],
        "signature": "let concat: (array<'a>, array<'a>) => array<'a>"
      },
      {
        "id": "Core.Array.concatMany",
        "kind": "value",
        "name": "concatMany",
        "docstrings": [
          "`concatMany(array1, arrays)` concatenates array1 with several other arrays, creating a new array.\n\nSee [`Array.concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) on MDN.\n\n## Examples\n```rescript\nlet array1 = [\"hi\", \"hello\"]\nlet array2 = [\"yay\"]\nlet array3 = [\"wehoo\"]\n\nlet someArray = array1->Array.concatMany([array2, array3])\n\nConsole.log(someArray) // [\"hi\", \"hello\", \"yay\", \"wehoo\"]\n```"
        ],
        "signature": "let concatMany: (array<'a>, array<array<'a>>) => array<'a>"
      },
      {
        "id": "Core.Array.flat",
        "kind": "value",
        "name": "flat",
        "docstrings": [
          "`flat(arrays)` concatenates an array of arrays into a single array.\n\nSee [`Array.flat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) on MDN.\n\n## Examples\n```rescript\nConsole.log([[1], [2], [3, 4]]->Array.flat) // [1, 2, 3, 4]\n```"
        ],
        "signature": "let flat: array<array<'a>> => array<'a>"
      },
      {
        "id": "Core.Array.includes",
        "kind": "value",
        "name": "includes",
        "docstrings": [
          "`includes(array, item)` checks whether `array` includes `item`, by doing a [strict check for equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality).\n\nSee [`Array.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes) on MDN.\n\n## Examples\n```rescript\nConsole.log([1, 2]->Array.includes(1)) // true\nConsole.log([1, 2]->Array.includes(3)) // false\nConsole.log([{\"language\": \"ReScript\"}]->Array.includes({\"language\": \"ReScript\"})) // false, because of strict equality\n```"
        ],
        "signature": "let includes: (array<'a>, 'a) => bool"
      },
      {
        "id": "Core.Array.indexOf",
        "kind": "value",
        "name": "indexOf",
        "docstrings": [
          "`indexOf(array, item)` returns the index of the provided `item` in `array`. Uses [strict check for equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality) when comparing items.\n\nReturns `-1` if the item doesn not exist. Check out `Array.indexOfOpt` for a version that returns `None` instead of `-1` if the item does not exist.\n\nSee [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) on MDN.\n\n## Examples\n```rescript\nConsole.log([1, 2]->Array.indexOf(2)) // 1\nConsole.log([1, 2]->Array.indexOf(3)) // -1\nConsole.log([{\"language\": \"ReScript\"}]->Array.indexOf({\"language\": \"ReScript\"})) // -1, because of strict equality\n```"
        ],
        "signature": "let indexOf: (array<'a>, 'a) => int"
      },
      {
        "id": "Core.Array.indexOfOpt",
        "kind": "value",
        "name": "indexOfOpt",
        "docstrings": [
          "`indexOfOpt(array, item)` returns an option of the index of the provided `item` in `array`. Uses [strict check for equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality) when comparing items.\n\nSee [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) on MDN.\n\n## Examples\n```rescript\nConsole.log([1, 2]->Array.indexOfOpt(2)) // Some(1)\nConsole.log([1, 2]->Array.indexOfOpt(3)) // None\nConsole.log([{\"language\": \"ReScript\"}]->Array.indexOfOpt({\"language\": \"ReScript\"})) // None, because of strict equality\n```"
        ],
        "signature": "let indexOfOpt: (array<'a>, 'a) => option<int>"
      },
      {
        "id": "Core.Array.indexOfFrom",
        "kind": "value",
        "name": "indexOfFrom",
        "docstrings": [],
        "signature": "let indexOfFrom: (array<'a>, 'a, int) => int"
      },
      {
        "id": "Core.Array.join",
        "kind": "value",
        "name": "join",
        "docstrings": [
          "`join(array, separator)` produces a string where all items of `array` are printed, separated by `separator`. Array items must be strings, to join number or other arrays, use `joinUnsafe`. Under the hood this will run JavaScript's `toString` on all the array items.\n\nSee [Array.join](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join)\n\n## Examples\n```rescript\nlet array = [\"One\", \"Two\", \"Three\"]\n\nConsole.log(array->Array.join(\" -- \")) // One -- Two -- Three\n```"
        ],
        "signature": "let join: (array<string>, string) => string"
      },
      {
        "id": "Core.Array.joinWith",
        "kind": "value",
        "name": "joinWith",
        "docstrings": [
          "`joinWith(array, separator)` produces a string where all items of `array` are printed, separated by `separator`. Array items must be strings, to join number or other arrays, use `joinWithUnsafe`. Under the hood this will run JavaScript's `toString` on all the array items.\n\n## Examples\n```rescript\nlet array = [\"One\", \"Two\", \"Three\"]\n\nConsole.log(array->Array.joinWith(\" -- \")) // One -- Two -- Three\n```"
        ],
        "signature": "let joinWith: (array<string>, string) => string",
        "deprecated": "Use `join` instead"
      },
      {
        "id": "Core.Array.joinUnsafe",
        "kind": "value",
        "name": "joinUnsafe",
        "docstrings": [
          "`joinUnsafe(array, separator)` produces a string where all items of `array` are printed, separated by `separator`. Under the hood this will run JavaScript's `toString` on all the array items.\n\nSee [Array.join](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join)\n\n## Examples\n```rescript\nlet array = [1, 2, 3]\n\nConsole.log(array->Array.joinUnsafe(\" -- \")) // 1 -- 2 -- 3\n```"
        ],
        "signature": "let joinUnsafe: (array<'a>, string) => string"
      },
      {
        "id": "Core.Array.joinWithUnsafe",
        "kind": "value",
        "name": "joinWithUnsafe",
        "docstrings": [
          "`joinWithUnsafe(array, separator)` produces a string where all items of `array` are printed, separated by `separator`. Under the hood this will run JavaScript's `toString` on all the array items.\n\n## Examples\n```rescript\nlet array = [1, 2, 3]\n\nConsole.log(array->Array.joinWithUnsafe(\" -- \")) // 1 -- 2 -- 3\n```"
        ],
        "signature": "let joinWithUnsafe: (array<'a>, string) => string",
        "deprecated": "Use `joinUnsafe` instead"
      },
      {
        "id": "Core.Array.lastIndexOf",
        "kind": "value",
        "name": "lastIndexOf",
        "docstrings": [],
        "signature": "let lastIndexOf: (array<'a>, 'a) => int"
      },
      {
        "id": "Core.Array.lastIndexOfOpt",
        "kind": "value",
        "name": "lastIndexOfOpt",
        "docstrings": [],
        "signature": "let lastIndexOfOpt: (array<'a>, 'a) => option<int>"
      },
      {
        "id": "Core.Array.lastIndexOfFrom",
        "kind": "value",
        "name": "lastIndexOfFrom",
        "docstrings": [],
        "signature": "let lastIndexOfFrom: (array<'a>, 'a, int) => int"
      },
      {
        "id": "Core.Array.slice",
        "kind": "value",
        "name": "slice",
        "docstrings": [
          "`slice(array, ~start, ~end)` creates a new array of items copied from `array` from `start` until (but not including) `end`.\n\nSee [`Array.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\n\nConsole.log(myArray->Array.slice(~start=1, ~end=3)) // [2, 3]\n```"
        ],
        "signature": "let slice: (array<'a>, ~start: int, ~end: int) => array<'a>"
      },
      {
        "id": "Core.Array.sliceToEnd",
        "kind": "value",
        "name": "sliceToEnd",
        "docstrings": [
          "`sliceToEnd(array, start)` creates a new array from `array`, with all items from `array` starting from `start`.\n\nSee [`Array.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) on MDN.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3, 4]\n\nConsole.log(myArray->Array.sliceToEnd(~start=1)) // [2, 3, 4]\n```"
        ],
        "signature": "let sliceToEnd: (array<'a>, ~start: int) => array<'a>"
      },
      {
        "id": "Core.Array.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(array)` makes a copy of the array with the items in it, but does not make copies of the items themselves.\n\n## Examples\n```rescript\nlet myArray = [1, 2, 3]\nlet copyOfMyArray = myArray->Array.copy\n\nConsole.log(copyOfMyArray) // [1, 2, 3]\nConsole.log(myArray === copyOfMyArray) // false\n```"
        ],
        "signature": "let copy: array<'a> => array<'a>"
      },
      {
        "id": "Core.Array.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "`toString(array)` stringifies `array` by running `toString` on all of the array elements and joining them with \",\".\n\nSee [`Array.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.toString) // \"1,2,3,4\"\n```"
        ],
        "signature": "let toString: array<'a> => string"
      },
      {
        "id": "Core.Array.toLocaleString",
        "kind": "value",
        "name": "toLocaleString",
        "docstrings": [],
        "signature": "let toLocaleString: array<'a> => string"
      },
      {
        "id": "Core.Array.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(array, predicate)` returns true if `predicate` returns true for all items in `array`.\n\nSee [`Array.every`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.every(num => num <= 4)) // true\nConsole.log(array->Array.every(num => num === 1)) // false\n```"
        ],
        "signature": "let every: (array<'a>, 'a => bool) => bool"
      },
      {
        "id": "Core.Array.everyWithIndex",
        "kind": "value",
        "name": "everyWithIndex",
        "docstrings": [
          "`everyWithIndex(array, checker)` returns true if all items in `array` returns true when running the provided `checker` function.\n\nSee [`Array.every`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.everyWithIndex((num, index) => index < 2 && num <= 2)) // true\nConsole.log(array->Array.everyWithIndex((num, index) => index < 2 && num >= 2)) // false\n```"
        ],
        "signature": "let everyWithIndex: (array<'a>, ('a, int) => bool) => bool"
      },
      {
        "id": "Core.Array.filter",
        "kind": "value",
        "name": "filter",
        "docstrings": [
          "`filter(array, checker)` returns a new array containing all elements from `array` for which the provided `checker` function returns true.\n\nSee [`Array.filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.filter(num => num > 2)) // [3, 4]\n```"
        ],
        "signature": "let filter: (array<'a>, 'a => bool) => array<'a>"
      },
      {
        "id": "Core.Array.filterWithIndex",
        "kind": "value",
        "name": "filterWithIndex",
        "docstrings": [
          "`filterWithIndex(array, checker)` returns a new array containing all elements from `array` for which the provided `checker` function returns true.\n\nSee [`Array.filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) on MDN.\n\n## Examples\n```rescript\nlet array = [1, 2, 3, 4]\n\nConsole.log(array->Array.filterWithIndex((num, index) => index === 0 || num === 2)) // [1, 2]\n```"
        ],
        "signature": "let filterWithIndex: (array<'a>, ('a, int) => bool) => array<'a>"
      },
      {
        "id": "Core.Array.find",
        "kind": "value",
        "name": "find",
        "docstrings": [
          "`find(array, checker)` returns the first element of `array` where the provided `checker` function returns true.\n\nSee [`Array.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, TypeScript, JavaScript]\n\nswitch array->Array.find(item => item == ReScript) {\n| None => Console.log(\"No item...\")\n| Some(_) => Console.log(\"Yay, ReScript!\")\n}\n```"
        ],
        "signature": "let find: (array<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Core.Array.findWithIndex",
        "kind": "value",
        "name": "findWithIndex",
        "docstrings": [
          "`findWithIndex(array, checker)` returns the first element of `array` where the provided `checker` function returns true.\n\nSee [`Array.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [TypeScript, JavaScript, ReScript]\n\nswitch array->Array.findWithIndex((item, index) => index > 1 && item == ReScript) {\n| None => Console.log(\"No item...\")\n| Some(_) => Console.log(\"Yay, ReScript exists in a later position!\")\n}\n```"
        ],
        "signature": "let findWithIndex: (array<'a>, ('a, int) => bool) => option<'a>"
      },
      {
        "id": "Core.Array.findIndex",
        "kind": "value",
        "name": "findIndex",
        "docstrings": [
          "`findIndex(array, checker)` returns the index of the first element of `array` where the provided `checker` function returns true.\n\nReturns `-1` if the item does not exist. Consider using `Array.findIndexOpt` if you want an option instead (where `-1` would be `None`).\n\nSee [`Array.findIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, JavaScript]\n\nConsole.log(array->Array.findIndex(item => item == ReScript)) // 0\nConsole.log(array->Array.findIndex(item => item == TypeScript)) // -1\n```"
        ],
        "signature": "let findIndex: (array<'a>, 'a => bool) => int"
      },
      {
        "id": "Core.Array.findIndexWithIndex",
        "kind": "value",
        "name": "findIndexWithIndex",
        "docstrings": [
          "`findIndexWithIndex(array, checker)` returns the index of the first element of `array` where the provided `checker` function returns true.\n\nReturns `-1` if the item does not exist. Consider using `Array.findIndexOpt` if you want an option instead (where `-1` would be `None`).\n\nSee [`Array.findIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, JavaScript]\n\nlet isReScriptFirst = array->Array.findIndexWithIndex((item, index) => index === 0 && item == ReScript)\nlet isTypeScriptFirst = array->Array.findIndexWithIndex((item, index) => index === 0 && item == TypeScript)\n\nConsole.log(isReScriptFirst) // 0\nConsole.log(isTypeScriptFirst) // -1\n```"
        ],
        "signature": "let findIndexWithIndex: (array<'a>, ('a, int) => bool) => int"
      },
      {
        "id": "Core.Array.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(array, fn)` runs the provided `fn` on every element of `array`.\n\nSee [`Array.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\narray->Array.forEach(item => {\n  Console.log(item)\n})\n```"
        ],
        "signature": "let forEach: (array<'a>, 'a => unit) => unit"
      },
      {
        "id": "Core.Array.forEachWithIndex",
        "kind": "value",
        "name": "forEachWithIndex",
        "docstrings": [
          "`forEachWithIndex(array, fn)` runs the provided `fn` on every element of `array`.\n\nSee [`Array.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\narray->Array.forEachWithIndex((item, index) => {\n  Console.log(\"At item \" ++ Int.toString(index) ++ \": \" ++ item)\n})\n```"
        ],
        "signature": "let forEachWithIndex: (array<'a>, ('a, int) => unit) => unit"
      },
      {
        "id": "Core.Array.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(array, fn)` returns a new array with all elements from `array`, each element transformed using the provided `fn`.\n\nSee [`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\nlet mappedArray = array->Array.map(greeting => greeting ++ \" to you\")\n\nConsole.log(mappedArray) // [\"Hello to you\", \"Hi to you\", \"Good bye to you\"]\n```"
        ],
        "signature": "let map: (array<'a>, 'a => 'b) => array<'b>"
      },
      {
        "id": "Core.Array.mapWithIndex",
        "kind": "value",
        "name": "mapWithIndex",
        "docstrings": [
          "`mapWithIndex(array, fn)` returns a new array with all elements from `array`, each element transformed using the provided `fn`.\n\nSee [`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\nlet mappedArray =\n  array->Array.mapWithIndex((greeting, index) =>\n    greeting ++ \" at position \" ++ Int.toString(index)\n  )\n\nConsole.log(mappedArray) // [\"Hello at position 0\", \"Hi at position 1\", \"Good bye at position 2\"]\n```"
        ],
        "signature": "let mapWithIndex: (array<'a>, ('a, int) => 'b) => array<'b>"
      },
      {
        "id": "Core.Array.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(xs, init, fn)`\n\n  Applies `fn` to each element of `xs` from beginning to end. Function `fn` has two parameters: the item from the list and an accumulator; which starts with a value of `init`. `reduce` returns the final value of the accumulator.\n\n  ```res example\n  Array.reduce([2, 3, 4], 1, (a, b) => a + b) == 10\n\n  Array.reduce([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"abcd\"\n  ```"
        ],
        "signature": "let reduce: (array<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Core.Array.reduceWithIndex",
        "kind": "value",
        "name": "reduceWithIndex",
        "docstrings": [
          "`reduceWithIndex(x, init, fn)`\n\n  Applies `fn` to each element of `xs` from beginning to end. Function `fn` has three parameters: the item from the array and an accumulator, which starts with a value of `init` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.\n\n  ```res example\n  Array.reduceWithIndex([1, 2, 3, 4], 0, (acc, x, i) => acc + x + i) == 16\n  ```"
        ],
        "signature": "let reduceWithIndex: (array<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Core.Array.reduceRight",
        "kind": "value",
        "name": "reduceRight",
        "docstrings": [
          "`reduceRight(xs, init, fn)`\n\n  Works like `Array.reduce`; except that function `fn` is applied to each item of `xs` from the last back to the first.\n\n  ```res example\n  Array.reduceRight([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"dcba\"\n  ```"
        ],
        "signature": "let reduceRight: (array<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Core.Array.reduceRightWithIndex",
        "kind": "value",
        "name": "reduceRightWithIndex",
        "docstrings": [
          "`reduceRightWithIndex(xs, init, fn)`\n\n  Like `reduceRight`, but with an additional index argument on the callback function.\n\n  ```res example\n  Array.reduceRightWithIndex([1, 2, 3, 4], 0, (acc, x, i) => acc + x + i) == 16\n  ```"
        ],
        "signature": "let reduceRightWithIndex: (array<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Core.Array.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(array, predicate)` returns true if `predicate` returns true for any element in `array`.\n\nSee [`Array.some`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\nConsole.log(array->Array.some(greeting => greeting === \"Hello\")) // true\n```"
        ],
        "signature": "let some: (array<'a>, 'a => bool) => bool"
      },
      {
        "id": "Core.Array.someWithIndex",
        "kind": "value",
        "name": "someWithIndex",
        "docstrings": [
          "`someWithIndex(array, checker)` returns true if running the provided `checker` function on any element in `array` returns true.\n\nSee [`Array.some`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) on MDN.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\nConsole.log(array->Array.someWithIndex((greeting, index) => greeting === \"Hello\" && index === 0)) // true\n```"
        ],
        "signature": "let someWithIndex: (array<'a>, ('a, int) => bool) => bool"
      },
      {
        "id": "Core.Array.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "`get(array, index)` returns the element at `index` of `array`.\n\nReturns `None` if the index does not exist in the array. Equivalent to doing `array[index]` in JavaScript.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\narray->Array.get(0) == Some(\"Hello\") // true\narray->Array.get(3) == None // true\n```"
        ],
        "signature": "let get: (array<'a>, int) => option<'a>"
      },
      {
        "id": "Core.Array.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(array, index, item)` sets the provided `item` at `index` of `array`.\n\nBeware this will *mutate* the array.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\narray->Array.set(1, \"Hello\")\n\nConsole.log(array[1]) // \"Hello\"\n```"
        ],
        "signature": "let set: (array<'a>, int, 'a) => unit"
      },
      {
        "id": "Core.Array.getSymbol",
        "kind": "value",
        "name": "getSymbol",
        "docstrings": [],
        "signature": "let getSymbol: (array<'a>, Core__Symbol.t) => option<'b>"
      },
      {
        "id": "Core.Array.getSymbolUnsafe",
        "kind": "value",
        "name": "getSymbolUnsafe",
        "docstrings": [],
        "signature": "let getSymbolUnsafe: (array<'a>, Core__Symbol.t) => 'b"
      },
      {
        "id": "Core.Array.setSymbol",
        "kind": "value",
        "name": "setSymbol",
        "docstrings": [],
        "signature": "let setSymbol: (array<'a>, Core__Symbol.t, 'b) => unit"
      },
      {
        "id": "Core.Array.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(array, index)` returns the element at `index` of `array`.\n\nThis is _unsafe_, meaning it will return `undefined` value if `index` does not exist in `array`.\n\nUse `Array.getUnsafe` only when you are sure the `index` exists (i.e. when using for-loop).\n\n## Examples\n```rescript\nlet array = [1, 2, 3]\nfor index in 0 to array->Array.length - 1 {\n  let value = array->Array.getUnsafe(index)\n  Console.log(value)\n}\n```"
        ],
        "signature": "let getUnsafe: (array<'a>, int) => 'a"
      },
      {
        "id": "Core.Array.setUnsafe",
        "kind": "value",
        "name": "setUnsafe",
        "docstrings": [
          "`setUnsafe(array, index, item)` sets the provided `item` at `index` of `array`.\n\nBeware this will *mutate* the array, and is *unsafe*.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\narray->Array.setUnsafe(1, \"Hello\")\n\nConsole.log(array[1]) // \"Hello\"\n```"
        ],
        "signature": "let setUnsafe: (array<'a>, int, 'a) => unit"
      },
      {
        "id": "Core.Array.findIndexOpt",
        "kind": "value",
        "name": "findIndexOpt",
        "docstrings": [
          "`findIndexOpt(array, checker)` returns the index of the first element of `array` where the provided `checker` function returns true.\n\nReturns `None` if no item matches.\n\nSee [`Array.findIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) on MDN.\n\n## Examples\n```rescript\ntype languages = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, TypeScript, JavaScript]\n\nswitch array->Array.findIndexOpt(item => item == ReScript) {\n| None => Console.log(\"Ahh, no ReScript...\")\n| Some(index) => Console.log(\"Yay, ReScript at index \" ++ Int.toString(index))\n}\n```"
        ],
        "signature": "let findIndexOpt: (array<'a>, 'a => bool) => option<int>"
      },
      {
        "id": "Core.Array.toReversed",
        "kind": "value",
        "name": "toReversed",
        "docstrings": [
          "`toReversed(array)` creates a new array with all items from `array` in reversed order.\n\nSee [`Array.toReversed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed) on MDN.\n\n## Examples\n```rescript\nlet someArray = [\"hi\", \"hello\"]\nlet reversed = someArray->Array.toReversed\n\nConsole.log(reversed) // [\"hello\", \"h1\"]\nConsole.log(someArray) // [\"h1\", \"hello\"]. Original unchanged\n```"
        ],
        "signature": "let toReversed: array<'a> => array<'a>"
      },
      {
        "id": "Core.Array.filterMap",
        "kind": "value",
        "name": "filterMap",
        "docstrings": [
          "`filterMap(array, fn)`\n\nCalls `fn` for each element and returns a new array containing results of the `fn` calls which are not `None`.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\nConsole.log(\n  array->Array.filterMap(item =>\n    switch item {\n    | \"Hello\" => Some(item->String.length)\n    | _ => None\n    }\n  ),\n) // [5]\n```"
        ],
        "signature": "let filterMap: (array<'a>, 'a => option<'b>) => array<'b>"
      },
      {
        "id": "Core.Array.keepSome",
        "kind": "value",
        "name": "keepSome",
        "docstrings": [
          "`keepSome(arr)`\n\n  Returns a new array containing `value` for all elements that are `Some(value)`\n  and ignoring every value that is `None`\n\n  ```res example\n  Array.keepSome([Some(1), None, Some(3)]) == [1, 3]\n  ```"
        ],
        "signature": "let keepSome: array<option<'a>> => array<'a>"
      },
      {
        "id": "Core.Array.toShuffled",
        "kind": "value",
        "name": "toShuffled",
        "docstrings": [
          "`toShuffled(array)` returns a new array with all items in `array` in a random order.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\nlet shuffledArray = array->Array.toShuffled\n\nConsole.log(shuffledArray)\n```"
        ],
        "signature": "let toShuffled: array<'a> => array<'a>"
      },
      {
        "id": "Core.Array.shuffle",
        "kind": "value",
        "name": "shuffle",
        "docstrings": [
          "`shuffle(array)` randomizes the position of all items in `array`.\n\nBeware this will *mutate* the array.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\narray->Array.shuffle\n\nConsole.log(array)\n```"
        ],
        "signature": "let shuffle: array<'a> => unit"
      },
      {
        "id": "Core.Array.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(array, mapper)` returns a new array concatenating the arrays returned from running `mapper` on all items in `array`.\n\n## Examples\n```rescript\ntype language = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, TypeScript, JavaScript]\n\nConsole.log(\n  array->Array.flatMap(item =>\n    switch item {\n    | ReScript => [1, 2, 3]\n    | TypeScript => [4, 5, 6]\n    | JavaScript => [7, 8, 9]\n    }\n  ),\n)\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```"
        ],
        "signature": "let flatMap: (array<'a>, 'a => array<'b>) => array<'b>"
      },
      {
        "id": "Core.Array.flatMapWithIndex",
        "kind": "value",
        "name": "flatMapWithIndex",
        "docstrings": [
          "`flatMapWithIndex(array, mapper)` returns a new array concatenating the arrays returned from running `mapper` on all items in `array`.\n\n## Examples\n```rescript\ntype language = ReScript | TypeScript | JavaScript\n\nlet array = [ReScript, TypeScript, JavaScript]\n\nConsole.log(\n  array->Array.flatMapWithIndex((item, index) =>\n    switch item {\n    | ReScript => [index]\n    | TypeScript => [index, index + 1]\n    | JavaScript => [index, index + 1, index + 2]\n    }\n  ),\n)\n// [0, 1, 2, 2, 3, 4]\n```"
        ],
        "signature": "let flatMapWithIndex: (array<'a>, ('a, int) => array<'b>) => array<'b>"
      },
      {
        "id": "Core.Array.findMap",
        "kind": "value",
        "name": "findMap",
        "docstrings": [
          "`findMap(arr, fn)`\n\n  Calls `fn` for each element and returns the first value from `fn` that is `Some(_)`.\n  Otherwise returns `None`\n\n  ```res example\n  Array.findMap([1, 2, 3], n => mod(n, 2) == 0 ? Some(n - 2) : None) == Some(0) // true\n  ```"
        ],
        "signature": "let findMap: (array<'a>, 'a => option<'b>) => option<'b>"
      },
      {
        "id": "Core.Array.at",
        "kind": "value",
        "name": "at",
        "docstrings": [
          "`at(array, index)`\n\n  Get an element by its index. Negative indices count backwards from the last item.\n\n  ## Examples\n  ```rescript\n  [\"a\", \"b\", \"c\"]->Array.at(0) // Some(\"a\")\n  [\"a\", \"b\", \"c\"]->Array.at(2) // Some(\"c\")\n  [\"a\", \"b\", \"c\"]->Array.at(3) // None\n  [\"a\", \"b\", \"c\"]->Array.at(-1) // Some(\"c\")\n  [\"a\", \"b\", \"c\"]->Array.at(-3) // Some(\"a\")\n  [\"a\", \"b\", \"c\"]->Array.at(-4) // None\n  ```"
        ],
        "signature": "let at: (array<'a>, int) => option<'a>"
      },
      {
        "id": "Core.Array.last",
        "kind": "value",
        "name": "last",
        "docstrings": [
          "`last(array)` returns the last element of `array`.\n\nReturns `None` if the array is empty.\n\n## Examples\n```rescript\nlet array = [\"Hello\", \"Hi\", \"Good bye\"]\n\narray->Array.last == Some(\"Good bye\") // true\n[]->Array.last == None // true\n```"
        ],
        "signature": "let last: array<'a> => option<'a>"
      }
    ]
  }
}