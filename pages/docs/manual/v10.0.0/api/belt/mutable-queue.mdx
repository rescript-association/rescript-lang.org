# MutableQueue

<Intro>

An FIFO(first in first out) queue data structure.

</Intro>

## t

```res prelude
type t<'a>
```

The type of queues containing elements of `type('a)`.

## make

```res sig
let make: unit => t<'a>
```

Returns a new queue, initially empty.

## clear

```res sig
let clear: t<'a> => unit
```

Discard all elements from the queue.

## isEmpty

```res sig
let isEmpty: t<'a> => bool
```

Returns `true` if the given queue is empty, `false` otherwise.

## fromArray

```res sig
let fromArray: array<'a> => t<'a>
```

`fromArray` a is equivalent to `Array.forEach(a, add(q, a));`

## add

```res sig
let add: (t<'a>, 'a) => unit
```

`add(q, x)` adds the element `x` at the end of the queue `q`.

## peek

```res sig
let peek: t<'a> => option<'a>
```

`peekOpt(q)` returns the first element in queue `q`, without removing it from the queue.

## peekUndefined

```res sig
let peekUndefined: t<'a> => Js.undefined<'a>
```

`peekUndefined(q)` returns `undefined` if not found.

## peekExn

```res sig
let peekExn: t<'a> => 'a
```

raise an exception if `q` is empty

## pop

```res sig
let pop: t<'a> => option<'a>
```

`pop(q)` removes and returns the first element in queue `q`.

## popUndefined

```res sig
let popUndefined: t<'a> => Js.undefined<'a>
```

`popUndefined(q)` removes and returns the first element in queue `q`. it will return `undefined` if it is already empty.

## popExn

```res sig
let popExn: t<'a> => 'a
```

`popExn(q)` raise an exception if q is empty.

## copy

```res sig
let copy: t<'a> => t<'a>
```

`copy(q)` returns a fresh queue.

## size

```res sig
let size: t<'a> => int
```

Returns the number of elements in a queue.

## mapU

```res sig
let mapU: (t<'a>, (. 'a) => 'b) => t<'b>
```

## map

```res sig
let map: (t<'a>, 'a => 'b) => t<'b>
```

## forEachU

```res sig
let forEachU: (t<'a>, (. 'a) => unit) => unit
```

## forEach

```res sig
let forEach: (t<'a>, 'a => unit) => unit
```

`forEach(q, f) applies`f`in turn to all elements of`q`, from the least recently entered to the most recently entered. The queue itself is unchanged.

## reduceU

```res sig
let reduceU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b
```

## reduce

```res sig
let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b
```

`reduce(q, accu, f)` is equivalent to `List.reduce(l, accu, f)`, where `l` is the list of `q`'s elements. The queue remains unchanged.

## transfer

```res sig
let transfer: (t<'a>, t<'a>) => unit
```

`transfer(q1, q2)` adds all of `q1`'s elements at the end of the queue `q2`, then clears `q1`. It is equivalent to the sequence `forEach((x) => add(x, q2), q1);`; clear `q1`, but runs in constant time.

## toArray

```res sig
let toArray: t<'a> => array<'a>
```

First added will be in the beginning of the array.
