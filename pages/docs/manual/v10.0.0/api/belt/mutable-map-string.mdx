# MutableMapString

## key

```res prelude
type key = string
```

## t

```res prelude
type t<'a>
```

## make

```res sig
let make: unit => t<'a>
```

## clear

```res sig
let clear: t<'a> => unit
```

## isEmpty

```res sig
let isEmpty: t<'a> => bool
```

## has

```res sig
let has: (t<'a>, key) => bool
```

## cmpU

```res sig
let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int
```

## cmp

```res sig
let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int
```

`cmp(m1, m2, cmp)` First compare by size, if size is the same, compare by key, value pair.

## eqU

```res sig
let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool
```

## eq

```res sig
let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool
```

`eq(m1, m2, cmp)`

## forEachU

```res sig
let forEachU: (t<'a>, (. key, 'a) => unit) => unit
```

## forEach

```res sig
let forEach: (t<'a>, (key, 'a) => unit) => unit
```

`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the key as first argument, and the associated value as second argument. The application order of `f` is in increasing order.

## reduceU

```res sig
let reduceU: (t<'a>, 'b, (. 'b, key, 'a) => 'b) => 'b
```

## reduce

```res sig
let reduce: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b
```

`reduce(m, a, f), computes`(f(kN, dN) ... (f(k1, d1, a))...)`, where`k1 ... kN`are the keys of all bindings in`m`(in increasing order), and`d1 ... dN` are the associated data.

## everyU

```res sig
let everyU: (t<'a>, (. key, 'a) => bool) => bool
```

## every

```res sig
let every: (t<'a>, (key, 'a) => bool) => bool
```

`every(m, p)` checks if all the bindings of the map satisfy the predicate `p`. The application order of `p` is unspecified.

## someU

```res sig
let someU: (t<'a>, (. key, 'a) => bool) => bool
```

## some

```res sig
let some: (t<'a>, (key, 'a) => bool) => bool
```

`some(m, p)` checks if at least one binding of the map satisfy the predicate `p`. The application order of `p` is unspecified.

## size

```res sig
let size: t<'a> => int
```

## toList

```res sig
let toList: t<'a> => list<(key, 'a)>
```

In increasing order

## toArray

```res sig
let toArray: t<'a> => array<(key, 'a)>
```

## fromArray

```res sig
let fromArray: array<(key, 'a)> => t<'a>
```

## keysToArray

```res sig
let keysToArray: t<'a> => array<key>
```

## valuesToArray

```res sig
let valuesToArray: t<'a> => array<'a>
```

## minKey

```res sig
let minKey: t<'a> => option<key>
```

## minKeyUndefined

```res sig
let minKeyUndefined: t<'a> => Js.undefined<key>
```

## maxKey

```res sig
let maxKey: t<'a> => option<key>
```

## maxKeyUndefined

```res sig
let maxKeyUndefined: t<'a> => Js.undefined<key>
```

## minimum

```res sig
let minimum: t<'a> => option<(key, 'a)>
```

## minUndefined

```res sig
let minUndefined: t<'a> => Js.undefined<(key, 'a)>
```

## maximum

```res sig
let maximum: t<'a> => option<(key, 'a)>
```

## maxUndefined

```res sig
let maxUndefined: t<'a> => Js.undefined<(key, 'a)>
```

## get

```res sig
let get: (t<'a>, key) => option<'a>
```

## getUndefined

```res sig
let getUndefined: (t<'a>, key) => Js.undefined<'a>
```

## getWithDefault

```res sig
let getWithDefault: (t<'a>, key, 'a) => 'a
```

## getExn

```res sig
let getExn: (t<'a>, key) => 'a
```

## checkInvariantInternal

```res sig
let checkInvariantInternal: t<'a> => unit
```

Raise when invariant is not held.

## remove

```res sig
let remove: (t<'a>, key) => unit
```

`remove(m, x)` do the in-place modification.

## removeMany

```res sig
let removeMany: (t<'a>, array<key>) => unit
```

## set

```res sig
let set: (t<'a>, key, 'a) => unit
```

`set(m, x, y)` do the in-place modification, return `m` for chaining. If `x` was already bound in `m`, its previous binding disappears.

## updateU

```res sig
let updateU: (t<'a>, key, (. option<'a>) => option<'a>) => unit
```

## update

```res sig
let update: (t<'a>, key, option<'a> => option<'a>) => unit
```

## mapU

```res sig
let mapU: (t<'a>, (. 'a) => 'b) => t<'b>
```

## map

```res sig
let map: (t<'a>, 'a => 'b) => t<'b>
```

`map(m, f)` returns a map with same domain as `m`, where the associated value a of all bindings of `m` has been replaced by the result of the application of `f` to `a`. The bindings are passed to `f` in increasing order with respect to the ordering over the type of the keys.

## mapWithKeyU

```res sig
let mapWithKeyU: (t<'a>, (. key, 'a) => 'b) => t<'b>
```

## mapWithKey

```res sig
let mapWithKey: (t<'a>, (key, 'a) => 'b) => t<'b>
```
