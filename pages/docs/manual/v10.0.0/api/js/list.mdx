# List

<Intro>

Provide utilities for list.

</Intro>

## t

```res prelude
type t<'a> = list<'a>
```

## length

```res sig
let length: t<'a> => int
```

## cons

```res sig
let cons: ('a, t<'a>) => t<'a>
```

## isEmpty

```res sig
let isEmpty: t<'a> => bool
```

## hd

```res sig
let hd: t<'a> => option<'a>
```

## tl

```res sig
let tl: t<'a> => option<t<'a>>
```

## nth

```res sig
let nth: (t<'a>, int) => option<'a>
```

## revAppend

```res sig
let revAppend: (t<'a>, t<'a>) => t<'a>
```

## rev

```res sig
let rev: t<'a> => t<'a>
```

## mapRev

```res sig
let mapRev: ((. 'a) => 'b, t<'a>) => t<'b>
```

## map

```res sig
let map: ((. 'a) => 'b, t<'a>) => t<'b>
```

## iter

```res sig
let iter: ((. 'a) => unit, t<'a>) => unit
```

## iteri

```res sig
let iteri: ((. int, 'a) => unit, t<'a>) => unit
```

## foldLeft

```res sig
let foldLeft: ((. 'a, 'b) => 'a, 'a, list<'b>) => 'a
```

Application order is left to right, tail-recurisve.

## foldRight

```res sig
let foldRight: ((. 'a, 'b) => 'b, list<'a>, 'b) => 'b
```

Application order is right to left, tail-recursive.

## flatten

```res sig
let flatten: t<t<'a>> => t<'a>
```

## filter

```res sig
let filter: ((. 'a) => bool, t<'a>) => t<'a>
```

## filterMap

```res sig
let filterMap: ((. 'a) => option<'b>, t<'a>) => t<'b>
```

## countBy

```res sig
let countBy: ((. 'a) => bool, list<'a>) => int
```

## init

```res sig
let init: (int, (. int) => 'a) => t<'a>
```

## toVector

```res sig
let toVector: t<'a> => Js_vector.t<'a>
```

## equal

```res sig
let equal: ((. 'a, 'a) => bool, list<'a>, list<'a>) => bool
```
