---
title: "Array & List"
description: "Arrays and List data structures"
canonical: "/docs/manual/latest/array-and-list"
---

# Array and List

## Array

Arrays are our main ordered data structure. They work the same way as JavaScript arrays: they can be randomly accessed, dynamically resized, updated, etc.

<CodeTab labels={["Reason (Old Syntax)", "ML (Older Syntax)", "JS Output"]}>

```re
let myArray = [|"hello", "world", "how are you"|];
```
```ml
let myArray = [|"hello"; "world"; "how are you"|]
```
```js
var myArray = ["hello", "world", "how are you"];
```

</CodeTab>

ReScript arrays' items must have the same type, i.e. homogeneous.

### Usage

See the [Js.Array](api/js/array) API.

Access & update an array item like so:

<CodeTab labels={["Reason (Old Syntax)", "ML (Older Syntax)", "JS Output"]}>

```re
let myArray = [|"hello", "world", "how are you"|];

let firstItem = myArray[0]; // "hello"

myArray[0] = "hey"; // now [|"hey", "world", "how are you"|]

let pushedValue = Js.Array2.push(myArray, "bye");
```
```ml
let myArray = [|"hello"; "world"; "how are you"|]

let firstItem = myArray(0)  (* "hello" *)

let () = myArray.(0) <- "hey" (* now [|"hey"; "world"; "how are you"|] *)
```
```js
var myArray = ["hello", "world", "how are you"];

var firstItem = myArray[0];

myArray[0] = "hey";

var pushedValue = myArray.push("bye");
```

</CodeTab>

## List

ReScript provides a singly linked list too. Lists are:

- immutable
- fast at prepending items
- fast at getting the tail
- slow at everything else

<CodeTab labels={["Reason (Old Syntax)", "ML (Older Syntax)", "JS Output"]}>

```re
let myList = [1, 2, 3];
```
```ml
let myList = [1; 2; 3]
```
```js
var myList = {
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: 0
    }
  }
};
```

</CodeTab>

Like arrays, lists' items need to be of the same type.

### Usage

You'd use list for its resizability, its fast prepend (adding at the head), and its fast split, all of which are immutable and relatively efficient.

Do **not** use list if you need to randomly access an item or insert at non-head position. Your code would end up obtuse and/or slow.

The standard lib provides a [List module](api/belt/list).

#### Immutable Prepend

Use the spread syntax:

<CodeTab labels={["Reason (Old Syntax)", "ML (Older Syntax)", "JS Output"]}>

```re
let myList = [1, 2, 3];
let anotherList = [0, ...myList];
```
```ml
let myList = [1; 2; 3]
let anotherList = 0 :: myList
```
```js
var myList = {
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: 0
    }
  }
};

var anotherList = {
  hd: 0,
  tl: myList
};
```

</CodeTab>

`myList` didn't mutate. `anotherList` is now `[0, 1, 2, 3]`. This is efficient (constant time, not linear). `anotherList`'s last 3 elements are shared with `myList`!

**Note that `[a, ...b, ...c]` is a syntax error**. We don't support multiple spread for a list. That'd be an accidental linear operation (`O(b)`), since each item of b would be one-by-one added to the head of `c`. You can use `List.concat` for this, but we highly discourage it.

Updating an arbitrary item in the middle of a list is also discouraged, since its performance and allocation overhead would be linear (`O(n)`).

#### Access

`switch` (described in the [pattern matching section](pattern-matching-destructuring.md)) is usually used to access list items:

<CodeTab labels={["Reason (Old Syntax)", "ML (Older Syntax)", "JS Output"]}>

```re
let message =
  switch myList {
  | [] => "This list is empty"
  | [a, ...rest] => "The head of the list is the string " ++ Js.Int.toString(a)
  };
```
```ml
let message =
  match myList with
  | [] -> "This list is empty"
  | a::rest -> "The head of the list is the string " ^ (Js.Int.toString a)
```
```js
var message = myList
  ? "The head of the list is the string " + (1).toString()
  : "This list is empty";
```

</CodeTab>
