---
title: "Extensible Variant"
description: "Extensible Variants in ReScript"
canonical: "/docs/manual/latest/extensible-variant"
---

# Extensible Variant

Variant types are usually constraint to a fixed set of constructors that are defined in its type declaration. There may be very rare cases where you still want to be able to add constructors to a variant type (e.g. in different places of your program). For this, we offer extensible variant types.

## Definition and Usage

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
type t = ..

type t += Other

type t +=
  | Point(float, float)
  | Line(float, float, float, float)
```
```js
var Caml_exceptions = require("./stdlib/caml_exceptions.js");

var Other = Caml_exceptions.create("Playground.Other");

var Point = Caml_exceptions.create("Playground.Point");

var Line = Caml_exceptions.create("Playground.Line");
```

</CodeTab>

Pattern-matching is possible the same way as with normal variants but there is one caveat:
With extensible variants, the possibility to check for exhaustiveness vanishes, you always need a default case `_` here.


<CodeTab labels={["ReScript", "JS Output"]}>


```res example
let print = v =>
  switch v {
  | Point(x, y) => Js.log2("Point", (x, y))
  | Line(ax, ay, bx, by) => Js.log2("Line", (ax, ay, bx, by))
  | Other
  | _ => Js.log("Other")
  }
```
```js
function print(v) {
  if (v.RE_EXN_ID === Point) {
    console.log("Point", [v._1, v._2]);
  } else if (v.RE_EXN_ID === Line) {
    console.log("Line", [v._1, v._2, v._3, v._4]);
  } else {
    console.log("Other");
  } 
}
```

</CodeTab>