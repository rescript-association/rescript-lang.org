---
title: memo
description: "using React.memo"
canonical: "/docs/react/latest/memo"
---

# memo

`React.memo` lets you skip re-rendering a component when its props are unchanged.

Wrap a component in memo to get a memoized version of that component.
This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed.

<small>But React may still re-render it: memoization is a performance optimization, not a guarantee.</small>

<CodeTab labels={["ReScript", "JS Output"]}>

```res
@react.component
let make = React.memo((~a: int, ~b: string) => {
  <div>
    {React.int(a)}
    <br />
    {React.string(b)}
  </div>
})
```

```js
import * as React from "react";
import * as JsxRuntime from "react/jsx-runtime";

var make = React.memo(function (props) {
      return JsxRuntime.jsxs("div", {
                  children: [
                    props.a,
                    JsxRuntime.jsx("br", {}),
                    props.b
                  ]
                });
    });
```

</CodeTab>

## arePropsEqual

In React, memo can accept an optional argument called "arePropsEqual". This function takes two arguments: the previous props and the new props of the component.
It should return true if the old and new props are the same, meaning the component will produce the same output and behavior with the new props as it did with the old ones.

In ReScript, to use the `arePropsEqual` function, you must redefine the `memo` binding.

<CodeTab>

```res
type propsDef = {
  disabled: bool,
  onClick: unit => unit,
}

// Refine memo to satify the compiler.
let memo = React.memoCustomCompareProps(_, (p1, p2) =>
  p1.disabled == p2.disabled
)

@react.component(: propsDef)
let make = memo((~disabled, ~onClick) => {
  <button
    disabled={disabled}
    onClick={ev => ev->JsxEvent.Mouse.preventDefault->onClick}>
    {React.string("My button")}
  </button>
})
```

```js
import * as React from "react";
import * as JsxRuntime from "react/jsx-runtime";

function memo(__x) {
  return React.memo(__x, (function (p1, p2) {
                return p1.disabled === p2.disabled;
              }));
}

var make = memo(function (props) {
      var onClick = props.onClick;
      return JsxRuntime.jsx("button", {
                  children: "My button",
                  disabled: props.disabled,
                  onClick: (function (ev) {
                      onClick((ev.preventDefault(), undefined));
                    })
                });
    });
```

</CodeTab>